<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulation &mdash; physx 5.3.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css" />
      <link rel="stylesheet" href="../_static/omni-style.css" type="text/css" />
      <link rel="stylesheet" href="../_static/api-styles.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/mermaid-init.js"></script>
        <script src="../_static/design-tabs.js"></script>
        <script src="../_static/version.js"></script>
        <script src="../_static/social-media.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Advanced Collision Detection" href="AdvancedCollisionDetection.html" />
    <link rel="prev" title="Rigid Body Dynamics" href="RigidBodyDynamics.html" />
 


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


  <a href="../index.html">
  <img src="../_static/PhysXLogoWhite.png" class="logo" alt="Logo"/>
</a>

<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="License.html">PhysX License</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingWithPhysX.html">Building with PhysX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Snippets.html">Snippets</a></li>
<li class="toctree-l1"><a class="reference internal" href="API.html">PhysX API Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="Startup.html">Startup and Shutdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="Threading.html">Threading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Geometry.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="CustomGeometry.html">Custom Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="RigidBodyOverview.html">Rigid Body Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="RigidBodyCollision.html">Rigid Body Collision</a></li>
<li class="toctree-l1"><a class="reference internal" href="RigidBodyDynamics.html">Rigid Body Dynamics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Simulation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-simulation-loop">The Simulation Loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="#island-management">Island Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="#callback-sequence">Callback Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulation-memory">Simulation memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scene-limits">Scene Limits</a></li>
<li class="toctree-l3"><a class="reference internal" href="#k-data-blocks">16K Data Blocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scratch-buffer">Scratch Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#in-place-serialization">In-Place Serialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#completion-tasks">Completion Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronizing-with-other-threads">Synchronizing with Other Threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="#substepping">Substepping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#split-sim">Split sim</a></li>
<li class="toctree-l2"><a class="reference internal" href="#split-fetchresults">Split fetchResults</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shifting-the-scene-origin">Shifting The Scene Origin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="AdvancedCollisionDetection.html">Advanced Collision Detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="Joints.html">Joints</a></li>
<li class="toctree-l1"><a class="reference internal" href="Articulations.html">Articulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPURigidBodies.html">GPU Rigid Bodies</a></li>
<li class="toctree-l1"><a class="reference internal" href="SoftBodies.html">Soft Bodies</a></li>
<li class="toctree-l1"><a class="reference internal" href="ParticleSystem.html">Particle System</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeometryQueries.html">Geometry Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="SceneQueries.html">Scene Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="GjkQueries.html">Gjk Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="Vehicles.html">Vehicles</a></li>
<li class="toctree-l1"><a class="reference internal" href="CharacterControllers.html">Character Controllers</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebugVisualization.html">Debug Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OmniVisualDebugger.html">Omniverse Visual Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="Statistics.html">Simulation Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Serialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExtendingSerialization.html">Extending Serialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="BestPractices.html">Best Practices Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationFrom28.html">Migrating From PhysX SDK 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo33.html">Migrating From PhysX SDK 3.2 to 3.3</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo34.html">Migrating From PhysX SDK 3.3 to 3.4</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo40.html">Migrating From PhysX SDK 3.4 to 4.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo51.html">Migrating From PhysX SDK 4.0 to 5.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo52.html">Migrating From PhysX SDK 5.1 to 5.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo53.html">Migrating From PhysX SDK 5.2 to 5.3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_api_build/physx_api.html">PhysX SDK API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">physx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">


<li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
<li>Simulation</li>

      <li class="wy-breadcrumbs-aside">
      </li>
<li class="wy-breadcrumbs-aside">

  <span>&nbsp;</span>
</li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="simulation">
<span id="id1"></span><h1>Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline"></a></h1>
<section id="the-simulation-loop">
<span id="simulation-loop"></span><h2>The Simulation Loop<a class="headerlink" href="#the-simulation-loop" title="Permalink to this headline"></a></h2>
<p>Use the method <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a> to advance the world forward in time.
Here is simplified code snippet for a fixed time stepper:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">mAccumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="n">mStepSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">60.0f</span><span class="p">;</span><span class="w"></span>

<span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">advance</span><span class="p">(</span><span class="n">PxReal</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">mAccumulator</span><span class="w">  </span><span class="o">+=</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">mAccumulator</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">mStepSize</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">mAccumulator</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">mStepSize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">mScene</span><span class="o">-&gt;</span><span class="n">simulate</span><span class="p">(</span><span class="n">mStepSize</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This code can be called whenever the app is done with processing events and is starting to idle.
It accumulates elapsed real time until it is greater than a sixtieth of a second, and then calls <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a>, which  moves all objects in the scene forward by that interval.
This is probably the simplest of very many different ways to deal with time when stepping the simulation forward.</p>
<p>To allow the simulation to finish and return the results, simply call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">mScene</span><span class="o">-&gt;</span><span class="n">fetchResults</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>True indicates that the simulation should block until it is finished, so that on return the results are guaranteed to be available.
When <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchResults()</span></code></a> completes, any simulation event callback functions that you defined will also be called.
See the chapter <a class="reference internal" href="#callbacks"><span class="std std-ref">Callback Sequence</span></a>.
Until <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchResults()</span></code></a> returns, the results of the current simulation step are not available.
It is not allowed to add, remove or modify scene objects while the simulation is running.
See the chapter <a class="reference internal" href="Threading.html#threading"><span class="std std-ref">Threading</span></a> for more details about reading and writing while the simulation is running.</p>
<p>For the human eye to perceive animated motion as smooth, use at least twenty discrete frames per second, with each frame corresponding to a physics time step.
To have smooth, realistic simulation of more complex physical scenes, use at least fifty frames per second.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are making a real-time interactive simulation, you may be tempted to take different sized time steps which correspond to the amount of real time that has elapsed since the last simulation frame.  Be very careful if you do this, rather than taking constant-sized time steps:  The simulation code is sensitive to both very small and large time steps, and also to too much variation between time steps.  In these cases it will likely produce jittery simulation.</p>
</div>
<p>See <a class="reference internal" href="#simulation-memory"><span class="std std-ref">Simulation memory</span></a> for details on how memory is used in simulation.</p>
</section>
<section id="island-management">
<h2>Island Management<a class="headerlink" href="#island-management" title="Permalink to this headline"></a></h2>
<p>For performance reasons the simulation of scenes with multiple actors is split up into multiple islands, which are solved independently.
Each actor is assigned to exactly one island and during the solve procedure actors can only influence other actors within the same island.</p>
<p>Islands are created by finding disconnected subgraphs in a scene graph where actors are nodes and edges represent connections between actors.
The edges of the graph may be interactions between actors, for example contacts, but also explicit constraints like attachments and joints.
Most of these edges are created automatically by PhysX when contacts occur or joints are being added to the scene.
In cases where users can directly write constraints into buffers, for example <a class="reference internal" href="../_api_build/class_px_particle_system.html#_CPPv4N16PxParticleSystem17addParticleBufferEP16PxParticleBuffer" title="PxParticleSystem::addParticleBuffer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxParticleSystem::addParticleBuffer()</span></code></a>, the SDK does not inspect the content of these constraint buffers until the constraint solver is invoked.
Therefore, it is necessary that users manually take care of creating edges (e.g., through <a class="reference internal" href="../_api_build/class_px_particle_system.html#_CPPv4N16PxParticleSystem18addRigidAttachmentEP12PxRigidActor" title="PxParticleSystem::addRigidAttachment"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxParticleSystem::addRigidAttachment()</span></code></a>) such that the islands can be properly formed and interacting actors end up in the same island.</p>
</section>
<section id="callback-sequence">
<span id="callbacks"></span><h2>Callback Sequence<a class="headerlink" href="#callback-sequence" title="Permalink to this headline"></a></h2>
<p>PhysX callbacks allow any application to listen for events and react as required.</p>
<p>The following callbacks are executed:</p>
<blockquote>
<div><ul class="simple">
<li><p>onConstraintBreak</p></li>
<li><p>onWake</p></li>
<li><p>onSleep</p></li>
<li><p>onContact</p></li>
<li><p>onTrigger</p></li>
<li><p>onAdvance</p></li>
</ul>
</div></blockquote>
<p>To listen to any of these events it is necessary to subclass <a class="reference internal" href="../_api_build/class_px_simulation_event_callback.html#_CPPv425PxSimulationEventCallback" title="PxSimulationEventCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxSimulationEventCallback</span></code></a> so that the various virtual functions may be implemented as desired.
An instance of this subclass can then be registered per scene with either <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene26setSimulationEventCallbackEP25PxSimulationEventCallback" title="PxScene::setSimulationEventCallback"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::setSimulationEventCallback()</span></code></a> or <a class="reference internal" href="../_api_build/class_px_scene_desc.html#_CPPv4N11PxSceneDesc23simulationEventCallbackE" title="PxSceneDesc::simulationEventCallback"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxSceneDesc::simulationEventCallback</span></code></a>.
Following these steps alone will ensure that constraint break events are successfully reported.
One more step is required to report sleep and wake events: to avoid the expense of reporting all sleep and wake events, actors identified as worthy of sleep/wake notification require the flag <a class="reference internal" href="../_api_build/struct_px_actor_flag.html#_CPPv4N11PxActorFlag4Enum20eSEND_SLEEP_NOTIFIESE" title="PxActorFlag::eSEND_SLEEP_NOTIFIES"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxActorFlag::eSEND_SLEEP_NOTIFIES</span></code></a> to be raised.
Finally, to receive onContact and onTrigger events it is necessary to set a flag in the filter shader callback for all pairs of interacting objects for which events are required.
More details on the filter shader callback can be found in <a class="reference internal" href="RigidBodyCollision.html#collisionfiltering"><span class="std std-ref">Collision Filtering</span></a>.</p>
<p>Each callback allows read operations to be performed on the relevant actors involved in each event.
It is important to note that for all events except <a class="reference internal" href="../_api_build/class_px_simulation_event_callback.html#_CPPv4N25PxSimulationEventCallback9onAdvanceEPPCK11PxRigidBodyPK11PxTransformK5PxU32" title="PxSimulationEventCallback::onAdvance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxSimulationEventCallback::onAdvance()</span></code></a>, these read operations will return the state of the actors at the end of the simulation step rather than the state the actors had when the event was first detected during the course of the simulation step.
This particularly affects the callbacks <a class="reference internal" href="../_api_build/class_px_simulation_event_callback.html#_CPPv4N25PxSimulationEventCallback9onTriggerEP13PxTriggerPair5PxU32" title="PxSimulationEventCallback::onTrigger"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxSimulationEventCallback::onTrigger()</span></code></a>, <a class="reference internal" href="../_api_build/class_px_simulation_event_callback.html#_CPPv4N25PxSimulationEventCallback9onContactERK19PxContactPairHeaderPK13PxContactPair5PxU32" title="PxSimulationEventCallback::onContact"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxSimulationEventCallback::onContact()</span></code></a> and <a class="reference internal" href="../_api_build/class_px_simulation_event_callback.html#_CPPv4N25PxSimulationEventCallback17onConstraintBreakEP16PxConstraintInfo5PxU32" title="PxSimulationEventCallback::onConstraintBreak"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxSimulationEventCallback::onConstraintBreak()</span></code></a>.
The linear velocity, angular velocity and pose used to detect <a class="reference internal" href="../_api_build/class_px_simulation_event_callback.html#_CPPv4N25PxSimulationEventCallback9onContactERK19PxContactPairHeaderPK13PxContactPair5PxU32" title="PxSimulationEventCallback::onContact"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxSimulationEventCallback::onContact()</span></code></a> events can be retrieved by amending the simulation filter shader with the flags <a class="reference internal" href="../_api_build/struct_px_pair_flag.html#_CPPv4N10PxPairFlag4Enum20ePRE_SOLVER_VELOCITYE" title="PxPairFlag::ePRE_SOLVER_VELOCITY"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxPairFlag::ePRE_SOLVER_VELOCITY</span></code></a> and <a class="reference internal" href="../_api_build/struct_px_pair_flag.html#_CPPv4N10PxPairFlag4Enum19eCONTACT_EVENT_POSEE" title="PxPairFlag::eCONTACT_EVENT_POSE"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxPairFlag::eCONTACT_EVENT_POSE</span></code></a>.
This leads to code as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onContact</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxContactPairHeader</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxContactPair</span><span class="o">*</span><span class="w"> </span><span class="n">pairs</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="w"> </span><span class="n">nbPairs</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Retrieve the current poses and velocities of the two actors involved in the contact event.</span>

<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="w"> </span><span class="n">body0PoseAtEndOfSimulateStep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getGlobalPose</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="w"> </span><span class="n">body1PoseAtEndOfSimulateStep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getGlobalPose</span><span class="p">();</span><span class="w"></span>

<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body0LinVelAtEndOfSimulateStep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getLinearVelocity</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">PxVec3</span><span class="p">(</span><span class="n">PxZero</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body1LinVelAtEndOfSimulateStep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getLinearVelocity</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">PxVec3</span><span class="p">(</span><span class="n">PxZero</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body0AngVelAtEndOfSimulateStep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAngularVelocity</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">PxVec3</span><span class="p">(</span><span class="n">PxZero</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body1AngVelAtEndOfSimulateStep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">actors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAngularVelocity</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">PxVec3</span><span class="p">(</span><span class="n">PxZero</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Retrieve the poses and velocities of the two actors involved in the contact event as they were</span>
<span class="w">        </span><span class="c1">// when the contact event was detected.</span>

<span class="w">        </span><span class="n">PxContactPairExtraDataIterator</span><span class="w"> </span><span class="n">iter</span><span class="p">(</span><span class="n">pairHeader</span><span class="p">.</span><span class="n">extraDataStream</span><span class="p">,</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">.</span><span class="n">extraDataStreamSize</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">nextItemSet</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="w"> </span><span class="n">body0PoseAtContactEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">eventPose</span><span class="o">-&gt;</span><span class="n">globalPose</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="w"> </span><span class="n">body1PoseAtContactEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">eventPose</span><span class="o">-&gt;</span><span class="n">globalPose</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>

<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body0LinearVelocityAtContactEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">preSolverVelocity</span><span class="o">-&gt;</span><span class="n">linearVelocity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body1LinearVelocityAtContactEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">preSolverVelocity</span><span class="o">-&gt;</span><span class="n">linearVelocity</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>

<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body0AngularVelocityAtContactEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">preSolverVelocity</span><span class="o">-&gt;</span><span class="n">angularVelocity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="w"> </span><span class="n">body1AngularVelocityAtContactEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">preSolverVelocity</span><span class="o">-&gt;</span><span class="n">angularVelocity</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../_api_build/class_px_simulation_event_callback.html#_CPPv4N25PxSimulationEventCallback9onAdvanceEPPCK11PxRigidBodyPK11PxTransformK5PxU32" title="PxSimulationEventCallback::onAdvance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxSimulationEventCallback::onAdvance()</span></code></a> callback provides early access to the new pose of moving rigid bodies.
When this call occurs, rigid bodies that have the flag <a class="reference internal" href="../_api_build/struct_px_rigid_body_flag.html#_CPPv4N15PxRigidBodyFlag4Enum32eENABLE_POSE_INTEGRATION_PREVIEWE" title="PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW</span></code></a> raised were moved by the simulation and their new poses can be accessed using the provided buffers.
This callback is different from the others mentioned above in the sense that it will get called while the simulation is running.
As a consequence, code in this callback should be as lightweight as possible, as it will block the simulation.</p>
<p>It is forbidden to perform write operations in any callback.</p>
</section>
<section id="simulation-memory">
<span id="id2"></span><h2>Simulation memory<a class="headerlink" href="#simulation-memory" title="Permalink to this headline"></a></h2>
<p>PhysX relies on the application for all memory allocation. The primary interface is via the <a class="reference internal" href="../_api_build/class_px_allocator_callback.html#_CPPv419PxAllocatorCallback" title="PxAllocatorCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxAllocatorCallback</span></code></a> interface required to initialize the SDK:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PxAllocatorCallback</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">PxAllocatorCallback</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">typeName</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>After the self-explanatory function argument describing the size of the allocation, the next three function arguments are an identifier name, which identifies the type of allocation, and the <code class="docutils literal notranslate"><span class="pre">__FILE__</span></code> and <code class="docutils literal notranslate"><span class="pre">__LINE__</span></code> location inside the SDK code where the allocation was made.
More details of these function arguments can be found in the API documentation: <a class="reference internal" href="../_api_build/class_px_allocator_callback.html#_CPPv419PxAllocatorCallback" title="PxAllocatorCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxAllocatorCallback</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An important change since 2.x:  The SDK now requires that the memory that is returned to be 16-byte aligned.
On many platforms <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> returns memory that is 16-byte aligned, but on Windows the system function <code class="docutils literal notranslate"><span class="pre">_aligned_malloc()</span></code> provides this capability.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On some platforms PhysX uses system library calls to determine the correct type name, and the system function that returns the type name may call the system memory allocator.
If you are instrumenting system memory allocations, you may observe this behavior.
To prevent PhysX requesting type names, disable allocation names using the method <a class="reference internal" href="../_api_build/class_px_foundation.html#_CPPv4N12PxFoundation24setReportAllocationNamesEb" title="PxFoundation::setReportAllocationNames"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxFoundation::setReportAllocationNames()</span></code></a>.</p>
</div>
<p>Minimizing dynamic allocation is an important aspect of performance tuning.  PhysX provides several mechanisms to control and analyze memory usage.  These shall be discussed in turn.</p>
<section id="scene-limits">
<h3>Scene Limits<a class="headerlink" href="#scene-limits" title="Permalink to this headline"></a></h3>
<p>The number of allocations for tracking objects can be minimized by presizing the capacities of scene data structures, using either <a class="reference internal" href="../_api_build/class_px_scene_desc.html#_CPPv4N11PxSceneDesc6limitsE" title="PxSceneDesc::limits"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxSceneDesc::limits</span></code></a> before creating the scene or the function <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene9setLimitsERK13PxSceneLimits" title="PxScene::setLimits"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::setLimits()</span></code></a>.
It is useful to note that these limits do not represent hard limits, meaning that PhysX will automatically perform further allocations if the number of objects exceeds the scene limits.</p>
</section>
<section id="k-data-blocks">
<h3>16K Data Blocks<a class="headerlink" href="#k-data-blocks" title="Permalink to this headline"></a></h3>
<p>Much of the memory PhysX uses for simulation is held in a pool of blocks, each 16K in size.
The initial number of blocks allocated to the pool can be controlled by setting <a class="reference internal" href="../_api_build/class_px_scene_desc.html#_CPPv4N11PxSceneDesc19nbContactDataBlocksE" title="PxSceneDesc::nbContactDataBlocks"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxSceneDesc::nbContactDataBlocks</span></code></a>, while the maximum number of blocks that can ever be in the pool is governed by <a class="reference internal" href="../_api_build/class_px_scene_desc.html#_CPPv4N11PxSceneDesc22maxNbContactDataBlocksE" title="PxSceneDesc::maxNbContactDataBlocks"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxSceneDesc::maxNbContactDataBlocks</span></code></a>.
If PhysX internally needs more blocks than <code class="docutils literal notranslate"><span class="pre">nbContactDataBlocks</span></code> then it will automatically allocate further blocks to the pool until the number of blocks reaches <code class="docutils literal notranslate"><span class="pre">maxNbContactDataBlocks</span></code>.
If PhysX subsequently needs more blocks than the maximum number of blocks, it will simply start dropping contacts and joint constraints.
When this happens, warnings are passed to the error stream in the <code class="docutils literal notranslate"><span class="pre">PX_CHECKED</span></code> configuration.</p>
<p>To help tune <code class="docutils literal notranslate"><span class="pre">nbContactDataBlocks</span></code> and <code class="docutils literal notranslate"><span class="pre">maxNbContactDataBlocks</span></code> it can be useful to query the number of blocks currently allocated to the pool using the function <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4NK7PxScene26getNbContactDataBlocksUsedEv" title="PxScene::getNbContactDataBlocksUsed"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::getNbContactDataBlocksUsed()</span></code></a>.
It can also be useful to query the maximum number of blocks that can ever be allocated to the pool with <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4NK7PxScene29getMaxNbContactDataBlocksUsedEv" title="PxScene::getMaxNbContactDataBlocksUsed"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::getMaxNbContactDataBlocksUsed()</span></code></a>.</p>
<p>Unused blocks can be reclaimed using <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene15flushSimulationEb" title="PxScene::flushSimulation"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::flushSimulation()</span></code></a>.
When this function is called any allocated blocks not required by the current scene state will be deleted so that they may be reused by the application.
Additionally, a number of other memory resources are freed by shrinking them to the minimum size required by the scene configuration.</p>
</section>
<section id="scratch-buffer">
<h3>Scratch Buffer<a class="headerlink" href="#scratch-buffer" title="Permalink to this headline"></a></h3>
<p>A scratch memory block may be passed as a function argument to the function <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a>.
As far as possible, PhysX will internally allocate temporary buffers from the scratch memory block, thereby reducing the need to perform temporary allocations from <a class="reference internal" href="../_api_build/class_px_allocator_callback.html#_CPPv419PxAllocatorCallback" title="PxAllocatorCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxAllocatorCallback</span></code></a>.
The block may be reused by the application after the <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchResults()</span></code></a> call, which marks the end of the simulation.
One restriction on the scratch memory block is that its size must be a multiple of 16K, and it must be 16-byte aligned.</p>
</section>
<section id="in-place-serialization">
<h3>In-Place Serialization<a class="headerlink" href="#in-place-serialization" title="Permalink to this headline"></a></h3>
<p>PhysX objects can be stored in memory owned by the application using PhysX’ binary deserialization mechanism. See <a class="reference internal" href="Serialization.html#serialization"><span class="std std-ref">Serialization</span></a> for details.</p>
</section>
</section>
<section id="completion-tasks">
<h2>Completion Tasks<a class="headerlink" href="#completion-tasks" title="Permalink to this headline"></a></h2>
<p>A completion task is a <a class="reference internal" href="Threading.html#task"><span class="std std-ref">Task</span></a> that executes once the chain of simulation tasks triggered during <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a> has finished.
If PhysX has been configured to use worker threads then <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a> will start simulation tasks on the worker threads and will likely exit before the worker threads have completed the work necessary to complete the scene update.
A typical completion task would first need to call <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchResults(true)</span></code></a> to wrap up the simulation update step.
After calling <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchResults(true)</span></code></a>, the completion task can perform any other post-physics work deemed necessary by the application:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">fetchResults</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="n">game</span><span class="p">.</span><span class="n">updateA</span><span class="p">();</span><span class="w"></span>
<span class="n">game</span><span class="p">.</span><span class="n">updateB</span><span class="p">();</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">game</span><span class="p">.</span><span class="n">updateZ</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>The completion task is specified as a function argument in <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a>.</p>
</section>
<section id="synchronizing-with-other-threads">
<h2>Synchronizing with Other Threads<a class="headerlink" href="#synchronizing-with-other-threads" title="Permalink to this headline"></a></h2>
<p>An important consideration for substepping is that <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a> and <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchResults()</span></code></a> are considered write calls on the scene, and it is therefore illegal to read from or write to a scene while those functions are running.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PhysX does not lock its scene graph, but it will report an error in checked build if it detects that multiple threads make concurrent calls to the same scene, unless they are all read calls.</p>
</div>
</section>
<section id="substepping">
<h2>Substepping<a class="headerlink" href="#substepping" title="Permalink to this headline"></a></h2>
<p>For reasons of fidelity simulation or better stability it is often desired that the simulation frequency of PhysX be higher than the update rate of the application.
The simplest way to do this is just to call <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::simulate()</span></code></a> and <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchResults()</span></code></a> multiple times:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">substepCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="n">pre</span><span class="o">-</span><span class="n">simulation</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="p">(</span><span class="n">update</span><span class="w"> </span><span class="n">controllers</span><span class="p">,</span><span class="w"> </span><span class="n">etc</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">simulate</span><span class="p">(</span><span class="n">substepSize</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">fetchResults</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="n">post</span><span class="w"> </span><span class="n">simulation</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="p">(</span><span class="n">process</span><span class="w"> </span><span class="n">physics</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">etc</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Sub-stepping can also be integrated with the completion task feature of the <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function. To illustrate this, consider the situation where the scene is simulated until the graphics component signals that it has completed updating the render state of the scene.
Here, the completion task will run once the simulaton tasks have finished and its first job will be to block with <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchResults(true)</span></code></a> to complete the simulation step.
When the completion task is able to proceed, its next work item will be to query the graphics component to check if another <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> is required or if it can exit.
In the case that another <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> step is required it will clearly need to pass a completion task to <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>.
A tricky point here is that a completion task cannot submit itself as the next completion task because it would cause an illegal recursion.
A solution to this problem might to be to have two completion tasks where each stores a reference to the other.
Each completion task can then pass its partner to <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">fetchResults</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">graphics</span><span class="p">.</span><span class="n">isComplete</span><span class="p">())</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">scene</span><span class="p">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">otherCompletionTask</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="split-sim">
<h2>Split sim<a class="headerlink" href="#split-sim" title="Permalink to this headline"></a></h2>
<p>As an alternative to <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>/ <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchResults()</span></code></a>, a simulation step may be split into two phases: <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7collideE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::collide"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::collide()</span></code></a> and <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7advanceEPN5physx10PxBaseTaskE" title="PxScene::advance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::advance()</span></code></a>.
This is known as split simulation.
The key point here is that the <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>/ <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchResults()</span></code></a> combination permits reads and writes only before <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene8simulateE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::simulate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> and after <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchResults()</span></code></a>.
The split simulation, on the other hand, relaxes this restriction and allows some reads and writes to take place at specific points during the course of a simulation step.
This shall now be explained in more detail.</p>
<p>When using split sim, a physics simulation step would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">collide</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="w"></span>
<span class="n">scene</span><span class="p">.</span><span class="n">fetchCollision</span><span class="p">()</span><span class="w"></span>
<span class="n">scene</span><span class="p">.</span><span class="n">advance</span><span class="p">()</span><span class="w"></span>
<span class="n">scene</span><span class="p">.</span><span class="n">fetchResults</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>As already mentioned, split sim allows some properties to be written during the simulation step.
More specifically, some properties, known as write-through properties, may be modified in-between the return from <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene14fetchCollisionEb" title="PxScene::fetchCollision"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::fetchCollision()</span></code></a> and the execution of the <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7advanceEPN5physx10PxBaseTaskE" title="PxScene::advance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">advance()</span></code></a> call.
This allows <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7collideE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::collide"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">collide()</span></code></a> to begin before the data required by <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7advanceEPN5physx10PxBaseTaskE" title="PxScene::advance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">advance()</span></code></a> is available and to run in parallel with application-side logic that generates inputs to <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7advanceEPN5physx10PxBaseTaskE" title="PxScene::advance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">advance()</span></code></a>.
This is particularly useful for animation logic generating kinematic targets, and for controllers applying forces to bodies.
The write-through properties are listed below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxRigidDynamic</span><span class="o">/</span><span class="n">PxArticulationLink</span><span class="o">::</span><span class="n">addForce</span><span class="p">()</span><span class="o">/</span><span class="n">addTorque</span><span class="p">()</span><span class="o">/</span><span class="n">clearForce</span><span class="p">()</span><span class="o">/</span><span class="n">clearTorque</span><span class="p">()</span><span class="o">/</span><span class="n">setForceAndTorque</span><span class="p">()</span><span class="w"></span>
<span class="n">PxRigidDynamic</span><span class="o">/</span><span class="n">PxArticulationLink</span><span class="o">::</span><span class="n">setAngularVelocity</span><span class="p">()</span><span class="o">/</span><span class="n">setLinearVelocity</span><span class="p">()</span><span class="w"></span>
<span class="n">PxRigidDynamic</span><span class="o">/</span><span class="n">PxArticulation</span><span class="o">::</span><span class="n">wakeUp</span><span class="p">()</span><span class="w"></span>
<span class="n">PxRigidDynamic</span><span class="o">/</span><span class="n">PxArticulation</span><span class="o">::</span><span class="n">setWakeCounter</span><span class="p">()</span><span class="w"></span>
<span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">setKinematicTarget</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Split sim also allows API read commands to be called during <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7collideE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::collide"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">collide()</span></code></a> and in-between the return from <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene14fetchCollisionEb" title="PxScene::fetchCollision"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchCollision()</span></code></a> and the execution of the <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7advanceEPN5physx10PxBaseTaskE" title="PxScene::advance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">advance()</span></code></a> call.
These read commands are listed below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxRigidActor</span><span class="o">/</span><span class="n">PxArticulationLink</span><span class="o">::</span><span class="n">getGlobalPose</span><span class="p">()</span><span class="w"></span>
<span class="n">PxRigidActor</span><span class="o">/</span><span class="n">PxArticulation</span><span class="o">/</span><span class="n">PxArticulationLink</span><span class="o">::</span><span class="n">getWorldBounds</span><span class="p">()</span><span class="w"></span>
<span class="n">PxConstraint</span><span class="o">::</span><span class="n">getForce</span><span class="p">()</span><span class="w"></span>
<span class="n">PxRigidActor</span><span class="o">/</span><span class="n">PxArticulationLink</span><span class="o">::</span><span class="n">getLinearVelocity</span><span class="p">()</span><span class="o">/</span><span class="n">getAngularVelocity</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Users can interleave the physics-dependent application logic between <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7collideE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::collide"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">collide()</span></code></a> and <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7advanceEPN5physx10PxBaseTaskE" title="PxScene::advance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">advance()</span></code></a> as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">collide</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="w"></span>
<span class="n">read</span><span class="w"> </span><span class="n">poses</span><span class="p">,</span><span class="w"> </span><span class="n">velocities</span><span class="p">,</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="n">bounds</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">constraint</span><span class="w"> </span><span class="n">forces</span><span class="w"></span>
<span class="n">physics</span><span class="o">-</span><span class="n">dependent</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="n">logic</span><span class="w"> </span><span class="p">(</span><span class="n">anmimation</span><span class="p">,</span><span class="w"> </span><span class="n">rendering</span><span class="p">)</span><span class="w"> </span><span class="n">generating</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">modifications</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">apply</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">write</span><span class="o">-</span><span class="n">through</span><span class="w"> </span><span class="n">properties</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">advance</span><span class="p">()</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
<span class="n">scene</span><span class="p">.</span><span class="n">fetchCollision</span><span class="p">()</span><span class="w"></span>
<span class="n">read</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">poses</span><span class="p">,</span><span class="w"> </span><span class="n">velocities</span><span class="p">,</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="n">bounds</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">constraint</span><span class="w"> </span><span class="n">forces</span><span class="w"></span>
<span class="n">apply</span><span class="w"> </span><span class="n">user</span><span class="o">-</span><span class="n">buffered</span><span class="w"> </span><span class="n">modifications</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">write</span><span class="o">-</span><span class="n">through</span><span class="w"> </span><span class="n">properties</span><span class="w"></span>
<span class="n">scene</span><span class="p">.</span><span class="n">advance</span><span class="p">()</span><span class="w"></span>
<span class="n">scene</span><span class="p">.</span><span class="n">fetchResults</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene14fetchCollisionEb" title="PxScene::fetchCollision"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchCollision()</span></code></a> will wait until <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7collideE6PxRealPN5physx10PxBaseTaskEPv5PxU32b" title="PxScene::collide"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">collide()</span></code></a> has finished.
Once <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene14fetchCollisionEb" title="PxScene::fetchCollision"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchCollision()</span></code></a> has completed, user-buffered modifications to write-through properties can be applied to the objects in the executing scene.
In the subsequent <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene7advanceEPN5physx10PxBaseTaskE" title="PxScene::advance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">advance()</span></code></a> phase, the solver will take the modified write-through properties into account when computing the new sets of velocities and poses for the actors being simulated.</p>
<p>As a final comment, it is worth noting that illegal read and write calls are detected in all build configurations - an illegal call will immediately return with an error passed to <a class="reference internal" href="../_api_build/class_px_error_callback.html#_CPPv415PxErrorCallback" title="PxErrorCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxErrorCallback</span></code></a> and the function will not be executed.</p>
</section>
<section id="split-fetchresults">
<h2>Split fetchResults<a class="headerlink" href="#split-fetchresults" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchResults()</span></code></a> method is available in both a standard and split format.
The split format offers some advantages over the standard <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchResults()</span></code></a> method because it permits the user to parallelize processing of contact reports, which can be expensive when simulating complex scenes.</p>
<p>A simplistic way to use split <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene12fetchResultsEbP5PxU32" title="PxScene::fetchResults"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fetchResults()</span></code></a> would look something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">gSharedIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="n">gScene</span><span class="o">-&gt;</span><span class="n">simulate</span><span class="p">(</span><span class="mf">1.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">60.0f</span><span class="p">);</span><span class="w"></span>

<span class="c1">//Call fetchResultsStart. Get the set of pair headers</span>
<span class="k">const</span><span class="w"> </span><span class="n">PxContactPairHeader</span><span class="o">*</span><span class="w"> </span><span class="n">pairHeader</span><span class="p">;</span><span class="w"></span>
<span class="n">PxU32</span><span class="w"> </span><span class="n">nbContactPairs</span><span class="p">;</span><span class="w"></span>
<span class="n">gScene</span><span class="o">-&gt;</span><span class="n">fetchResultsStart</span><span class="p">(</span><span class="n">pairHeader</span><span class="p">,</span><span class="w"> </span><span class="n">nbContactPairs</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>

<span class="c1">//Set up continuation task to be run after callbacks have been processed in parallel</span>
<span class="n">callbackFinishTask</span><span class="p">.</span><span class="n">setContinuation</span><span class="p">(</span><span class="o">*</span><span class="n">gScene</span><span class="o">-&gt;</span><span class="n">getTaskManager</span><span class="p">(),</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="n">callbackFinishTask</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>

<span class="c1">//process the callbacks</span>
<span class="n">gScene</span><span class="o">-&gt;</span><span class="n">processCallbacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callbackFinishTask</span><span class="p">);</span><span class="w"></span>

<span class="n">callbackFinishTask</span><span class="p">.</span><span class="n">removeReference</span><span class="p">();</span><span class="w"></span>

<span class="n">callbackFinishTask</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>

<span class="n">gScene</span><span class="o">-&gt;</span><span class="n">fetchResultsFinish</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>The user is free to use their own task/threading system to process the callbacks.
However, the PhysX scene provides a utility function that processes the callbacks using multiple threads, which is used in this code snippet.
This method takes a continuation task that will be run when the tasks processing callbacks have completed.
In this example, the completion task raises an event that can be waited upon to notify the main thread that callback processing has completed.</p>
<p>This feature is demonstrated in <em>SnippetSplitFetchResults</em>.
In order to make use of this approach, contact notification callbacks must be thread-safe.
Furthermore, for this approach to be beneficial, contact notification callbacks need to be doing a significant amount of work to benefit from multi-threading them.</p>
</section>
<section id="shifting-the-scene-origin">
<span id="originshift"></span><h2>Shifting The Scene Origin<a class="headerlink" href="#shifting-the-scene-origin" title="Permalink to this headline"></a></h2>
<p>Problems arising from the limits of floating point precision become more pronounced as objects move further from the origin. This phenomenon adversely affects large world scenarios. One solution might be to teleport all objects towards the origin with the proviso that their relative positions are preserved. The problem here is that internally cached data and persistent state will become invalid. PhysX offers an API to shift the origin of an entire scene in a way that maintains the consistency of the internally cached data and persistent state.</p>
<p>The function <a class="reference internal" href="../_api_build/class_px_scene.html#_CPPv4N7PxScene11shiftOriginERK6PxVec3" title="PxScene::shiftOrigin"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">shiftOrigin()</span></code></a> will shift the origin of a scene by a translation vector:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxScene</span><span class="o">::</span><span class="n">shiftOrigin</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">shift</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The positions of all objects in the scene and the corresponding data structures will be adjusted to reflect the new origin location (basically, the shift vector will be subtracted from all object positions). The intended use pattern for this API is to shift the origin such that object positions move closer towards zero. Please note that it is the user’s responsibility to keep track of the summed total origin shift and adjust all input/output to/from PhysX accordingly. It is worth noting that this can be an expensive operation and it is recommended to use it only in the case where distance-related precision issues arise in areas far from the origin. If extension modules of PhysX, such as the character or vehicle controller, are used then it will be necessary to propagate the scene shift to those modules as well. Please refer to the API documentation of these modules for details.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2023, NVIDIA.
      <span class="lastupdated">Last updated on Sep 19, 2023.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>