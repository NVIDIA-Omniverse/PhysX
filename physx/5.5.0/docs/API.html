<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PhysX API Basics &mdash; physx 5.5.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css" />
      <link rel="stylesheet" href="../_static/omni-style.css" type="text/css" />
      <link rel="stylesheet" href="../_static/api-styles.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/mermaid-init.js"></script>
        <script src="../_static/design-tabs.js"></script>
        <script src="../_static/version.js"></script>
        <script src="../_static/social-media.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Startup and Shutdown" href="Startup.html" />
    <link rel="prev" title="Snippets" href="Snippets.html" />
 


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


  <a href="../index.html">
  <img src="../_static/PhysXLogoWhite.png" class="logo" alt="Logo"/>
</a>

<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="License.html">PhysX License</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingWithPhysX.html">Building with PhysX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Snippets.html">Snippets</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">PhysX API Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error-reporting">Error Reporting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#math-classes">Math Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connecting-physx-objects-with-user-application-objects">Connecting PhysX Objects with User Application Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-casting">Type Casting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reference-counting">Reference Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-different-units">Using Different Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="#determinism">Determinism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#enhanced-determinism">Enhanced Determinism</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Startup.html">Startup and Shutdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="Threading.html">Threading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Geometry.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="CustomGeometry.html">Custom Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="RigidBodyOverview.html">Rigid Body Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="RigidBodyCollision.html">Rigid Body Collision</a></li>
<li class="toctree-l1"><a class="reference internal" href="RigidBodyDynamics.html">Rigid Body Dynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="Simulation.html">Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="AdvancedCollisionDetection.html">Advanced Collision Detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="Joints.html">Joints</a></li>
<li class="toctree-l1"><a class="reference internal" href="Articulations.html">Articulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPURigidBodies.html">GPU Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="DirectGPUAPI.html">Direct GPU API</a></li>
<li class="toctree-l1"><a class="reference internal" href="DeformableBodyOverview.html">Deformable Body Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="DeformableVolume.html">Deformable Volume</a></li>
<li class="toctree-l1"><a class="reference internal" href="ParticleSystem.html">Particle System</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeometryQueries.html">Geometry Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="SceneQueries.html">Scene Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="GjkQueries.html">Gjk Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="Vehicles.html">Vehicles</a></li>
<li class="toctree-l1"><a class="reference internal" href="CharacterControllers.html">Character Controllers</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebugVisualization.html">Debug Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OmniVisualDebugger.html">Omniverse Visual Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="Statistics.html">Simulation Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Serialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExtendingSerialization.html">Extending Serialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="BestPractices.html">Best Practices Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationFrom28.html">Migrating From PhysX SDK 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo33.html">Migrating From PhysX SDK 3.2 to 3.3</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo34.html">Migrating From PhysX SDK 3.3 to 3.4</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo40.html">Migrating From PhysX SDK 3.4 to 4.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo51.html">Migrating From PhysX SDK 4.0 to 5.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo52.html">Migrating From PhysX SDK 5.1 to 5.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo53.html">Migrating From PhysX SDK 5.2 to 5.3</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo54.html">Migrating From PhysX SDK 5.3 to 5.4</a></li>
<li class="toctree-l1"><a class="reference internal" href="MigrationTo55.html">Migrating From PhysX SDK 5.4 to 5.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_api_build/physx_api.html">PhysX SDK API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">physx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">


<li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
<li>PhysX API Basics</li>

      <li class="wy-breadcrumbs-aside">
      </li>
<li class="wy-breadcrumbs-aside">

  <span>&nbsp;</span>
</li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="physx-api-basics">
<span id="api"></span><h1>PhysX API Basics<a class="headerlink" href="#physx-api-basics" title="Permalink to this headline"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>This chapter covers the basic patterns common to the PhysX application programming interface (API). We are committed to keeping this API stable and backwards-compatible from one minor release to the next, to protect the investment you make in your integration code.</p>
<p>The PhysX API is composed primarily of abstract interface classes. Classes, enumerations and functions defined by the API have the prefix Px.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is currently one section of the public API which does not have the Px prefix: the PhysX Visual Debugger connection library which has the prefix Pvd.</p>
</div>
<p>The PhysX libraries also expose some classes and functions that are not yet an official part of the public API. These can be recognized because they do not have the Px prefix, but they are required to build the PhysX libraries. Even though they are in principle accessible to users, they can be undocumented and we do not guarantee compatibility of these specific classes and functions between PhysX versions.</p>
<hr class="docutils" />
</section>
<section id="memory-management">
<span id="memorymanagement"></span><h2>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline"></a></h2>
<p>PhysX performs all allocations via the <a class="reference internal" href="../_api_build/classPxAllocatorCallback.html#_CPPv419PxAllocatorCallback" title="PxAllocatorCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxAllocatorCallback</span></code></a> interface. You must implement this interface in order to initialize PhysX:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PxAllocatorCallback</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">PxAllocatorCallback</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">typeName</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The size of the request is specified in bytes, and PhysX requires that the memory that is returned be 16-byte aligned. On many platforms <em>malloc()</em> returns memory that is 16-byte aligned, and on Windows the system function <em>_aligned_malloc()</em> provides this capability. The other parameters to <em>allocate()</em> are a string which identifies the type of allocation, and the __FILE__ and __LINE__ location inside PhysX code where the allocation was made. Refer to <a class="reference internal" href="../_api_build/classPxAllocatorCallback.html#_CPPv4N19PxAllocatorCallback8allocateE6size_tPKcPKci" title="PxAllocatorCallback::allocate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxAllocatorCallback::allocate()</span></code></a> to find out more about them.</p>
<p>A simple implementation of the allocator callback class can be found in the PhysX Extensions library, see class <a class="reference internal" href="../_api_build/classPxDefaultAllocator.html#_CPPv418PxDefaultAllocator" title="PxDefaultAllocator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxDefaultAllocator</span></code></a>. This library also contains <em>physx::platformAlignedAlloc()</em> and <em>physx::platformAlignedFree()</em> wrappers for convenient 16-byte aligned memory allocations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On some platforms PhysX uses system library calls to determine the correct type name, and the system function that returns the type name may call the system memory allocator. If you are instrumenting system memory allocations, you may observe this behavior. To prevent PhysX requesting type names, disable allocation names using the method <a class="reference internal" href="../_api_build/classPxFoundation.html#_CPPv4N12PxFoundation24setReportAllocationNamesEb" title="PxFoundation::setReportAllocationNames"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxFoundation::setReportAllocationNames()</span></code></a>.</p>
</div>
<p>You can place PhysX objects in memory owned by the application using PhysX’ binary deserialization mechanism. See <a class="reference internal" href="Serialization.html#serialization"><span class="std std-ref">Serialization</span></a> for details.</p>
<hr class="docutils" />
</section>
<section id="error-reporting">
<span id="errorreporting"></span><h2>Error Reporting<a class="headerlink" href="#error-reporting" title="Permalink to this headline"></a></h2>
<p>PhysX logs all error messages through the <a class="reference internal" href="../_api_build/classPxErrorCallback.html#_CPPv415PxErrorCallback" title="PxErrorCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxErrorCallback</span></code></a> interface. You must implement this interface in order to initialize PhysX:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">UserErrorCallback</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PxErrorCallback</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">reportError</span><span class="p">(</span><span class="n">PxErrorCode</span><span class="o">::</span><span class="n">Enum</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// error processing implementation</span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>There is only a single function to implement, <a class="reference internal" href="../_api_build/classPxErrorCallback.html#_CPPv4N15PxErrorCallback11reportErrorEN11PxErrorCode4EnumEPKcPKci" title="PxErrorCallback::reportError"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxErrorCallback::reportError()</span></code></a>. This function should log the passed message, or print it on the application’s output console. For the more serious error codes <a class="reference internal" href="../_api_build/structPxErrorCode.html#_CPPv4N11PxErrorCode4Enum6eABORTE" title="PxErrorCode::eABORT"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxErrorCode::eABORT</span></code></a>, <a class="reference internal" href="../_api_build/structPxErrorCode.html#_CPPv4N11PxErrorCode4Enum18eINVALID_PARAMETERE" title="PxErrorCode::eINVALID_PARAMETER"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxErrorCode::eINVALID_PARAMETER</span></code></a>, <a class="reference internal" href="../_api_build/structPxErrorCode.html#_CPPv4N11PxErrorCode4Enum18eINVALID_OPERATIONE" title="PxErrorCode::eINVALID_OPERATION"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxErrorCode::eINVALID_OPERATION</span></code></a>, <a class="reference internal" href="../_api_build/structPxErrorCode.html#_CPPv4N11PxErrorCode4Enum15eINTERNAL_ERRORE" title="PxErrorCode::eINTERNAL_ERROR"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxErrorCode::eINTERNAL_ERROR</span></code></a> and <a class="reference internal" href="../_api_build/structPxErrorCode.html#_CPPv4N11PxErrorCode4Enum14eOUT_OF_MEMORYE" title="PxErrorCode::eOUT_OF_MEMORY"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxErrorCode::eOUT_OF_MEMORY</span></code></a>, breaking into the debugger may be a more appropriate choice. Whatever you do, do not just ignore the messages.</p>
<p>A simple implementation of the error callback class can be found in the PhysX Extensions library, see class <a class="reference internal" href="../_api_build/classPxDefaultErrorCallback.html#_CPPv422PxDefaultErrorCallback" title="PxDefaultErrorCallback"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxDefaultErrorCallback</span></code></a>.</p>
<hr class="docutils" />
</section>
<section id="math-classes">
<span id="mathtypes"></span><h2>Math Classes<a class="headerlink" href="#math-classes" title="Permalink to this headline"></a></h2>
<p>The common math classes used in PhysX are <a class="reference internal" href="../_api_build/typedef_PxVec2_8h_1a93b3bd57c939e655e5612b0fbe4c020d.html#_CPPv46PxVec2" title="PxVec2"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxVec2</span></code></a>, <a class="reference internal" href="../_api_build/typedef_PxVec3_8h_1ae91c92d849735e5ef8906ccfd6fc1f20.html#_CPPv46PxVec3" title="PxVec3"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxVec3</span></code></a>, <a class="reference internal" href="../_api_build/typedef_PxVec4_8h_1a7346068a75502045a7c8f65e7dcee471.html#_CPPv46PxVec4" title="PxVec4"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxVec4</span></code></a>, <a class="reference internal" href="../_api_build/typedef_PxMat33_8h_1a2d8dc7bd6d5e77c8e8df90679ae9af61.html#_CPPv47PxMat33" title="PxMat33"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxMat33</span></code></a>, <a class="reference internal" href="../_api_build/typedef_PxMat44_8h_1a95751c2e7256308fbd285e798495f8ee.html#_CPPv47PxMat44" title="PxMat44"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxMat44</span></code></a>, <a class="reference internal" href="../_api_build/typedef_PxTransform_8h_1a8ddcfa21262bb645cbe896368cf1e7aa.html#_CPPv411PxTransform" title="PxTransform"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxTransform</span></code></a>, <a class="reference internal" href="../_api_build/typedef_PxQuat_8h_1ad2b837fa8365f179d52b48e5aa5bc264.html#_CPPv46PxQuat" title="PxQuat"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxQuat</span></code></a> and <a class="reference internal" href="../_api_build/classPxPlane.html#_CPPv47PxPlane" title="PxPlane"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPlane</span></code></a>, which are are defined in their respective header files, e.g. (SDKRoot)/include/foundation/PxVec3.h. Most of these classes exist for floats and doubles via a typedef. The types support standard operator overloads and typical math operations. Zero and identity objects where appropriate can be constructed by passing the arguments <em>PxZero</em> and <em>PxIdentity</em> respectively.</p>
<p>Some points to note are:</p>
<ul class="simple">
<li><p><em>PxTransform</em> is a representation of a rigid body transform as a rotation quaternion and a position vector, and PhysX functions which take transforms all use this type.</p></li>
<li><p><em>PxPlane</em> is a homogeneous plane equation: that is, the constructor PxPlane(n, d) represents the equation n.x + d = 0.</p></li>
</ul>
<p><em>PxMat33</em> and <em>PxMat44</em> matrices represent transformations with basis vectors in the columns (pre-multiply with matrix on the left hand side) and are stored in column-major order. This format is layout compatible with popular graphics APIs such as OpenGL and Direct3D. For example, to set the model transformation for a rigid body in OpenGL:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// retrieve world space transform of rigid body</span>
<span class="n">PxTransform</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rigidActor</span><span class="p">.</span><span class="n">getGlobalPose</span><span class="p">();</span><span class="w"></span>

<span class="c1">// convert to matrix form</span>
<span class="n">PxMat44</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxMat44</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="c1">// set to OpenGL</span>
<span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_MODELVIEW</span><span class="p">);</span><span class="w"></span>
<span class="n">glPushMatrix</span><span class="p">();</span><span class="w"></span>

<span class="c1">// PxMat44::front() returns a pointer to the first matrix element</span>
<span class="n">glMultMatrixf</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">front</span><span class="p">());</span><span class="w"></span>

<span class="c1">// draw model</span>

<span class="n">glPopMatrix</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>DirectX uses row-major storage for matrices by default (D3DMATRIX), but also stores basis vectors in rows (post-multiply on the right), so <em>PxMat44</em> may be used in place of D3DXMATRIX types directly.</p>
<hr class="docutils" />
</section>
<section id="connecting-physx-objects-with-user-application-objects">
<span id="userdata"></span><h2>Connecting PhysX Objects with User Application Objects<a class="headerlink" href="#connecting-physx-objects-with-user-application-objects" title="Permalink to this headline"></a></h2>
<p>Often an application needs to associate PhysX objects with application objects for application logic or rendering purposes. An easy way to connect a single user application object with a PhysX object is to use the <em>userData</em> member provided by the most important PhysX classes (e.g. <a class="reference internal" href="../_api_build/classPxActor.html#_CPPv4N7PxActor8userDataE" title="PxActor::userData"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxActor::userData</span></code></a>, <a class="reference internal" href="../_api_build/classPxShape.html#_CPPv4N7PxShape8userDataE" title="PxShape::userData"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxShape::userData</span></code></a>, <a class="reference internal" href="../_api_build/classPxMaterial.html#_CPPv4N10PxMaterial8userDataE" title="PxMaterial::userData"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxMaterial::userData</span></code></a>, etc). The <em>userData</em> member is a <em>void*</em> pointer which is reserved for application use. Each class only has one <em>userData</em> field, so to manage multiple associations another mechanism must be used.</p>
</section>
<hr class="docutils" />
<section id="type-casting">
<h2>Type Casting<a class="headerlink" href="#type-casting" title="Permalink to this headline"></a></h2>
<p>PhysX API interface classes inherit from a top-level interface called PxBase, which provides mechanisms for type-safe down-casting between interface types. For example, to cast from a <a class="reference internal" href="../_api_build/classPxActor.html#_CPPv47PxActor" title="PxActor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxActor</span></code></a> to a <a class="reference internal" href="../_api_build/classPxRigidDynamic.html#_CPPv414PxRigidDynamic" title="PxRigidDynamic"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRigidDynamic</span></code></a>, use the following idiom:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxActor</span><span class="o">*</span><span class="w"> </span><span class="n">actor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">PxRigidDynamic</span><span class="o">*</span><span class="w"> </span><span class="n">myActor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actor</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">PxActor</span><span class="o">*</span><span class="w"> </span><span class="n">actor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">PxRigidDynamic</span><span class="o">*</span><span class="w"> </span><span class="n">myActor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actor</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>This pattern can be used to cast to intermediate types in the hierarchy such as <a class="reference internal" href="../_api_build/classPxRigidActor.html#_CPPv412PxRigidActor" title="PxRigidActor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRigidActor</span></code></a>, but this is somewhat slower than casting to concrete types. In addition, <a class="reference internal" href="../_api_build/classPxBase.html#_CPPv46PxBase" title="PxBase"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxBase</span></code></a> provides the following capabilities:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../_api_build/classPxBase.html#_CPPv4NK6PxBase15getConcreteTypeEv" title="PxBase::getConcreteType"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxBase::getConcreteType()</span></code></a> provides an integer value which corresponds to the concrete type of an object</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxBase.html#_CPPv4NK6PxBase19getConcreteTypeNameEv" title="PxBase::getConcreteTypeName"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxBase::getConcreteTypeName()</span></code></a> provides a string name of the concrete type</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxBase.html#_CPPv4NK6PxBase8isKindOfEPKc" title="PxBase::isKindOf"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxBase::isKindOf()</span></code></a> provides string-based testing of inheritance</p></li>
</ul>
<p>This can be used to cast types in a more cumbersome but faster way, like for example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxBase</span><span class="o">&amp;</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mSceneCollection</span><span class="o">-&gt;</span><span class="n">getObject</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">getConcreteType</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PxConcreteType</span><span class="o">::</span><span class="n">eRIGID_DYNAMIC</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">PxRigidDynamic</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">PxRigidDynamic</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="reference-counting">
<span id="basicreferencecounting"></span><h2>Reference Counting<a class="headerlink" href="#reference-counting" title="Permalink to this headline"></a></h2>
<p>Some PhysX objects are designed to be shared and referenced multiple times in a PhysX scene graph. For example, a <a class="reference internal" href="../_api_build/classPxConvexMesh.html#_CPPv412PxConvexMesh" title="PxConvexMesh"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConvexMesh</span></code></a> may be referenced by multiple <a class="reference internal" href="../_api_build/classPxShape.html#_CPPv47PxShape" title="PxShape"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxShape</span></code></a> objects, each sharing the same geometry but associated with different actors. The ref-counted types inherit from <a class="reference internal" href="../_api_build/classPxRefCounted.html#_CPPv412PxRefCounted" title="PxRefCounted"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRefCounted</span></code></a>, which is an interface that manages a reference count. The rules for reference counting are as follows:</p>
<ul class="simple">
<li><p>when an object is created from <a class="reference internal" href="../_api_build/classPxPhysics.html#_CPPv49PxPhysics" title="PxPhysics"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPhysics</span></code></a>, it has a reference count of 1.</p></li>
<li><p>when an object’s reference count reaches 0, the object is destroyed.</p></li>
<li><p>when a new counted reference is created, the reference count is incremented. Counted references are for example:</p>
<ul>
<li><p>when a <a class="reference internal" href="../_api_build/classPxShape.html#_CPPv47PxShape" title="PxShape"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxShape</span></code></a> references a <a class="reference internal" href="../_api_build/classPxConvexMesh.html#_CPPv412PxConvexMesh" title="PxConvexMesh"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConvexMesh</span></code></a>, <a class="reference internal" href="../_api_build/classPxHeightField.html#_CPPv413PxHeightField" title="PxHeightField"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxHeightField</span></code></a>, or <a class="reference internal" href="../_api_build/classPxTriangleMesh.html#_CPPv414PxTriangleMesh" title="PxTriangleMesh"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxTriangleMesh</span></code></a>.</p></li>
<li><p>when a <a class="reference internal" href="../_api_build/classPxShape.html#_CPPv47PxShape" title="PxShape"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxShape</span></code></a> references a PxMaterial.</p></li>
<li><p>when a <a class="reference internal" href="../_api_build/classPxRigidActor.html#_CPPv412PxRigidActor" title="PxRigidActor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRigidActor</span></code></a> references a <a class="reference internal" href="../_api_build/classPxShape.html#_CPPv47PxShape" title="PxShape"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxShape</span></code></a>.</p></li>
<li><p>etc</p></li>
</ul>
</li>
<li><p>when a counted reference is destroyed, or the object’s release() method is called, the reference count is decremented.</p></li>
<li><p>when an object is created through deserialization, its reference count is 1, plus the number of counted references that exist to the object.</p></li>
</ul>
<p>The initial reference count of 1 ensures the object is not destroyed until the application allows it by calling <em>release()</em> - thereafter it will be destroyed when no remaining counted references to it exist.</p>
<p>For example, if you create a shape using <a class="reference internal" href="../_api_build/classPxPhysics.html#_CPPv4N9PxPhysics11createShapeERK10PxGeometryRK10PxMaterialb12PxShapeFlags" title="PxPhysics::createShape"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxPhysics::createShape()</span></code></a> and attach it to an actor with <a class="reference internal" href="../_api_build/classPxRigidActor.html#_CPPv4N12PxRigidActor11attachShapeER7PxShape" title="PxRigidActor::attachShape"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxRigidActor::attachShape()</span></code></a>, it has a reference count of 2. If you then call the shape’s <em>release()</em> method, it has a reference count of 1. When the actor is destroyed, or the shape is detached from the actor, the reference count is decremented, and since it is now 0, the shape is destroyed.</p>
<p>The <a class="reference internal" href="../_api_build/classPxRefCounted.html#_CPPv4N12PxRefCounted16acquireReferenceEv" title="PxRefCounted::acquireReference"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxRefCounted::acquireReference()</span></code></a> method increments the reference count of an object. For example, when a spatial query returns a reference to a mesh shape, and you want to pass that result to another thread for deferred processing, incrementing the reference count will ensure that even if the shape referencing the mesh is released, the mesh continues to exist.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>subtypes of <a class="reference internal" href="../_api_build/classPxGeometry.html#_CPPv410PxGeometry" title="PxGeometry"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxGeometry</span></code></a> do not have counted references to the meshes to which they point, e.g. when <a class="reference internal" href="../_api_build/classPxConvexMeshGeometry.html#_CPPv420PxConvexMeshGeometry" title="PxConvexMeshGeometry"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConvexMeshGeometry</span></code></a> points to a <a class="reference internal" href="../_api_build/classPxConvexMesh.html#_CPPv412PxConvexMesh" title="PxConvexMesh"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConvexMesh</span></code></a>. A counted reference exists only when the geometry is within a <a class="reference internal" href="../_api_build/classPxShape.html#_CPPv47PxShape" title="PxShape"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxShape</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>shapes are often created using the utility method <a class="reference internal" href="../_api_build/classPxRigidActorExt.html#_CPPv4N15PxRigidActorExt20createExclusiveShapeER12PxRigidActorRK10PxGeometryPPC10PxMaterial5PxU1612PxShapeFlags" title="PxRigidActorExt::createExclusiveShape"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxRigidActorExt::createExclusiveShape()</span></code></a>. Take special care when deserializing such actors (see <a class="reference internal" href="RigidBodyCollision.html#rigidbodycollisionshapes"><span class="std std-ref">Shapes</span></a> and <a class="reference internal" href="Serialization.html#deserializereferencecounting"><span class="std std-ref">Reference Counting of Deserialized Objects</span></a>)</p>
</div>
<hr class="docutils" />
</section>
<section id="using-different-units">
<span id="pxtolerancescale"></span><h2>Using Different Units<a class="headerlink" href="#using-different-units" title="Permalink to this headline"></a></h2>
<p>PhysX is designed to produce correct results regardless of the units of length or mass, so long as inputs use those units consistently. However, there are certain tolerances values whose defaults need to be adjusted depending on the units. In order to ensure that these tolerances default to reasonable values, adjust the values in <a class="reference internal" href="../_api_build/classPxTolerancesScale.html#_CPPv417PxTolerancesScale" title="PxTolerancesScale"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxTolerancesScale</span></code></a> when creating the <a class="reference internal" href="../_api_build/classPxPhysics.html#_CPPv49PxPhysics" title="PxPhysics"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPhysics</span></code></a> and <a class="reference internal" href="../_api_build/structPxCookingParams.html#_CPPv415PxCookingParams" title="PxCookingParams"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxCookingParams</span></code></a> interfaces. Tolerances for objects are set at creation time, and may then be overridden by the application.</p>
<p>You should set tolerances based on the typical size of objects in your simulation. For example, if you are working with objects of size approximately one meter, but in units of centimeters, you should set the scale as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxFoundation</span><span class="o">*</span><span class="w"> </span><span class="n">foundation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">PxTolerancesScale</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span><span class="w"></span>
<span class="n">scale</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">        </span><span class="c1">// typical length of an object</span>
<span class="n">scale</span><span class="p">.</span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">981</span><span class="p">;</span><span class="w">         </span><span class="c1">// typical speed of an object, gravity*1s is a reasonable choice</span>
<span class="n">PxPhysics</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreatePhysics</span><span class="p">(</span><span class="n">PX_PHYSICS_VERSION</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">foundation</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
</pre></div>
</div>
<p>This will result in the defaults for values like <em>PxShape::contactDistance</em> being scaled appropriately for your objects.</p>
<p>You can also set the typical object mass in <a class="reference internal" href="../_api_build/classPxTolerancesScale.html#_CPPv417PxTolerancesScale" title="PxTolerancesScale"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxTolerancesScale</span></code></a>.</p>
<p>It is important to use the same <a class="reference internal" href="../_api_build/classPxTolerancesScale.html#_CPPv417PxTolerancesScale" title="PxTolerancesScale"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxTolerancesScale</span></code></a> value for initialization of <a class="reference internal" href="../_api_build/structPxCookingParams.html#_CPPv415PxCookingParams" title="PxCookingParams"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxCookingParams</span></code></a> and <a class="reference internal" href="../_api_build/classPxPhysics.html#_CPPv49PxPhysics" title="PxPhysics"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPhysics</span></code></a>, and also when creating <a class="reference internal" href="../_api_build/classPxSceneDesc.html#_CPPv411PxSceneDesc" title="PxSceneDesc"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxSceneDesc</span></code></a> objects.</p>
</section>
<hr class="docutils" />
<section id="determinism">
<h2>Determinism<a class="headerlink" href="#determinism" title="Permalink to this headline"></a></h2>
<p>Given a specific platform and PhysX build, PhysX will produce identical simulation results for scenes with rigid bodies and articulations.
In order to achieve this determinism, the application must create a new <a class="reference internal" href="../_api_build/classPxScene.html#_CPPv47PxScene" title="PxScene"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxScene</span></code></a> instance and recreate the scene with the exact same sequence of API calls.
Note that removing all the objects from a scene is generally not sufficient to reinitialize it for this purpose.
For determinism the application must also use a consistent time-stepping scheme and ensure the same responses from simulation callbacks that modify data.</p>
<p>Simulation results can vary between platforms due to differences in hardware floating point precision and differences in how the compiler reorders instructions during optimization.
This means that behavior can be different between different platforms, different compilers operating on the same platform or between optimized and unoptimized builds using the same compiler on the same platform.</p>
<p>In addition, the PhysX simulation can produce divergent behavior if any conditions or settings in the simulation were changed, although behavior and determinism is not sensitive to the number of CPU worker threads used.</p>
<p>PhysX does currently not guarantee determinism for any scene that contains non-rigid actors such as <a class="reference internal" href="../_api_build/classPxPBDParticleSystem.html#_CPPv419PxPBDParticleSystem" title="PxPBDParticleSystem"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPBDParticleSystem</span></code></a>, <a class="reference internal" href="../_api_build/classPxDeformableSurface.html#_CPPv419PxDeformableSurface" title="PxDeformableSurface"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxDeformableSurface</span></code></a> or <a class="reference internal" href="../_api_build/classPxDeformableVolume.html#_CPPv418PxDeformableVolume" title="PxDeformableVolume"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxDeformableVolume</span></code></a>.</p>
<section id="enhanced-determinism">
<h3>Enhanced Determinism<a class="headerlink" href="#enhanced-determinism" title="Permalink to this headline"></a></h3>
<p>Even the addition or removal of a single actor that is <em>not</em> interacting with the existing set of actors in the scene can produce divergent results because it may change the order in which constraints are processed.
PhysX provides a mechanism to overcome the issue of divergent behavior in such cases where additional actors being added or actors being removed from the scene do not interact with the other actors in the scene.
This mechanism can be enabled by raising <a class="reference internal" href="../_api_build/structPxSceneFlag.html#_CPPv4N11PxSceneFlag4Enum28eENABLE_ENHANCED_DETERMINISME" title="PxSceneFlag::eENABLE_ENHANCED_DETERMINISM"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxSceneFlag::eENABLE_ENHANCED_DETERMINISM</span></code></a> on <a class="reference internal" href="../_api_build/classPxSceneDesc.html#_CPPv4N11PxSceneDesc5flagsE" title="PxSceneDesc::flags"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxSceneDesc::flags</span></code></a> prior to creating the scene.
Enabling this mode makes some performance concessions to be able to offer an improved level of determinism.
The application must still follow all the requirements to achieve deterministic behavior described previously in order for this mechanism to produce consistent results.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2024, NVIDIA.
      <span class="lastupdated">Last updated on Dec 04, 2024.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>