

<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Deformable Volume &#8212; PhysX SDK Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/nvidia-sphinx-theme.css?v=eb367b29" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=7abaf8bc" />
    <link rel="stylesheet" type="text/css" href="../_static/api.css?v=6f210184" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=8ca671aa"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'docs/DeformableVolume';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = '../versions1.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '5.5.1';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <script src="../_static/version-patch.js?v=c24f8c5d"></script>
    <script rel="preload" src="../_static/toctree.js"></script>
    <link rel="icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Particle System" href="ParticleSystem.html" />
    <link rel="prev" title="Deformable Body Overview" href="DeformableBodyOverview.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Feb 07, 2025"/>


  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        



  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a>


  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">


<nav class="bd-docs-nav bd-links"
     aria-label="Table of Contents">
  <p class="bd-links__title" role="heading" aria-level="1">Table of Contents</p>
  <div class="bd-toc-item navbar-nav"></div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">


<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
  </div>
  
  <div id="rtd-footer-container"></div>



      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">Deformable Volume</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="deformable-volume">
<span id="deformablevolume"></span><h1>Deformable Volume<a class="headerlink" href="#deformable-volume" title="Link to this heading">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>In PhysX deformable volumes are represented using two tetrahedral meshes:</p>
<ul class="simple">
<li><p><strong>Simulation Mesh</strong>: This mesh is used to compute deformations. It only needs to approximate the overall shape of the body and can feature a regular, uniformly sized tetrahedral structure. This design is optimized for efficient computation and rapid convergence.</p></li>
<li><p><strong>Collision Mesh</strong>: This mesh is used for collision detection. It must closely match the surface of the simulated body to ensure accurate collision responses.</p></li>
</ul>
<p>Alternatively, the simulation and collision meshes can be identical, if required.</p>
</section>
<section id="tet-maker">
<h2>Tet Maker<a class="headerlink" href="#tet-maker" title="Link to this heading">#</a></h2>
<p>The tetrahedral meshes required to create a deformable volume can be provided either from an external source or they can be created directly in PhysX by a component called Tet Maker. This process can be time consuming, therefore it is recommended to do it as a preprocessing step and save the cooked meshes to a file.
The collision mesh is typically created from the render mesh by calling <code class="docutils literal notranslate"><span class="pre">createConformingTetrahedronMesh(...)</span></code>. The surface of the resulting tetrahedral mesh will exactly match the surface of the input triangle mesh. The vertex list of the collision mesh replicates all vertices from the render mesh. The mesher can append additional vertices in case this is required to generate a valid tetrahedral mesh.
The simulation mesh can be created by calling <code class="docutils literal notranslate"><span class="pre">createVoxelTetrahedronMesh(...)</span></code> which takes the previously generated collision mesh as input as well as parameters to define the resolution of the output mesh. It will create voxels completely enclosing the collision mesh. The following image shows the render mesh, the collision tetmesh and the simulation tetmesh from left to right.</p>
<img alt="../_images/Tetmeshes.png" src="../_images/Tetmeshes.png" />
<p>There are a few variables for users to control the resolution of the mesh and to get optional embedding information:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numVoxelsAlongLongestBoundingBoxAxis</span></code>: Allows control over the resolution of the resulting mesh. The parameter specifies the number of voxels to generate along the longest axis of the input mesh’s bounding box. The number of cells along the smaller dimensions will be computed such that voxels get similar edge lengths in all directions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numTetsPerVoxel</span></code>: Every voxel will be split into 5 or 6 tetrahedra to produce a mesh with elements of similar size and shape.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputPointToOutputTetIndex</span></code>: This is an optional parameter that allows a mapping between input point and the tetrahedron containing the point. If <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is passed in, that information is not generated, otherwise pointer to a list with size matching the number of input vertices can be provided.</p></li>
</ul>
<p>The example in the section <a class="reference internal" href="#usingdeformablevolumes"><span class="std std-ref">Using Deformable Volumes</span></a> shows how to generate both meshes.</p>
</section>
<section id="mesh-cleaning">
<h2>Mesh Cleaning<a class="headerlink" href="#mesh-cleaning" title="Link to this heading">#</a></h2>
<p>Some triangle meshes contain holes, self intersections, sliver triangles (triangles where at least one angle is much bigger or much smaller than the other angles) or other defects. Generating a tetmesh out of a triangle mesh that has defects might not be possible or lead to a bad tetmesh. In that case a remeshing operation can help to fix the mesh defects. Other triangle meshes might simply have an excessive amount of triangles such that it makes sense to reduce the mesh’s resolution before generating a collision and a simulation tetmesh. The high resolution triangle mesh can still be used for rendering.</p>
<p>The following piece of code shows how to create a new set of vertices and triangles using a remeshing operation to fix mesh defects:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxVec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputVertices</span><span class="p">;</span>
<span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxU32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputIndices</span><span class="p">;</span>
<span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxVec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputVertices</span><span class="p">;</span>
<span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxU32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputIndices</span><span class="p">;</span>
<span class="n">PxI32</span><span class="w"> </span><span class="n">remesherGridResolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="n">PxTetMaker</span><span class="o">::</span><span class="n">remeshTriangleMesh</span><span class="p">(</span><span class="n">inputVertices</span><span class="p">,</span><span class="w"> </span><span class="n">inputIndices</span><span class="p">,</span><span class="w"> </span><span class="n">remesherGridResolution</span><span class="p">,</span><span class="w"> </span><span class="n">outputVertices</span><span class="p">,</span><span class="w"> </span><span class="n">outputIndices</span><span class="p">);</span>
</pre></div>
</div>
<p>A remeshing operation might increase the number of triangles. This depends on the resolution of the internal grid that the remesher uses. In many cases it makes sense to reduce the number of triangles to a number that still captures the mesh’s surface well while being as low as possible because the less triangles, the less tetrahedra the collision tetmesh will have and the faster the simulation will run. The following code shows how to reduce the number of triangles in a mesh to a given target. It does not make use of the maximal edge length feature that allows to avoid too long triangle edges because big triangles don’t approximate the body’s shape well when it starts deforming:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxVec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputVertices</span><span class="p">;</span>
<span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxU32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputIndices</span><span class="p">;</span>
<span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxVec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputVertices</span><span class="p">;</span>
<span class="n">PxArray</span><span class="o">&lt;</span><span class="n">PxU32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputIndices</span><span class="p">;</span>
<span class="n">PxI32</span><span class="w"> </span><span class="n">targetTriangleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>
<span class="n">PxReal</span><span class="w"> </span><span class="n">maximalTriangleEdgeLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="n">PxTetMaker</span><span class="o">::</span><span class="n">simplifyTriangleMesh</span><span class="p">(</span><span class="n">inputVertices</span><span class="p">,</span><span class="w"> </span><span class="n">inputIndices</span><span class="p">,</span><span class="w"> </span><span class="n">targetTriangleCount</span><span class="p">,</span><span class="w"> </span><span class="n">maximalTriangleEdgeLength</span><span class="p">,</span><span class="w"> </span><span class="n">outputVertices</span><span class="p">,</span><span class="w"> </span><span class="n">outputIndices</span><span class="p">);</span>
</pre></div>
</div>
<p>All mesh processing steps are usually performed in the following order</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Remeshing (optional)</p></li>
<li><p>Mesh Simplification (optional)</p></li>
<li><p>Creation of collision tetmesh</p></li>
<li><p>Creation of simulation tetmesh using the voxel tetmesher</p></li>
</ol>
</div></blockquote>
<img alt="../_images/SoftBodySimplification.png" src="../_images/SoftBodySimplification.png" />
</section>
<section id="cooking">
<h2>Cooking<a class="headerlink" href="#cooking" title="Link to this heading">#</a></h2>
<p>During the cooking process, all internal structures required by the simulation are configured. This includes acceleration structures for collision detection; ordering and partitioning for the tetrahedra mesh; mass/volume properties for every vertex/tetrahedra of the simulation mesh; and remap tables to update the collision mesh’s vertices according to the simulation mesh’s deformation. This precomputed data must be updated if the topology of the deformable volume is changed by the application at runtime e.g. due to tearing/cutting. Density, uniform scaling and translation are defined when the deformable volume is constructed.</p>
<p>Depending on the mesh’s resolution, cooking might take some time. To avoid calculating this data every time a simulation starts, the cooked data can be saved to a file by calling <code class="docutils literal notranslate"><span class="pre">PxCookDeformableVolumeMesh</span></code>. To load the cooked file, the <code class="docutils literal notranslate"><span class="pre">PxPhysics</span></code> instance provides a <code class="docutils literal notranslate"><span class="pre">createDeformableVolumeMesh</span></code> method that takes a file stream as source:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//Cook and save the mesh</span>
<span class="n">PxDefaultFileOutputStream</span><span class="w"> </span><span class="nf">writeBuffer</span><span class="p">(</span><span class="n">cacheFilename</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCookDeformableVolumeMesh</span><span class="p">(</span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="n">simMeshDesc</span><span class="p">,</span><span class="w"> </span><span class="n">meshDesc</span><span class="p">,</span><span class="w"> </span><span class="n">simDesc</span><span class="p">,</span><span class="w"> </span><span class="n">writeBuffer</span><span class="p">);</span>

<span class="c1">//Load the cooked mesh</span>
<span class="n">PxDefaultFileInputData</span><span class="w"> </span><span class="nf">readBuffer</span><span class="p">(</span><span class="n">cacheFilename</span><span class="p">);</span>
<span class="n">tetMesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physics</span><span class="p">.</span><span class="n">createDeformableVolumeMesh</span><span class="p">(</span><span class="n">readBuffer</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="using-deformable-volumes">
<span id="usingdeformablevolumes"></span><h2>Using Deformable Volumes<a class="headerlink" href="#using-deformable-volumes" title="Link to this heading">#</a></h2>
<p>The following snippet shows how to create a deformable volume from scratch given only triangle mesh vertices and indices. Separate collision and simulation meshes are used in the snippet. It is also possible to use the same mesh as simulation and collision mesh:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//Compute collision mesh</span>
<span class="n">physx</span><span class="o">::</span><span class="n">PxArray</span><span class="o">&lt;</span><span class="n">physx</span><span class="o">::</span><span class="n">PxVec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">collisionMeshVertices</span><span class="p">,</span><span class="w"> </span><span class="n">simulationMeshVertices</span><span class="p">;</span>
<span class="n">physx</span><span class="o">::</span><span class="n">PxArray</span><span class="o">&lt;</span><span class="n">physx</span><span class="o">::</span><span class="n">PxU32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">collisionMeshIndices</span><span class="p">,</span><span class="w"> </span><span class="n">simulationMeshIndices</span><span class="p">;</span>
<span class="n">PxTetMaker</span><span class="o">::</span><span class="n">createConformingTetrahedronMesh</span><span class="p">(</span><span class="n">surfaceMesh</span><span class="p">,</span><span class="w"> </span><span class="n">collisionMeshVertices</span><span class="p">,</span><span class="w"> </span><span class="n">collisionMeshIndices</span><span class="p">);</span>
<span class="n">PxTetrahedronMeshDesc</span><span class="w"> </span><span class="nf">meshDesc</span><span class="p">(</span><span class="n">collisionMeshVertices</span><span class="p">,</span><span class="w"> </span><span class="n">collisionMeshIndices</span><span class="p">);</span>

<span class="c1">//Compute simulation mesh</span>
<span class="n">PxU32</span><span class="w"> </span><span class="n">numVoxelsAlongLongestAABBAxis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="n">physx</span><span class="o">::</span><span class="n">PxArray</span><span class="o">&lt;</span><span class="n">physx</span><span class="o">::</span><span class="n">PxI32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vertexToTet</span><span class="p">;</span>
<span class="n">vertexToTet</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">meshDesc</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
<span class="n">PxTetMaker</span><span class="o">::</span><span class="n">createVoxelTetrahedronMesh</span><span class="p">(</span><span class="n">meshDesc</span><span class="p">,</span><span class="w"> </span><span class="n">numVoxelsAlongLongestAABBAxis</span><span class="p">,</span><span class="w"> </span><span class="n">simulationMeshVertices</span><span class="p">,</span><span class="w"> </span><span class="n">simulationMeshIndices</span><span class="p">,</span><span class="w"> </span><span class="n">vertexToTet</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
<span class="n">PxTetrahedronMeshDesc</span><span class="w"> </span><span class="nf">simMeshDesc</span><span class="p">(</span><span class="n">simulationMeshVertices</span><span class="p">,</span><span class="w"> </span><span class="n">simulationMeshIndices</span><span class="p">);</span>
<span class="n">PxDeformableVolumeSimulationDataDesc</span><span class="w"> </span><span class="nf">simDesc</span><span class="p">(</span><span class="n">vertexToTet</span><span class="p">);</span>

<span class="n">PxDeformableVolumeMesh</span><span class="o">*</span><span class="w"> </span><span class="n">mesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateDeformableVolumeMesh</span><span class="p">(</span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="n">simMeshDesc</span><span class="p">,</span><span class="w"> </span><span class="n">meshDesc</span><span class="p">,</span><span class="w"> </span><span class="n">simDesc</span><span class="p">,</span><span class="w"> </span><span class="n">physics</span><span class="p">.</span><span class="n">getPhysicsInsertionCallback</span><span class="p">());</span>

<span class="n">PxDeformableVolume</span><span class="o">*</span><span class="w"> </span><span class="n">deformableVolume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physics</span><span class="p">.</span><span class="n">createDeformableVolume</span><span class="p">(</span><span class="o">*</span><span class="n">mCudaContextManager</span><span class="p">);</span>
<span class="n">PxShapeFlags</span><span class="w"> </span><span class="n">shapeFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eVISUALIZATION</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSIMULATION_SHAPE</span><span class="p">;</span>
<span class="n">PxDeformableVolumeMaterial</span><span class="o">*</span><span class="w"> </span><span class="n">materialPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physics</span><span class="p">.</span><span class="n">createDeformableVolumeMaterial</span><span class="p">(</span><span class="mf">1e+9f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.45f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">);</span>
<span class="n">PxTetrahedronMeshGeometry</span><span class="w"> </span><span class="nf">geometry</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">getCollisionMesh</span><span class="p">());</span>
<span class="n">PxShape</span><span class="o">*</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physics</span><span class="p">.</span><span class="n">createShape</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">materialPtr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">shapeFlags</span><span class="p">);</span>
<span class="n">deformableVolume</span><span class="o">-&gt;</span><span class="n">attachShape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">);</span>
<span class="n">deformableVolume</span><span class="o">-&gt;</span><span class="n">attachSimulationMesh</span><span class="p">(</span><span class="o">*</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">getSimulationMesh</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">getDeformableVolumeAuxData</span><span class="p">());</span>
<span class="n">scene</span><span class="p">.</span><span class="n">addActor</span><span class="p">(</span><span class="o">*</span><span class="n">deformableVolume</span><span class="p">);</span>
</pre></div>
</div>
<p>After the deformable volume has been added to the scene, the GPU data needs to be initialized and copied to the GPU. We provide a set of extension functions in <code class="docutils literal notranslate"><span class="pre">PxDeformableVolumeExt</span></code> that serve as a starting point. First, pinned host memory buffers to mirror the data have to be allocated and initialized:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVec4</span><span class="o">*</span><span class="w"> </span><span class="n">simPositionInvMassPinned</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxVec4</span><span class="o">*</span><span class="w"> </span><span class="n">simVelocityPinned</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxVec4</span><span class="o">*</span><span class="w"> </span><span class="n">collPositionInvMassPinned</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxVec4</span><span class="o">*</span><span class="w"> </span><span class="n">restPositionPinned</span><span class="p">;</span>

<span class="n">PxDeformableVolumeExt</span><span class="o">::</span><span class="n">allocateAndInitializeHostMirror</span><span class="p">(</span><span class="o">*</span><span class="n">deformableVolume</span><span class="p">,</span><span class="w"> </span><span class="n">mCudaContextManager</span><span class="p">,</span>
<span class="w">    </span><span class="n">simPositionInvMassPinned</span><span class="p">,</span><span class="w"> </span><span class="n">simVelocityPinned</span><span class="p">,</span><span class="w"> </span><span class="n">collPositionInvMassPinned</span><span class="p">,</span><span class="w"> </span><span class="n">restPositionPinned</span><span class="p">);</span>
</pre></div>
</div>
<p>Ownership of the pinned host buffers is transferred to the user, who is responsible for freeing these buffers during the shutdown procedure.
To adjust location, orientation and scaling of a deformable volume after cooking, an optional call to transform will modify the internal deformable volume buffers accordingly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxDeformableVolumeExt</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="o">*</span><span class="n">deformableVolume</span><span class="p">,</span><span class="w"> </span><span class="n">transform</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="p">,</span>
<span class="w">    </span><span class="n">simPositionInvMassPinned</span><span class="p">,</span><span class="w"> </span><span class="n">simVelocityPinned</span><span class="p">,</span><span class="w"> </span><span class="n">collPositionInvMassPinned</span><span class="p">,</span><span class="w"> </span><span class="n">restPositionPinned</span><span class="p">);</span>
</pre></div>
</div>
<p>The maximal inverse mass ratio specifies how much the mass at connected vertices is allowed to vary. Big mass ratios in the mesh can be bad for the simulation stability and convergence. To ensure that the body has a properly defined mass, either total mass or mass density must be specified:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxDeformableVolumeExt</span><span class="o">::</span><span class="n">updateMass</span><span class="p">(</span><span class="o">*</span><span class="n">deformableVolume</span><span class="p">,</span><span class="w"> </span><span class="n">density</span><span class="p">,</span><span class="w"> </span><span class="n">maxInvMassRatio</span><span class="p">,</span><span class="w"> </span><span class="n">simPositionInvMassPinned</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, the deformable volume buffers need to be uploaded to the GPU. This can either be done by calling CUDA memcpy for every buffer to upload or more easily using the <code class="docutils literal notranslate"><span class="pre">copyToDevice</span></code> method from the deformable volume extensions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxDeformableVolumeExt</span><span class="o">::</span><span class="n">copyToDevice</span><span class="p">(</span><span class="o">*</span><span class="n">deformableVolume</span><span class="p">,</span><span class="w"> </span><span class="n">PxDeformableVolumeDataFlag</span><span class="o">::</span><span class="n">eALL</span><span class="p">,</span>
<span class="w">    </span><span class="n">simPositionInvMassPinned</span><span class="p">,</span><span class="w"> </span><span class="n">simVelocityPinned</span><span class="p">,</span><span class="w"> </span><span class="n">collPositionInvMassPinned</span><span class="p">,</span><span class="w"> </span><span class="n">restPositionPinned</span><span class="p">);</span>
</pre></div>
</div>
<p>In addition to the deformable volume geometry, a few solver settings should be configured. The section about tuning provides more details:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">deformableVolume</span><span class="o">-&gt;</span><span class="n">setSolverIterationCounts</span><span class="p">(</span><span class="n">iterCount</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
</section>
<section id="kinematic-deformable-volumes">
<h2>Kinematic Deformable Volumes<a class="headerlink" href="#kinematic-deformable-volumes" title="Link to this heading">#</a></h2>
<p>Deformable volumes support user-driven movements similar to kinematic rigid bodies. In addition a deformable volume can be partially kinematic. A partially kinematic deformable volume has kinematic targets specified for some of its vertices while others can move freely (the solver will update their location to minimize the deformable volume’s internal stress). PhysX ensures that vertices that got moved kinematically get the correct velocity assigned which is important for good collision responses.</p>
<p>One of the main use cases for partially kinematic deformable volumes are animated characters where the movement of the skin (often the skin is a time-sampled triangle mesh) is pre-defined but the body should still interact with the world, e. g. a shirt over the skin should show correct physical behavior and move with the animated object through collisions. The main advantage of using a deformable volume for this interaction is that they are space filling which makes collision detection more robust.</p>
<p>The setup of a fully or partially kinematic deformable volume is similar to a normal deformable volume but requires a couple of additional steps.</p>
<p>A fully kinematic deformable volume expects a kinematic target to be set for every simulation vertex whereas a partially kinematic deformable volume only expects a valid kinematic target for simulation mesh vertices with an inverse mass of zero. An inverse mass of zero means the vertex cannot be moved by the solver. This is desired since constrained vertices that have a kinematic target should not move since it’s the users responsibility to place them. The number of elements in the kinematic target buffer is always equal to the number of vertices in the simulation tetmesh. The preparation of kinematic targets can be done as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVec4</span><span class="o">*</span><span class="w"> </span><span class="n">kinematicTargets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PX_EXT_PINNED_MEMORY_ALLOC</span><span class="p">(</span><span class="n">PxVec4</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">cudaContextManager</span><span class="p">,</span><span class="w"> </span><span class="n">vertexCount</span><span class="p">);</span>
<span class="n">PxVec4</span><span class="o">*</span><span class="w"> </span><span class="n">positionInvMass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">mPositionsInvMass</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vertexCount</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PxVec4</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positionInvMass</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="c1">//Fix a couple of vertices</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">9.9f</span><span class="p">)</span>
<span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">)</span>
<span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>

<span class="w">    </span><span class="n">kinematicTargets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positionInvMass</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">PxVec4</span><span class="o">*</span><span class="w"> </span><span class="n">kinematicTargetsD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PX_EXT_DEVICE_MEMORY_ALLOC</span><span class="p">(</span><span class="n">PxVec4</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">cudaContextManager</span><span class="p">,</span><span class="w"> </span><span class="n">vertexCount</span><span class="p">);</span>
<span class="n">PxCudaContext</span><span class="o">*</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaContextManager</span><span class="o">-&gt;</span><span class="n">getCudaContext</span><span class="p">();</span>
<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">memcpyHtoD</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CUdeviceptr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">deformableVolume</span><span class="o">-&gt;</span><span class="n">getSimPositionInvMassBufferD</span><span class="p">()),</span><span class="w"> </span><span class="n">positionInvMass</span><span class="p">,</span><span class="w"> </span><span class="n">vertexCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">PxVec4</span><span class="p">));</span>
<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">memcpyHtoD</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CUdeviceptr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kinematicTargetsD</span><span class="p">),</span><span class="w"> </span><span class="n">kinematicTargets</span><span class="p">,</span><span class="w"> </span><span class="n">vertexCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">PxVec4</span><span class="p">));</span>
</pre></div>
</div>
<p>The user owns the kinematic target buffers and therefore is responsible to release their memory when they are not used anymore. To update the kinematic targets, one just executes the last line of the above snippets again to copy new kinematic targets to the gpu.</p>
<p>As last step of the setup process, the gpu buffer holding the kinematic targets must be registered:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">deformableVolume</span><span class="o">-&gt;</span><span class="n">setKinematicTargetBufferD</span><span class="p">(</span><span class="n">kinematicTargetsD</span><span class="p">);</span>
</pre></div>
</div>
<p>It usually makes sense to use the same simulation and collision tetmesh for a kinematic deformable volume (no voxel simulation mesh) because this setup simplifies the transfer of the animated motion to the deformable volume’s kinematic targets which is the users responsibility. To improve performance, it is possible to use the mesh simplifier to create a mapping that allows to drive a lower resolution deformable volume with a high resolution animated skin mesh.</p>
</section>
<section id="constitutive-model">
<span id="id1"></span><h2>Constitutive Model<a class="headerlink" href="#constitutive-model" title="Link to this heading">#</a></h2>
<p>To simulate volume deformation, a version of corotated linear elasticity is used that inherits the simplicity of linear models while enforcing rotational invariance.
A commonly used corotated model has the following form:</p>
<div class="math notranslate nohighlight">
\[\Psi(\mathbf{F}) = \mu \| \mathbf{F} - \mathbf{R} \|_F^2 + \frac{\lambda}{2} \operatorname{tr}^2(\mathbf{R}^T\mathbf{F} - \mathbf{I})\]</div>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{F}\)</span>: The deformation gradient.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Psi\)</span>: The energy density function of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{R}\)</span>: The rotational component of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> (<span class="math notranslate nohighlight">\(\mathbf{F}\)</span> = <span class="math notranslate nohighlight">\(\mathbf{R} \mathbf{S}\)</span>).</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{I}\)</span>: The Identity matrix.</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span>: The Lamé parameters.</p></li>
<li><p><span class="math notranslate nohighlight">\(\operatorname{tr(\cdot)}\)</span>: The trace of a matrix.</p></li>
<li><p><span class="math notranslate nohighlight">\(\operatorname{det(\cdot)}\)</span>: The determinant of a matrix.</p></li>
<li><p><span class="math notranslate nohighlight">\(\| \cdot \|_F^2\)</span>: The Frobenius norm of a matrix.</p></li>
</ul>
</div></blockquote>
<p>The first term resists stretching and compression and often referred as the As-Rigid-As-Possible (ARAP) energy, and the second term is to preserve the volume.
PhysX uses a similar energy model to the corotated linear model, but incorporates a different volume coservation term as shown below:</p>
<div class="math notranslate nohighlight">
\[\Psi(\mathbf{F}) = \mu \| \mathbf{F} - \mathbf{R} \|_F^2 + \frac{\lambda}{2} (\operatorname{det}(\mathbf{F}) - 1)^2.\]</div>
<p>This energy model is often referred to as the fixed corotated model.</p>
</section>
<section id="tuning">
<h2>Tuning<a class="headerlink" href="#tuning" title="Link to this heading">#</a></h2>
<p>As illustrated in <a class="reference internal" href="#constitutive-model"><span class="std std-ref">Constitutive Model</span></a>, the material behaviors are controlled by the Lamé parameters in the energy density function:
<span class="math notranslate nohighlight">\(\mu\)</span> for the first term (ARAP energy) and <span class="math notranslate nohighlight">\(\lambda\)</span> for the second term (volume-preserving energy).
However, many physics simulators including PhysX use an equivalent set of parameters: Young’s modulus <span class="math notranslate nohighlight">\(E\)</span> and Poisson’s ratio <span class="math notranslate nohighlight">\(\nu\)</span>, where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu &amp;= \frac{E}{2(1 + \nu)} \\ \\
\lambda &amp;= \frac{E \nu}{(1 + \nu)(1 - 2\nu)}.\end{split}\]</div>
<p>Practically speaking, increasing Young’s modulus <span class="math notranslate nohighlight">\(E\)</span> effectively makes the deformable volume stiffer, while a higher value of Poisson’s ratio <span class="math notranslate nohighlight">\(\nu \in [0, 0.5]\)</span> enforces better incompressibility.
Using a value of 0.5 for the Poisson’s ratio means enforcing full incompressibility (i.e., applying infinite stiffness to the volume-preserving term).
These material properties are controlled via <a class="reference internal" href="../_api_build/classPxDeformableMaterial.html#_CPPv420PxDeformableMaterial" title="PxDeformableMaterial"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxDeformableMaterial</span></code></a>.</p>
</section>
<section id="performance-considerations">
<h2>Performance Considerations<a class="headerlink" href="#performance-considerations" title="Link to this heading">#</a></h2>
<p>To improve performance, it is advisable to choose tetrahedral meshes with the lowest resolution that delivers satisfactory results.
At each simulation timestep, a stress measure is evaluated for each tetrahedron.
The resolution of a mesh, therefore, has a direct impact on the computational effort required to update the deformation.
Very stiff materials typically require more solver iterations to achieve convergence.
Using a lower resolution simulation mesh often helps to simulate stiff objects, while keeping the required number of iterations low.
To reduce the number of tetrahedra it is worth considering a collision mesh with very few interior nodes.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h2>
<p id="macklin-et-al-2019">MACKLIN M., STOREY K., LU M., TERDIMAN P., CHENTANEZ N., JESCHKE S., MÜLLER M.: Small steps in physics simulation. In Proceedings of the 18th Annual ACM SIGGRAPH/Eurographics
Symposium on Computer Animation (New York, NY, USA, 2019), SCA ’19, Association for Computing Machinery. URL: <a class="reference external" href="https://doi.org/10.1145/3309486.3340247">https://doi.org/10.1145/3309486.3340247</a>, doi:10.1145/3309486. 3340247. 3, 4</p>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="DeformableBodyOverview.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Deformable Body Overview</p>
      </div>
    </a>
    <a class="right-next"
       href="ParticleSystem.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Particle System</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tet-maker">Tet Maker</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mesh-cleaning">Mesh Cleaning</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cooking">Cooking</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-deformable-volumes">Using Deformable Volumes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kinematic-deformable-volumes">Kinematic Deformable Volumes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#constitutive-model">Constitutive Model</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tuning">Tuning</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#performance-considerations">Performance Considerations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
<a class="footer-brand logo" href="https://www.nvidia.com">
  <img src="../_static/nvidia-logo-horiz-rgb-1c-blk-for-screen.svg" class="logo__image only-light" alt="NVIDIA"/>
  <img src="../_static/nvidia-logo-horiz-rgb-1c-wht-for-screen.svg" class="logo__image only-dark" alt="NVIDIA"/>
</a></div>
      
        <div class="footer-item">



  <p class="copyright">
    
      Copyright © 2022-2025, NVIDIA Corporation.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item"><p class="last-updated">
  Last updated on Feb 07, 2025.
  <br/>
</p></div>
      
    </div>
  
  
  
</div>

  </footer>
  </body>
</html>