

<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Joints &#8212; PhysX SDK Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/nvidia-sphinx-theme.css?v=c5edffae" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=767de534" />
    <link rel="stylesheet" type="text/css" href="../_static/api.css?v=6f210184" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script rel="preload" src="../_static/modal-table.js"></script>
    <script src="../_static/documentation_options.js?v=bbec3584"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scrollspy-patch.js?v=edc4054a"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'docs/Joints';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = '../versions1.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '5.6.1';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <script src="../_static/version-patch.js?v=c24f8c5d"></script>
    <script rel="preload" src="../_static/toctree.js"></script>
    <link rel="icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Articulations" href="Articulations.html" />
    <link rel="prev" title="Advanced Collision Detection" href="AdvancedCollisionDetection.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Jul 22, 2025"/>


  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA-Omniverse/PhysX" title="github" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">github</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        



  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a>


  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA-Omniverse/PhysX" title="github" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">github</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">


<nav class="bd-docs-nav bd-links"
     aria-label="Table of Contents">
  <p class="bd-links__title" role="heading" aria-level="1">Table of Contents</p>
  <div class="bd-toc-item navbar-nav"></div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">


<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
  </div>
  
  <div id="rtd-footer-container"></div>



      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">Joints</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="joints">
<span id="id1"></span><h1>Joints<a class="headerlink" href="#joints" title="Link to this heading">#</a></h1>
<section id="joint-basics">
<h2>Joint Basics<a class="headerlink" href="#joint-basics" title="Link to this heading">#</a></h2>
<p>A joint constrains the way two actors move relative to one another. A typical use for a joint would be to model a door hinge or the shoulder of a character. A variety of joint types are implemented in the PhysX extensions library. Custom joints may also be implemented.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PhysX also supports reduced coordinate articulation joints. These are not covered here. Please refer to the section <a class="reference internal" href="Articulations.html#articulations"><span class="std std-ref">Articulations</span></a> to read about articulation joints.</p>
</div>
<p>The creation of simple joints and limits is demonstrated in the SnippetJoint snippet.</p>
<p>To create a joint, call the joint’s creation function <a class="reference internal" href="../_api_build/function_PxRevoluteJoint_8h_1a3165570816acab57a72cd3467c242e80.html#_CPPv421PxRevoluteJointCreateR9PxPhysicsP12PxRigidActorRK11PxTransformP12PxRigidActorRK11PxTransform" title="PxRevoluteJointCreate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxRevoluteJointCreate()</span></code></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxRevoluteJointCreate</span><span class="p">(</span><span class="n">PxPhysics</span><span class="o">&amp;</span><span class="w"> </span><span class="n">physics</span><span class="p">,</span>
<span class="w">                      </span><span class="n">PxRigidActor</span><span class="o">*</span><span class="w"> </span><span class="n">actor0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="o">&amp;</span><span class="w"> </span><span class="n">localFrame0</span><span class="p">,</span>
<span class="w">                      </span><span class="n">PxRigidActor</span><span class="o">*</span><span class="w"> </span><span class="n">actor1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="o">&amp;</span><span class="w"> </span><span class="n">localFrame1</span><span class="p">);</span>
</pre></div>
</div>
<p>This has the same pattern for all joints: two actors, and for each actor a constraint frame.</p>
<p>One of the actors must be movable, either a <a class="reference internal" href="../_api_build/classPxRigidDynamic.html#_CPPv414PxRigidDynamic" title="PxRigidDynamic"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRigidDynamic</span></code></a> or a <a class="reference internal" href="../_api_build/classPxArticulationLink.html#_CPPv418PxArticulationLink" title="PxArticulationLink"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxArticulationLink</span></code></a>. The other may be of one of those types, or a <a class="reference internal" href="../_api_build/classPxRigidStatic.html#_CPPv413PxRigidStatic" title="PxRigidStatic"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRigidStatic</span></code></a>. Use a NULL pointer here to indicate an implicit actor representing the immovable global reference frame.</p>
<p>Each localFrame argument specifies a constraint frame relative to the actor’s global pose. Let c0 and c1 denote these constraint frames (in world space). Each joint defines a relationship between the origins and orientations of constraint frames c0 and c1 that will be enforced by the PhysX constraint solver. In the case of a revolute joint, the constraints aim to co-locate the origins of c0 and c1 and to maintain the rule that their x-axes point in the same direction. However, the two constraint frames may rotate freely relative to each other around the common x-axis.</p>
<p>PhysX supports the following joint types:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../_api_build/classPxFixedJoint.html#_CPPv412PxFixedJoint" title="PxFixedJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxFixedJoint</span></code></a>: locks the orientations and origins rigidly together</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxDistanceJoint.html#_CPPv415PxDistanceJoint" title="PxDistanceJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxDistanceJoint</span></code></a>: keeps the origins within a certain distance range</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxSphericalJoint.html#_CPPv416PxSphericalJoint" title="PxSphericalJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxSphericalJoint</span></code></a>: (also called a <em>ball-and-socket</em>) keeps the origins together, but allows the orientations to vary freely.</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxRevoluteJoint.html#_CPPv415PxRevoluteJoint" title="PxRevoluteJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRevoluteJoint</span></code></a>: (also called a <em>hinge</em>) keeps the origins and x-axes of the frames together, and allows free rotation around this common axis.</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxPrismaticJoint.html#_CPPv416PxPrismaticJoint" title="PxPrismaticJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPrismaticJoint</span></code></a>: (also called a <em>slider</em>) keeps the orientations identical, but allows the origin of each frame to slide freely along the common x-axis.</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxGearJoint.html#_CPPv411PxGearJoint" title="PxGearJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxGearJoint</span></code></a>: uses a gear ratio to couple the rotations of two revolute joints.</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxRackAndPinionJoint.html#_CPPv420PxRackAndPinionJoint" title="PxRackAndPinionJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRackAndPinionJoint</span></code></a>: uses a gear ratio (rotation/distance) to couple the rotation of a revolute joint to the travel of a prismatic joint.</p></li>
<li><p><a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv49PxD6Joint" title="PxD6Joint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxD6Joint</span></code></a>: a highly configurable joint that allows to specify for individual degrees of freedom whether to move freely or be locked together. It can be used to implement a wide variety of mechanical and anatomical joints, but is somewhat less intuitive to configure than the other joint types. This joint is covered in detail further below.</p></li>
</ul>
<p>All joints are implemented as plugins to the SDK through the <a class="reference internal" href="../_api_build/classPxConstraint.html#_CPPv412PxConstraint" title="PxConstraint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraint</span></code></a> class. A number of the properties for each joint are configured using the <a class="reference internal" href="../_api_build/structPxConstraintFlag.html#_CPPv416PxConstraintFlag" title="PxConstraintFlag"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraintFlag</span></code></a> enumeration.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As in the rest of the PhysX API, all joint angles for limits and drive targets are specified in radians.</p>
</div>
<p>A description of the mathematics and implementation of PhysX joints may be found in the accompanying document <a class="reference download internal" download="" href="../_downloads/f27bad5e4b631dc274a41ecf77568a49/constraintFormulation.pdf"><code class="xref download docutils literal notranslate"><span class="pre">1d</span> <span class="pre">Constraint</span> <span class="pre">Formulation</span></code></a>.</p>
<section id="visualization">
<h3>Visualization<a class="headerlink" href="#visualization" title="Link to this heading">#</a></h3>
<p>All standard PhysX joints support debug visualization. You can visualize the joint frames of each actor, and also any limits the joint may have.</p>
<p>By default, joints are not visualized. To visualize a joint, set its visualization constraint flag and the appropriate scene-level visualization parameters:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">setVisualizationParameter</span><span class="p">(</span><span class="n">PxVisualizationParameter</span><span class="o">::</span><span class="n">eJOINT_LOCAL_FRAMES</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">scene</span><span class="o">-&gt;</span><span class="n">setVisualizationParameter</span><span class="p">(</span><span class="n">PxVisualizationParameter</span><span class="o">::</span><span class="n">eJOINT_LIMITS</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>

<span class="p">...</span>

<span class="n">joint</span><span class="o">-&gt;</span><span class="n">setConstraintFlag</span><span class="p">(</span><span class="n">PxConstraintFlag</span><span class="o">::</span><span class="n">eVISUALIZATION</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="force-reporting">
<h3>Force Reporting<a class="headerlink" href="#force-reporting" title="Link to this heading">#</a></h3>
<p>The force applied at a joint may be retrieved after simulation with a call to <a class="reference internal" href="../_api_build/classPxConstraint.html#_CPPv4NK12PxConstraint8getForceER6PxVec3R6PxVec3" title="PxConstraint::getForce"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getForce()</span></code></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">fetchResults</span><span class="p">(...);</span>
<span class="n">joint</span><span class="o">-&gt;</span><span class="n">getConstraint</span><span class="p">().</span><span class="n">getForce</span><span class="p">(</span><span class="n">force</span><span class="p">,</span><span class="w"> </span><span class="n">torque</span><span class="p">);</span>
</pre></div>
</div>
<p>The force is specified in the world frame.</p>
<p>Note that this force is only updated while the joint’s actors are awake.</p>
</section>
<section id="breakage">
<h3>Breakage<a class="headerlink" href="#breakage" title="Link to this heading">#</a></h3>
<p>All of the standard PhysX joints can be made <em>breakable</em>. A maximum breaking force and torque may be specified. If the force or torque required to maintain the joint constraint exceeds either threshold, the joint will break. Since the breakage is detected after the joint constraints are applied, there is no excess force or torque that could result in a post-breakage acceleration of the actors involved.</p>
<p>Breaking a joint generates a simulation event (see <a class="reference internal" href="../_api_build/classPxSimulationEventCallback.html#_CPPv4N25PxSimulationEventCallback17onConstraintBreakEP16PxConstraintInfo5PxU32" title="PxSimulationEventCallback::onConstraintBreak"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">onConstraintBreak()</span></code></a>), and the joint no longer participates in simulation, although it remains attached to its actors until it is deleted.</p>
<p>By default the threshold force and torque are set to PX_MAX_REAL, making joints effectively unbreakable. To make a joint breakable, specify the force and torque thresholds:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">PxReal</span><span class="w"> </span><span class="n">forceThreshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">100.0f</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">PxReal</span><span class="w"> </span><span class="n">torqueThreshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">200.0f</span><span class="p">;</span>
<span class="n">joint</span><span class="o">-&gt;</span><span class="n">setBreakForce</span><span class="p">(</span><span class="n">forceThreshold</span><span class="p">,</span><span class="w"> </span><span class="n">torqueThreshold</span><span class="p">);</span>
</pre></div>
</div>
<p>A constraint flag records whether a joint is currently broken:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">broken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">joint</span><span class="o">-&gt;</span><span class="n">getConstraintFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PxConstraintFlag</span><span class="o">::</span><span class="n">eBROKEN</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Breaking a joint causes a callback via <a class="reference internal" href="../_api_build/classPxSimulationEventCallback.html#_CPPv4N25PxSimulationEventCallback17onConstraintBreakEP16PxConstraintInfo5PxU32" title="PxSimulationEventCallback::onConstraintBreak"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">onConstraintBreak()</span></code></a>. In this callback, a pointer to the joint and its type are specified in the <a class="reference internal" href="../_api_build/structPxConstraintInfo.html#_CPPv4N16PxConstraintInfo17externalReferenceE" title="PxConstraintInfo::externalReference"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxConstraintInfo::externalReference</span></code></a> and <a class="reference internal" href="../_api_build/structPxConstraintInfo.html#_CPPv4N16PxConstraintInfo4typeE" title="PxConstraintInfo::type"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxConstraintInfo::type</span></code></a> fields of the <a class="reference internal" href="../_api_build/structPxConstraintInfo.html#_CPPv416PxConstraintInfo" title="PxConstraintInfo"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraintInfo</span></code></a> struct. For custom joint types it is recommended to use the <a class="reference internal" href="../_api_build/structPxConstraintInfo.html#_CPPv4N16PxConstraintInfo4typeE" title="PxConstraintInfo::type"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxConstraintInfo::type</span></code></a> field to determine the dynamic type of the broken constraint. Otherwise, simply cast the externalReference to a <a class="reference internal" href="../_api_build/classPxJoint.html#_CPPv47PxJoint" title="PxJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxJoint</span></code></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MySimulationEventCallback</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">onConstraintBreak</span><span class="p">(</span><span class="n">PxConstraintInfo</span><span class="o">*</span><span class="w"> </span><span class="n">constraints</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="w"> </span><span class="n">count</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">PxConstraintExtIDs</span><span class="o">::</span><span class="n">eJOINT</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">PxJoint</span><span class="o">*</span><span class="w"> </span><span class="n">joint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PxJoint</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">externalReference</span><span class="p">);</span>
<span class="w">                </span><span class="p">...</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">eUSER_CUSTOM_JOINT</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">CustomUserType</span><span class="o">*</span><span class="w"> </span><span class="n">customUserType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CustomUserType</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">externalReference</span><span class="p">);</span>
<span class="w">                </span><span class="p">...</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="limits">
<h3>Limits<a class="headerlink" href="#limits" title="Link to this heading">#</a></h3>
<p>Some PhysX joints constrain not just relative rotation or translation, but can also enforce <em>limits</em> on the range of that motion. For example, in its initial configuration the revolute joint allows free rotation around its axis.  This free rotation can be limited to to a range of angles by specifying a lower and upper limit and configuring the joint as a limited joint. The class <a class="reference internal" href="../_api_build/classPxRevoluteJoint.html#_CPPv415PxRevoluteJoint" title="PxRevoluteJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRevoluteJoint</span></code></a> serves as a good example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">revolute</span><span class="o">-&gt;</span><span class="n">setLimit</span><span class="p">(</span><span class="n">PxJointAngularLimitPair</span><span class="p">(</span><span class="o">-</span><span class="n">PxPi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">PxPi</span><span class="o">/</span><span class="mi">4</span><span class="p">));</span>
<span class="n">revolute</span><span class="o">-&gt;</span><span class="n">setRevoluteJointFlag</span><span class="p">(</span><span class="n">PxRevoluteJointFlag</span><span class="o">::</span><span class="n">eLIMIT_ENABLED</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Limits may be either <em>hard</em> or <em>soft</em>. When a hard limit is reached, relative motion will simply stop dead if the limit is configured with zero restitution, or bounce if the restitution is non-zero. When a soft limit is violated, the solver will pull the joint back towards the limit using a spring specified by the limit’s stiffness and damping parameters. By default, limits are hard and without restitution, so when the joint reaches a limit, motion will simply stop. To specify softness for a limit, declare the limit structure and set the stiffness and damping parameters directly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxJointAngularLimitPair</span><span class="w"> </span><span class="nf">limitPair</span><span class="p">(</span><span class="o">-</span><span class="n">PxPi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">PxPi</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
<span class="n">limitPair</span><span class="p">.</span><span class="n">stiffness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">100.0f</span><span class="p">;</span>
<span class="n">limitPair</span><span class="p">.</span><span class="n">damping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">;</span>
<span class="n">revolute</span><span class="o">-&gt;</span><span class="n">setLimit</span><span class="p">(</span><span class="n">limitPair</span><span class="p">);</span>
<span class="n">revolute</span><span class="o">-&gt;</span><span class="n">setRevoluteJointFlag</span><span class="p">(</span><span class="n">PxRevoluteJointFlag</span><span class="o">::</span><span class="n">eLIMIT_ENABLED</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="actuation">
<h3>Actuation<a class="headerlink" href="#actuation" title="Link to this heading">#</a></h3>
<p>Some PhysX joints may be actuated by a motor or a spring implicitly integrated by the PhysX solver. While driving simulations with actuated joints is more expensive than simply applying forces, it can provide much more stable control of simulation. See <a class="reference internal" href="#rbd6joint"><span class="std std-ref">D6 Joint</span></a> and <a class="reference internal" href="#rbrevolutejoint"><span class="std std-ref">Revolute Joint</span></a> for details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The force generated by actuation is not included in the force reported by the solver, nor does it contribute towards exceeding the joint’s breakage force threshold.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing the drive parameters for a joint, or activating or deactivating the drive, does not wake sleeping bodies attached to the joint. If required, wake these bodies manually.</p>
</div>
<p>When using spring drives (in particular, drives on the D6 joint), the flag <a class="reference internal" href="../_api_build/structPxD6JointDriveFlag.html#_CPPv4N18PxD6JointDriveFlag4Enum13eACCELERATIONE" title="PxD6JointDriveFlag::eACCELERATION"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxD6JointDriveFlag::eACCELERATION</span></code></a> is strongly recommended. This flag will automatically scale the strength of the spring according to the masses and inertias of the objects directly influenced by the drive, and can substantially reduce the amount of tuning required for stable behavior.</p>
</section>
<section id="mass-scaling">
<span id="joint-mass-scaling"></span><h3>Mass Scaling<a class="headerlink" href="#mass-scaling" title="Link to this heading">#</a></h3>
<p>PhysX joints may apply scale to the mass and moment of inertia of the two connected bodies for the purposes of resolving a joint. For example, if two objects in a ragdoll have masses 1 and 10, PhysX will typically resolve the joint by changing the velocity of the lighter body much more than the heavier one. A mass scale of 10 may be applied to the first body to make PhysX change the velocity of both bodies by an equal amount. To ensure the same property holds for both linear and angular velocity, the inertia scales may also be adjusted in accordance with the bodies’ inertias. Applying mass scales such that the joint sees similar effective masses and inertias makes the solver converge faster, which can make individual joints seem less rubbery or separated, and sets of jointed bodies appear less twitchy.</p>
<p>Many applications that prioritize visual behavior over adherence to physical laws can benefit from tuning these scale values. It is worth noting that mass and inertia scaling is fundamentally nonphysical. In general momentum will not be conserved, the energy of the system may increase, the force reported for the joint may be incorrect, and non-physical tuning of breakage thresholds and force limits may be required.</p>
</section>
</section>
<section id="fixed-joint">
<span id="rbfixedjoint"></span><h2>Fixed Joint<a class="headerlink" href="#fixed-joint" title="Link to this heading">#</a></h2>
<img alt="../_images/fixedJoint1.png" src="../_images/fixedJoint1.png" />
<p>The fixed joint <a class="reference internal" href="../_api_build/classPxFixedJoint.html#_CPPv412PxFixedJoint" title="PxFixedJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxFixedJoint</span></code></a> constrains two objects so that the positions and orientations of their constraint frames are the same.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All joints are enforced by the dynamics solver, so although under ideal conditions the objects will maintain their spatial relationship, there may be some drift. A common alternative, which is cheaper to simulate and does not suffer from drift, is to construct a single actor with multiple shapes. However, fixed joints are useful, for example, when a joint must be breakable or report its constraint force.</p>
</div>
</section>
<section id="spherical-joint">
<h2>Spherical Joint<a class="headerlink" href="#spherical-joint" title="Link to this heading">#</a></h2>
<img alt="../_images/sphericalJoint.png" src="../_images/sphericalJoint.png" />
<p>A spherical joint <a class="reference internal" href="../_api_build/classPxSphericalJoint.html#_CPPv416PxSphericalJoint" title="PxSphericalJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxSphericalJoint</span></code></a> constrains the origins of the actor’s constraint frames to be coincident.</p>
<p>The spherical joint supports a cone limit, which constrains the angle between the x-axes of the two constraint frames. Actor1’s x-axis is constrained by a limit cone whose axis is the x-axis of actor0’s constraint frame. The allowed limit values are the maximum rotation around the y- and z-axes of that frame. Different values for the y- and z-axes may be specified, in which case the limit takes the form of an elliptical angular cone:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">joint</span><span class="o">-&gt;</span><span class="n">setLimitCone</span><span class="p">(</span><span class="n">PxJointLimitCone</span><span class="p">(</span><span class="n">PxPi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">PxPi</span><span class="o">/</span><span class="mi">6</span><span class="p">);</span>
<span class="n">joint</span><span class="o">-&gt;</span><span class="n">setSphericalJointFlag</span><span class="p">(</span><span class="n">PxSphericalJointFlag</span><span class="o">::</span><span class="n">eLIMIT_ENABLED</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that very small or highly elliptical limit cones may result in solver jitter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Visualization of the limit surface can help considerably in understanding its shape.</p>
</div>
</section>
<section id="revolute-joint">
<span id="rbrevolutejoint"></span><h2>Revolute Joint<a class="headerlink" href="#revolute-joint" title="Link to this heading">#</a></h2>
<img alt="../_images/revoluteJoint1.png" src="../_images/revoluteJoint1.png" />
<p>A revolute joint <a class="reference internal" href="../_api_build/classPxRevoluteJoint.html#_CPPv415PxRevoluteJoint" title="PxRevoluteJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRevoluteJoint</span></code></a> removes all but a single rotational degree of freedom from two objects. The axis along which the two bodies may rotate is specified by the common origin of the joint frames and their common x-axis. In theory, all origin points along the axis of rotation are equivalent, but simulation stability is best in practice when the point is near where the bodies are closest.</p>
<p>The joint supports a rotational limit with upper and lower extents. The angle is zero when the y- and z-axes of the joint frames are coincident, and increases moving from the y-axis towards the z-axis:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">joint</span><span class="o">-&gt;</span><span class="n">setLimit</span><span class="p">(</span><span class="n">PxJointAngularLimitPair</span><span class="p">(</span><span class="o">-</span><span class="n">PxPi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">PxPi</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
<span class="n">joint</span><span class="o">-&gt;</span><span class="n">setRevoluteJointFlag</span><span class="p">(</span><span class="n">PxRevoluteJointFlag</span><span class="o">::</span><span class="n">eLIMIT_ENABLED</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>The joint also supports a motor which drives the relative angular velocity of the two actors towards a user-specified target velocity. The magnitude of the force applied by the motor may be limited to a specified maximum:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">joint</span><span class="o">-&gt;</span><span class="n">setDriveVelocity</span><span class="p">(</span><span class="mf">10.0f</span><span class="p">);</span>
<span class="n">joint</span><span class="o">-&gt;</span><span class="n">setRevoluteJointFlag</span><span class="p">(</span><span class="n">PxRevoluteJointFlag</span><span class="o">::</span><span class="n">eDRIVE_ENABLED</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>By default, when the angular velocity at the joint exceeds the target velocity the motor acts as a brake; a freespin flag <a class="reference internal" href="../_api_build/structPxRevoluteJointFlag.html#_CPPv4N19PxRevoluteJointFlag4Enum15eDRIVE_FREESPINE" title="PxRevoluteJointFlag::eDRIVE_FREESPIN"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxRevoluteJointFlag::eDRIVE_FREESPIN</span></code></a> disables this braking behavior.</p>
<p>The drive force limit for a revolute joint may be interpreted either as a force or an impulse, depending on the value of <a class="reference internal" href="../_api_build/structPxConstraintFlag.html#_CPPv4N16PxConstraintFlag4Enum24eDRIVE_LIMITS_ARE_FORCESE" title="PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES</span></code></a>.</p>
</section>
<section id="prismatic-joint">
<span id="rbprismaticjoint"></span><h2>Prismatic Joint<a class="headerlink" href="#prismatic-joint" title="Link to this heading">#</a></h2>
<img alt="../_images/prismJoint1.png" src="../_images/prismJoint1.png" />
<p>A prismatic joint <a class="reference internal" href="../_api_build/classPxPrismaticJoint.html#_CPPv416PxPrismaticJoint" title="PxPrismaticJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPrismaticJoint</span></code></a> prevents all rotational motion, but allows the origin of actor1’s constraint frame to move freely along the x-axis of actor0’s constraint frame. The prismatic joint supports a single limit with upper and lower bounds on the distance between the two constraint frames’ origin points:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">joint</span><span class="o">-&gt;</span><span class="n">setLimit</span><span class="p">(</span><span class="n">PxJointLinearLimitPair</span><span class="p">(</span><span class="n">tolerancesScale</span><span class="p">,</span><span class="w"> </span><span class="mf">-10.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">);</span>
<span class="n">joint</span><span class="o">-&gt;</span><span class="n">setPrismaticJointFlag</span><span class="p">(</span><span class="n">PxPrismaticJointFlag</span><span class="o">::</span><span class="n">eLIMIT_ENABLED</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="distance-joint">
<span id="rbdistancejoint"></span><h2>Distance Joint<a class="headerlink" href="#distance-joint" title="Link to this heading">#</a></h2>
<img alt="../_images/distanceJoint.png" src="../_images/distanceJoint.png" />
<p>The distance joint <a class="reference internal" href="../_api_build/classPxDistanceJoint.html#_CPPv415PxDistanceJoint" title="PxDistanceJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxDistanceJoint</span></code></a> keeps the origins of the constraint frames within a certain range of distance. The range may have both upper and lower bounds, which are enabled separately by flags:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">joint</span><span class="o">-&gt;</span><span class="n">setMaxDistance</span><span class="p">(</span><span class="mf">10.0f</span><span class="p">);</span>
<span class="n">joint</span><span class="o">-&gt;</span><span class="n">setDistanceJointFlag</span><span class="p">(</span><span class="n">eMAX_DISTANCE_ENABLED</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Motion beyond the maximum distance may either be entirely prevented by the solver, or pushed back towards its range with an implicit spring, for which stiffness and damping parameters may be specified.</p>
</section>
<section id="gear-joint">
<span id="rbgearjoint"></span><h2>Gear Joint<a class="headerlink" href="#gear-joint" title="Link to this heading">#</a></h2>
<a class="reference internal image-reference" href="../_images/ext_physics-joints-gear.png"><img alt="../_images/ext_physics-joints-gear.png" src="../_images/ext_physics-joints-gear.png" style="width: 520.0px; height: 347.1px;" />
</a>
<p>The gear joint <a class="reference internal" href="../_api_build/classPxGearJoint.html#_CPPv411PxGearJoint" title="PxGearJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxGearJoint</span></code></a> uses a gear ratio to constrain the relative angular velocity of the two bodies of the joint. Additionally, it contrains the relative position of the two bodies of the joint.</p>
<p>It is required that the two bodies of the gear joint rotate only around the twist axis.  The requirement for each body may in turn be enforced by additional joints such as <a class="reference internal" href="../_api_build/classPxRevoluteJoint.html#_CPPv415PxRevoluteJoint" title="PxRevoluteJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRevoluteJoint</span></code></a> or <a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv49PxD6Joint" title="PxD6Joint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxD6Joint</span></code></a> configured with a single rotational degree of freedom around <a class="reference internal" href="../_api_build/structPxD6Axis.html#_CPPv4N8PxD6Axis4Enum6eTWISTE" title="PxD6Axis::eTWIST"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxD6Axis::eTWIST</span></code></a>.  <a class="reference internal" href="../_api_build/classPxGearJoint.html#_CPPv411PxGearJoint" title="PxGearJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxGearJoint</span></code></a> also allows either or both of the bodies to be of type <a class="reference internal" href="../_api_build/classPxArticulationLink.html#_CPPv418PxArticulationLink" title="PxArticulationLink"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxArticulationLink</span></code></a>. This being the case, the inbound <a class="reference internal" href="../_api_build/classPxArticulationJointReducedCoordinate.html#_CPPv436PxArticulationJointReducedCoordinate" title="PxArticulationJointReducedCoordinate"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxArticulationJointReducedCoordinate</span></code></a> should be configured to be of type <a class="reference internal" href="../_api_build/structPxArticulationJointType.html#_CPPv4N23PxArticulationJointType4Enum9eREVOLUTEE" title="PxArticulationJointType::eREVOLUTE"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxArticulationJointType::eREVOLUTE</span></code></a> or  <a class="reference internal" href="../_api_build/structPxArticulationJointType.html#_CPPv4N23PxArticulationJointType4Enum19eREVOLUTE_UNWRAPPEDE" title="PxArticulationJointType::eREVOLUTE_UNWRAPPED"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxArticulationJointType::eREVOLUTE_UNWRAPPED</span></code></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">gearJoint</span><span class="o">-&gt;</span><span class="n">setHinges</span><span class="p">(</span><span class="n">hinge0</span><span class="p">,</span><span class="w"> </span><span class="n">hinge1</span><span class="p">);</span>
<span class="n">gearJoint</span><span class="o">-&gt;</span><span class="n">setGearRatio</span><span class="p">(</span><span class="n">gearRatio</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="rack-and-pinion-joint">
<span id="rbrackandpinionjoint"></span><h2>Rack And Pinion Joint<a class="headerlink" href="#rack-and-pinion-joint" title="Link to this heading">#</a></h2>
<a class="reference internal image-reference" href="../_images/ext_physics-joints-rackandpinion.png"><img alt="../_images/ext_physics-joints-rackandpinion.png" src="../_images/ext_physics-joints-rackandpinion.png" style="width: 520.0px; height: 347.1px;" />
</a>
<p>The gear joint <a class="reference internal" href="../_api_build/classPxGearJoint.html#_CPPv411PxGearJoint" title="PxGearJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxGearJoint</span></code></a> uses a gear ratio to enforce a relationship between the angular velocity of one body and the linear velocity of another. Additionally, it contrains the relative position of the two bodies of the joint.</p>
<p>It is required that one body of the pair has a single translational degree of freedom.  A further requirement is that the other body of the pair has a single rotational degree of freedom. These requirements may be enforced in turn by additional joints. For example, the requirement of translational motion may be enforced with <a class="reference internal" href="../_api_build/classPxPrismaticJoint.html#_CPPv416PxPrismaticJoint" title="PxPrismaticJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxPrismaticJoint</span></code></a> or <a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv49PxD6Joint" title="PxD6Joint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxD6Joint</span></code></a> configured with a single translational degree of freedom along <a class="reference internal" href="../_api_build/structPxD6Axis.html#_CPPv4N8PxD6Axis4Enum2eXE" title="PxD6Axis::eX"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxD6Axis::eX</span></code></a>.  Likewise, the requirement of rotational motion may be enforced with <a class="reference internal" href="../_api_build/classPxRevoluteJoint.html#_CPPv415PxRevoluteJoint" title="PxRevoluteJoint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxRevoluteJoint</span></code></a> or a <a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv49PxD6Joint" title="PxD6Joint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxD6Joint</span></code></a> configured with a single rotational degree of freedom around <a class="reference internal" href="../_api_build/structPxD6Axis.html#_CPPv4N8PxD6Axis4Enum6eTWISTE" title="PxD6Axis::eTWIST"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxD6Axis::eTWIST</span></code></a>.  Either or both of the bodies may be of type <a class="reference internal" href="../_api_build/classPxArticulationLink.html#_CPPv418PxArticulationLink" title="PxArticulationLink"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxArticulationLink</span></code></a>.  This being the case, the inbound <a class="reference internal" href="../_api_build/classPxArticulationJointReducedCoordinate.html#_CPPv436PxArticulationJointReducedCoordinate" title="PxArticulationJointReducedCoordinate"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxArticulationJointReducedCoordinate</span></code></a> should be configured to be <a class="reference internal" href="../_api_build/structPxArticulationJointType.html#_CPPv4N23PxArticulationJointType4Enum9eREVOLUTEE" title="PxArticulationJointType::eREVOLUTE"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxArticulationJointType::eREVOLUTE</span></code></a> or  <a class="reference internal" href="../_api_build/structPxArticulationJointType.html#_CPPv4N23PxArticulationJointType4Enum19eREVOLUTE_UNWRAPPEDE" title="PxArticulationJointType::eREVOLUTE_UNWRAPPED"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxArticulationJointType::eREVOLUTE_UNWRAPPED</span></code></a> for the rotating body and <a class="reference internal" href="../_api_build/structPxArticulationJointType.html#_CPPv4N23PxArticulationJointType4Enum10ePRISMATICE" title="PxArticulationJointType::ePRISMATIC"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxArticulationJointType::ePRISMATIC</span></code></a> for the translating body:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rackAndPinionJoint</span><span class="o">-&gt;</span><span class="n">setJoints</span><span class="p">(</span><span class="n">hinge0</span><span class="p">,</span><span class="w"> </span><span class="n">prismatic</span><span class="p">);</span>
<span class="n">rackAndPinionJoint</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="n">nbRackTeeth</span><span class="p">,</span><span class="w"> </span><span class="n">nbPinionTeeth</span><span class="p">,</span><span class="w"> </span><span class="n">rackLength</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="d6-joint">
<span id="rbd6joint"></span><h2>D6 Joint<a class="headerlink" href="#d6-joint" title="Link to this heading">#</a></h2>
<p>The D6 joint <a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv49PxD6Joint" title="PxD6Joint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxD6Joint</span></code></a> is by far the most complex of the standard PhysX joints. In its default state it behaves like a fixed joint - that is, it rigidly fixes the constraint frames of its two actors. However, individual degrees of freedom may be unlocked to permit any combination of rotation around the x-, y- and z-axis, and translation along these axes.</p>
<section id="locking-and-unlocking-axes">
<h3>Locking and Unlocking Axes<a class="headerlink" href="#locking-and-unlocking-axes" title="Link to this heading">#</a></h3>
<p>To unlock and lock degrees of freedom, use the <a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv4N9PxD6Joint9setMotionEN8PxD6Axis4EnumEN10PxD6Motion4EnumE" title="PxD6Joint::setMotion"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxD6Joint::setMotion()</span></code></a> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eX</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
</pre></div>
</div>
<p>Unlocking translational degrees of freedom allows the origin point of actor1’s constraint frame to move along a subset of the axes defined by actor0’s constraint frame. For example, unlocking just the x-axis creates the equivalent of a prismatic joint.</p>
<p>Rotational degrees of freedom are partitioned as <em>twist</em> (around the x-axis of actor0’s constraint frame) and <em>swing</em> (around the y- and z-axis). Different effects are achieved by unlocking various combinations of twist and swing.</p>
<ul class="simple">
<li><p>if just a single degree of angular freedom is unlocked, the result is always equivalent to a revolute joint. It is recommended that if just one angular degree of freedom is unlocked, it should be the twist degree, because the joint has various configuration options and optimizations that are designed for this case.</p></li>
</ul>
<ul class="simple">
<li><p>if both swing degrees of freedom are unlocked but the twist degree remains locked, the result is a <em>zero-twist</em> joint. The x-axis of actor1 swings freely away from the x-axis of actor0 but twists to minimize the rotation required to align the two frames. This creates a kind of isotropic universal joint which avoids the problems of the usual ‘engineering style’ universal joint (see below) that is sometimes used as a kind of twist constraint. There is a nasty singularity at π radians (180 degrees) swing, so a swing limit should be used to avoid the singularity.</p></li>
</ul>
<ul class="simple">
<li><p>if one swing and one twist degree of freedom are unlocked but the remaining swing is kept locked, a <em>zero-swing</em> joint results (often also called a <em>universal</em> joint). If for example the <a class="reference internal" href="../_api_build/structPxD6Axis.html#_CPPv4N8PxD6Axis4Enum7eSWING1E" title="PxD6Axis::eSWING1"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxD6Axis::eSWING1</span></code></a> (y-axis rotation) is unlocked, the x-axis of actor1 is constrained to remain orthogonal to the y-axis of actor0. In character applications, this joint can be used to model an elbow swing joint incorporating the twist freedom of the lower arm or a knee swing joint incorporating the twist freedom of the lower leg. In vehicle applications, these joints can be used as ‘steered wheel’ joints in which the child actor is the wheel, free to rotate about its twist axis, while the free swing axis in the parent acts as the steering axis. Care must be taken with this combination because of anisotropic behavior and singularities (beware the dreaded gimbal lock) at angles of π/2 radians (90 degrees), making the zero-twist joint a better behaved alternative for most use cases.</p></li>
</ul>
<ul class="simple">
<li><p>if all three angular degrees are unlocked, the result is equivalent to a spherical joint.</p></li>
</ul>
<p>Common use cases can be implemented as follows:</p>
<ul>
<li><p>The cylindrical joint (with axis along the common x-axis of the two constraint frames) is given by the combination:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eX</span><span class="p">,</span><span class="w">     </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eTWIST</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>the point-on-plane joint (with plane axis along the x-axis of actor0’s constraint frame) is given by the combination:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eY</span><span class="p">,</span><span class="w">      </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eZ</span><span class="p">,</span><span class="w">      </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eTWIST</span><span class="p">,</span><span class="w">  </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eSWING1</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eSWING2</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>the point-on-line joint (with axis along the x-axis of actor0’s constraint frame) is given by the combination:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eX</span><span class="p">,</span><span class="w">      </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eTWIST</span><span class="p">,</span><span class="w">  </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eSWING1</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eSWING2</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id2">
<h3>Limits<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<p>Any axis configured as free may also be specified as limited. The D6 supports different limits which may be used in any combination.</p>
<p>A single linear limit with only an upper bound is used to constrain any of the translational degrees of freedom. The limit constrains the distance between the origins of the constraint frames when projected onto these axes. For example, the combination:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eX</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eY</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eLIMITED</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eZ</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eLIMITED</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setDistanceLimit</span><span class="p">(</span><span class="n">PxJointLinearLimit</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</pre></div>
</div>
<p>constrains the y- and z-coordinates of actor1’s constraint frame to lie within the unit disc. Since the x-axis is unconstrained, the effect is to constrain the origin of actor1’s constraint frame to lie within a cylinder of radius 1 extending along the x-axis of actor0’s constraint frame.</p>
<p>The D6 joint also supports per-axis linear limit pairs, with the <a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv4N9PxD6Joint14setLinearLimitERK18PxJointLinearLimit" title="PxD6Joint::setLinearLimit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">setLinearLimit()</span></code></a> function. This can be used to implement a prismatic joint when only one of the linear axis is limited and the others remain locked. Otherwise in 2D and 3D this gives birth to quad-shaped and box-shaped limit volumes, as opposed to the disc-shaped and sphere-shaped volumes generated by <a class="reference internal" href="../_api_build/classPxD6Joint.html#_CPPv4N9PxD6Joint16setDistanceLimitERK18PxJointLinearLimit" title="PxD6Joint::setDistanceLimit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">setDistanceLimit()</span></code></a>.</p>
<p>The twist degree of freedom is limited by a pair limit with upper and lower bounds, identical to the limit of the revolute joint.</p>
<p>If both swing degrees of freedom are limited, a limit cone is generated, identical to the limit of the spherical joint. As with the spherical joint, very small or highly elliptical limit cones may result in solver jitter.</p>
<p>If only one swing degree of freedom is limited, the corresponding angle from the cone limit is used to limit rotation. If the other swing degree is locked, the maximum value of the limit is π radians (180 degrees). If the other swing degree is free, the maximum value of the limit is π/2 radians (90 degrees).</p>
</section>
<section id="drives">
<h3>Drives<a class="headerlink" href="#drives" title="Link to this heading">#</a></h3>
<p>The D6 has a linear drive model, and two possible angular drive models. The drive is a <em>proportional derivative</em> drive, which applies a force as follows:</p>
<p><em>force = stiffness * (targetPosition - position) + damping * (targetVelocity - velocity)</em></p>
<p>The drive model may also be configured to generate a proportional acceleration instead of a force, factoring in the masses of the actors to which the joint is attached. Acceleration drive is often easier to tune than force drive.</p>
<dl class="simple">
<dt>The linear drive model for the D6 has the following parameters:</dt><dd><ul class="simple">
<li><p>target position, specified in actor0’s constraint frame</p></li>
<li><p>target velocity, specified in actor0’s constraint frame</p></li>
<li><p>stiffness</p></li>
<li><p>damping</p></li>
<li><p>forceLimit - the maximum force (or impulse, see <a class="reference internal" href="../_api_build/structPxConstraintFlag.html#_CPPv4N16PxConstraintFlag4Enum24eDRIVE_LIMITS_ARE_FORCESE" title="PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES</span></code></a>) the drive can apply</p></li>
<li><p>acceleration drive flag</p></li>
</ul>
</dd>
</dl>
<p>The drive attempts to follow the desired position input with the configured stiffness and damping properties. A physical lag due to the inertia of the driven body acting through the drive spring will occur; therefore, sudden step changes will result over a number of time steps. Physical lag can be reduced by stiffening the spring or supplying a velocity target.</p>
<p>With a fixed position input and a zero target velocity, a position drive will spring about that drive position with the specified stiffness/damping characteristics:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// set all translational degrees free</span>

<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eX</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eY</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setMotion</span><span class="p">(</span><span class="n">PxD6Axis</span><span class="o">::</span><span class="n">eZ</span><span class="p">,</span><span class="w"> </span><span class="n">PxD6Motion</span><span class="o">::</span><span class="n">eFREE</span><span class="p">);</span>

<span class="c1">// set all translation degrees driven:</span>

<span class="k">const</span><span class="w"> </span><span class="n">PxD6JointDrive</span><span class="w"> </span><span class="nf">drive</span><span class="p">(</span><span class="mf">10.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">,</span><span class="w"> </span><span class="n">PX_MAX_F32</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setDrive</span><span class="p">(</span><span class="n">PxD6Drive</span><span class="o">::</span><span class="n">eX</span><span class="p">,</span><span class="w"> </span><span class="n">drive</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setDrive</span><span class="p">(</span><span class="n">PxD6Drive</span><span class="o">::</span><span class="n">eY</span><span class="p">,</span><span class="w"> </span><span class="n">drive</span><span class="p">);</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setDrive</span><span class="p">(</span><span class="n">PxD6Drive</span><span class="o">::</span><span class="n">eZ</span><span class="p">,</span><span class="w"> </span><span class="n">drive</span><span class="p">);</span>

<span class="c1">// Drive the joint to the local(actor[0]) origin - since no angular</span>
<span class="c1">// dofs are free, the angular part of the transform is ignored</span>

<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setDrivePosition</span><span class="p">(</span><span class="n">PxTransform</span><span class="p">(</span><span class="n">PxIdentity</span><span class="p">));</span>
<span class="n">d6joint</span><span class="o">-&gt;</span><span class="n">setDriveVelocity</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="n">PxZero</span><span class="p">),</span><span class="w"> </span><span class="n">PxVec3</span><span class="p">(</span><span class="n">PxZero</span><span class="p">));</span>
</pre></div>
</div>
<p>Angular drive differs from linear drive in a fundamental way: it does not have a simple and intuitive representation free from singularities. For this reason, the D6 joint provides two angular drive models - twist &amp; swing and SLERP (Spherical Linear Interpolation).</p>
<p>The two models differ in the way they estimate the path in quaternion space between the current orientation and the target orientation. In a SLERP drive, the quaternion is used directly. In a twist &amp; swing drive, it is decomposed into separate twist and swing components and each component is interpolated separately. Twist &amp; swing is intuitive in many situations; however, there is a singularity when driven to 180 degrees swing. In addition, the drive will not follow the shortest arc between two orientations. On the other hand, SLERP drive will follow the shortest arc between a pair of angular configurations, but may cause unintuitive changes in the joint’s twist and swing.</p>
<p>The angular drive model has the following parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p>An angular velocity target specified relative to actor0’s constraint frame</p></li>
<li><p>An orientation target specified relative to actor0’s constraint frame</p></li>
<li><p>drive specifications for SLERP (<a class="reference internal" href="../_api_build/structPxD6Drive.html#_CPPv4N9PxD6Drive4Enum6eSLERPE" title="PxD6Drive::eSLERP"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">eSLERP</span></code></a>), swing (<a class="reference internal" href="../_api_build/structPxD6Drive.html#_CPPv4N9PxD6Drive4Enum6eSWINGE" title="PxD6Drive::eSWING"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">eSWING</span></code></a>) and twist (<a class="reference internal" href="../_api_build/structPxD6Drive.html#_CPPv4N9PxD6Drive4Enum6eTWISTE" title="PxD6Drive::eTWIST"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">eTWIST</span></code></a>):</p></li>
<li><p>stiffness</p></li>
<li><p>damping</p></li>
<li><p>forceLimit - the maximum torque (or impulse, see <a class="reference internal" href="../_api_build/structPxConstraintFlag.html#_CPPv4N16PxConstraintFlag4Enum24eDRIVE_LIMITS_ARE_FORCESE" title="PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES</span></code></a>) the drive can apply.</p></li>
<li><p>acceleration drive flag. If this flag is set, the acceleration (rather than the force) applied by the drive is proportional to the angle from the target.</p></li>
</ul>
</div></blockquote>
<p>Best results will be achieved when the drive target inputs are consistent with the joint freedom and limit constraints.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If any angular degrees of freedom are locked, the SLERP drive parameters are ignored. If all angular degrees of freedom are unlocked, and parameters are set for multiple angular drives, the SLERP parameters will be used.</p>
</div>
</section>
<section id="configuring-physx-joint-types-for-best-behavior">
<h3>Configuring PhysX Joint Types for Best Behavior<a class="headerlink" href="#configuring-physx-joint-types-for-best-behavior" title="Link to this heading">#</a></h3>
<p>The behavior quality of joints in PhysX is largely determined by the ability of the iterative solver to converge. Better convergence can be achieved simply by increasing the attributes of the PxRigidDynamic that control the solver iteration count. However, joints themselves can also be purposefully configured to produce better convergence, as set out in the following observations.</p>
<ul class="simple">
<li><p>the solver can have difficulty converging well when a light object is constrained between two heavy objects. Mass ratios higher than 10 are best avoided in such scenarios.</p></li>
<li><p>when one body is significantly heavier than the other, make the lighter body the second actor in the joint. Similarly, when one of the objects is static or kinematic (or the actor pointer is NULL) make the dynamic body the second actor.</p></li>
</ul>
<p>A common use for joints is to move objects around in the world. Best results are obtained when the solver has access to the velocity of motion as well as the change in position.</p>
<ul class="simple">
<li><p>if a very stiff controller is desired that moves the object to a specific position each frame, consider jointing the object to a kinematic actor and use the setKinematicTarget function to move the actor.</p></li>
<li><p>if a more springy controller is desired, use a D6 joint with a drive target to set the desired position and orientation, and control the spring parameters to increase stiffness and damping.  In general, acceleration drive is much easier to tune than force drive.</p></li>
</ul>
</section>
</section>
<section id="custom-constraints">
<h2>Custom Constraints<a class="headerlink" href="#custom-constraints" title="Link to this heading">#</a></h2>
<p>It is also possible to add new joint types to PhysX. Use the existing joints in the PhysXExtensions library as a reference, and also the source for SnippetCustomJoint, which shows how to implement a Pulley Joint. Serializing custom objects is discussed in the chapter <a class="reference internal" href="Serialization.html#serialization"><span class="std std-ref">Serialization</span></a>, so the discussion here is limited to how to achieve the desired behavior in simulation. This is an advanced topic, and assumes familiarity with the mathematics underlying rigid body simulation. The presentation here assumes that the joint constrains two bodies; the case for a static body is equivalent to a dynamic body of infinite mass.</p>
<p>The functions that implement dynamic behavior of joints are PhysX <em>shaders</em>, similar in nature to the <a class="reference internal" href="../_api_build/typedef_PxFiltering_8h_1a235380b2a5b3cc89a4cd89d089d72b33.html#_CPPv424PxSimulationFilterShader" title="PxSimulationFilterShader"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxSimulationFilterShader</span></code></a> (see <a class="reference internal" href="RigidBodyCollision.html#collisionfiltering"><span class="std std-ref">Collision Filtering</span></a>). In particular, the functions may execute in parallel and asynchronously, and should not access any state except that passed in as parameters.</p>
<p>To create a custom joint class, define the following:</p>
<ul class="simple">
<li><p>the functions which implement the behavior of the constraint. The functions must be stateless, because they may be called simultaneously from multiple threads. When each function is called, PhysX passes a <em>constant block</em> which can be used to store the joint configuration parameters (offsets, axes, limits etc).</p></li>
<li><p>a static instance of PxConstraintShaderTable containing pointers to the functions</p></li>
<li><p>a class implementing the PxConstraintConnector interface, that connects the custom joint to PhysX.</p></li>
</ul>
<section id="defining-constraint-behavior">
<h3>Defining Constraint Behavior<a class="headerlink" href="#defining-constraint-behavior" title="Link to this heading">#</a></h3>
<p>The most important function that defines the joint behavior is the <em>solver preparation</em> function, which generates inputs to PhysX’s velocity-based constraint solver.</p>
<p>The processing sequence during simulation is as follows:</p>
<ul class="simple">
<li><p>in the simulate() function, before starting simulation, the scene updates an internal copy of the joint’s constant block (so that the joint’s copy may be modified during simulation without causing races).</p></li>
<li><p>collision detection runs, and may wake bodies. If the joint connects two bodies, the simulation will ensure that either both bodies are awake, or neither is.</p></li>
<li><p>for every joint connected to an awake body, the simulation calls the solver preparation function.</p></li>
<li><p>the solver updates body velocities and positions.</p></li>
</ul>
<section id="the-solver-preparation-function">
<h4>The Solver Preparation Function<a class="headerlink" href="#the-solver-preparation-function" title="Link to this heading">#</a></h4>
<p>The solver preparation function for a joint has the following signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxU32</span><span class="w"> </span><span class="nf">prepare</span><span class="p">(</span><span class="n">Px1DConstraint</span><span class="o">*</span><span class="w"> </span><span class="n">constraints</span><span class="p">,</span>
<span class="w">              </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bodyAWorldOffset</span><span class="p">,</span>
<span class="w">              </span><span class="n">PxU32</span><span class="w"> </span><span class="n">maxConstraints</span><span class="p">,</span>
<span class="w">              </span><span class="n">PxConstraintInvMassScale</span><span class="w"> </span><span class="o">&amp;</span><span class="n">invMassScale</span><span class="p">,</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">constantBlock</span><span class="p">,</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bodyAToWorld</span><span class="p">,</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bodyBToWorld</span><span class="p">,</span>
<span class="w">              </span><span class="kt">bool</span><span class="w"> </span><span class="n">useExtendedLimits</span><span class="p">,</span>
<span class="w">              </span><span class="n">PxVec3p</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cAtW</span><span class="p">,</span>
<span class="w">              </span><span class="n">PxVec3p</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cBtW</span><span class="p">);</span>
</pre></div>
</div>
<p>The parameters are as follows:</p>
<ul class="simple">
<li><p><em>constraints</em> is the output buffer of constraint rows.</p></li>
<li><p><em>bodyAWorldOffset</em> is the point, specified in world space as an offset from the origin of bodyA, at which the constraint forces act to enforce the joint. The constraint solver ignores this value as the information is already encoded in the constraint array, but when reporting forces it is necessary to choose a point at which the force is considered to act. For PhysX joints, the attachment point of the joint on body B is used.</p></li>
<li><p><em>maxConstraints</em> is the size of the buffer, which limits the number of constraint rows that may be generated.</p></li>
<li><p><em>invMassScale</em> is the inverse mass scales which should be applied to the bodies for the purpose of resolving the joint. In the standard joints, these are just the joint’s mass scaling parameters (see <a class="reference internal" href="#joint-mass-scaling"><span class="std std-ref">Mass Scaling</span></a>).</p></li>
<li><p><em>constantBlock</em> is the simulation’s copy of the joint constant block.</p></li>
<li><p><em>bodyAToWorld</em> is the center of mass frame of the first constrained body (the identity transform if the first actor is static, or if a NULL actor pointer was provided for it).</p></li>
<li><p><em>bodyBToWorld</em> is the center of mass frame of the second constrained body (the identity transform if the second actor is static, or if a NULL actor pointer was provided for it)</p></li>
<li><p><em>useExtendedLimits</em> enables angular limit ranges outside of (-π, π).</p></li>
<li><p>cAtW is the world space location of body A’s joint frame (position only).</p></li>
<li><p>cBtW is the world space location of body B’s joint frame (position only)</p></li>
</ul>
<p>The role of the solver preparation function is to populate the buffer of <a class="reference internal" href="../_api_build/structPx1DConstraint.html#_CPPv414Px1DConstraint" title="Px1DConstraint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Px1DConstraint</span></code></a> structs, provide the point of application for force reporting, and provide the mass scaling properties. The return value is the number of <a class="reference internal" href="../_api_build/structPx1DConstraint.html#_CPPv414Px1DConstraint" title="Px1DConstraint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Px1DConstraint</span></code></a> structs generated in the output buffer.</p>
<p>Notice that although the joint parameters (relative pose etc) are typically specified relative to an actor, the solver preparation function works with the transforms of the underlying rigid bodies. The constraint infrastructure (see <a class="reference internal" href="#constraint-infrastructure"><span class="std std-ref">Data Management</span></a>) assists joints in maintaining consistency when, for example, the application modifies the center of mass of an actor.</p>
<p>Each <a class="reference internal" href="../_api_build/structPx1DConstraint.html#_CPPv414Px1DConstraint" title="Px1DConstraint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Px1DConstraint</span></code></a> constrains one degree of freedom between the two bodies. The structure looks like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Px1DConstraint</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PxVec3</span><span class="w">                </span><span class="n">linear0</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxReal</span><span class="w">                </span><span class="n">geometricError</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxVec3</span><span class="w">                </span><span class="n">angular0</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxReal</span><span class="w">                </span><span class="n">velocityTarget</span><span class="p">;</span>

<span class="w">    </span><span class="n">PxVec3</span><span class="w">                </span><span class="n">linear1</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxReal</span><span class="w">                </span><span class="n">minImpulse</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxVec3</span><span class="w">                </span><span class="n">angular1</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxReal</span><span class="w">                </span><span class="n">maxImpulse</span><span class="p">;</span>

<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">SpringModifiers</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">PxReal</span><span class="w">        </span><span class="n">stiffness</span><span class="p">;</span>
<span class="w">            </span><span class="n">PxReal</span><span class="w">        </span><span class="n">damping</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">spring</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">RestitutionModifiers</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">PxReal</span><span class="w">        </span><span class="n">restitution</span><span class="p">;</span>
<span class="w">            </span><span class="n">PxReal</span><span class="w">        </span><span class="n">velocityThreshold</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">bounce</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">mods</span><span class="p">;</span>

<span class="w">    </span><span class="n">PxU16</span><span class="w">                </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxU16</span><span class="w">                </span><span class="n">solveHint</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each <a class="reference internal" href="../_api_build/structPx1DConstraint.html#_CPPv414Px1DConstraint" title="Px1DConstraint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Px1DConstraint</span></code></a> is either a hard constraint (for example, one axis of a fixed joint) or a soft constraint (for example, a spring). A joint may have a mixture of hard and soft constraint rows - for example, the actuated joint at a rag doll shoulder often has:</p>
<ul class="simple">
<li><p>3 hard 1D-constraints which prevent the shoulder from separating.</p></li>
<li><p>3 hard 1D-constraints constraining the angular degrees of freedom within some limits.</p></li>
<li><p>3 soft constraints simulating resistance to angular motion from muscles.</p></li>
</ul>
<p>The constraint is treated as hard unless the <a class="reference internal" href="../_api_build/structPx1DConstraintFlag.html#_CPPv4N18Px1DConstraintFlag4Type7eSPRINGE" title="Px1DConstraintFlag::eSPRING"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Px1DConstraintFlag::eSPRING</span></code></a> flag is set.</p>
<p>For both soft and hard constraints, the <em>solver velocity</em> for each row is the quantity:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linear0</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">body0LinVel</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">angular0</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">body0AngVel</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">linear1</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">body1LinVel</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">angular1</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">body1AngVel</span><span class="p">)</span>
</pre></div>
</div>
<section id="hard-constraints">
<h5>Hard Constraints<a class="headerlink" href="#hard-constraints" title="Link to this heading">#</a></h5>
<p>For a hard constraint, the solver attempts to generate:</p>
<ul>
<li><p>a set of motion solver velocities vMotion for objects which, when integrated, respect the constraint errors, represented by the equation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vMotion</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">geometricError</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">timestep</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">velocityTarget</span>
</pre></div>
</div>
</li>
<li><p>a set of post-simulation solver velocities vNext for the objects which respect the constraints:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">velocityTarget</span>
</pre></div>
</div>
</li>
</ul>
<p>The motion velocities are used for integration and then discarded. The post-simulation velocities are the values that <a class="reference internal" href="../_api_build/classPxRigidBody.html#_CPPv4NK11PxRigidBody17getLinearVelocityEv" title="PxRigidBody::getLinearVelocity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getLinearVelocity()</span></code></a> and <a class="reference internal" href="../_api_build/classPxRigidBody.html#_CPPv4NK11PxRigidBody18getAngularVelocityEv" title="PxRigidBody::getAngularVelocity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getAngularVelocity()</span></code></a> return.</p>
<p>There are two special options for hard constraints, both most often used to implement limits: restitution and velocity biasing. They are set by the constraint flags <a class="reference internal" href="../_api_build/structPx1DConstraintFlag.html#_CPPv4N18Px1DConstraintFlag4Type12eRESTITUTIONE" title="Px1DConstraintFlag::eRESTITUTION"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Px1DConstraintFlag::eRESTITUTION</span></code></a> and <a class="reference internal" href="../_api_build/structPx1DConstraintFlag.html#_CPPv4N18Px1DConstraintFlag4Type9eKEEPBIASE" title="Px1DConstraintFlag::eKEEPBIAS"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Px1DConstraintFlag::eKEEPBIAS</span></code></a>, are mutually exclusive, and restitution takes priority (in the sense that if restitution is set, biasing is ignored).</p>
<p>Restitution simulates bouncing (off a limit, for example). If the impact solver velocity vCurrent at the start of simulation exceeds the restitution velocity threshold, the target velocity of the constraint will be set to:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">restitution</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="n">vCurrent</span>
</pre></div>
</div>
<p>and the input velocityTarget field will be ignored. To use restitution, set <a class="reference internal" href="../_api_build/structPx1DConstraintFlag.html#_CPPv4N18Px1DConstraintFlag4Type12eRESTITUTIONE" title="Px1DConstraintFlag::eRESTITUTION"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Px1DConstraintFlag::eRESTITUTION</span></code></a>.</p>
<p>Velocity biasing generates post-simulation velocities to satisfy the same constraints as for the motion velocities:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vNext</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">geometricError</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">timestep</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">velocityTarget</span>
</pre></div>
</div>
<p>This can be useful for speculative continuous collision detection scenarios. An example might be a joint that is approaching but has not yet reached a limit. If the target velocity is 0 and the geometric error is the distance remaining to the limit, then no impulse will be applied if the limit is not reached within the given timestep. However, if the limit is to be violated within the given timestep, the solver will apply an impulse that will reduce the velocity such that the limit will be reached exactly instead.</p>
</section>
<section id="soft-constraints">
<h5>Soft Constraints<a class="headerlink" href="#soft-constraints" title="Link to this heading">#</a></h5>
<p>Alternatively, the solver can attempt to resolve the velocity constraint as an implicit spring. In this case, the motion velocity vMotion and post-simulation velocity vNext are the same. The solver solves the equation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stiffness</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="n">geometricError</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">damping</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">velocityTarget</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>where F is the constraint force.</p>
<p>Springs are fully implicit: that is, the force or acceleration is a function of the position and velocity after the solve. There is one special option that applies only to soft constraints: acceleration springs (<a class="reference internal" href="../_api_build/structPx1DConstraintFlag.html#_CPPv4N18Px1DConstraintFlag4Type20eACCELERATION_SPRINGE" title="Px1DConstraintFlag::eACCELERATION_SPRING"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Px1DConstraintFlag::eACCELERATION_SPRING</span></code></a>). With this option the solver will scale the magnitude of the force in accordance with the response of the two bodies; effectively it implicitly solves the equation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">acceleration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stiffness</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="n">geometricError</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">damping</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">velocityTarget</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="force-limits-and-reporting">
<h5>Force Limits and Reporting<a class="headerlink" href="#force-limits-and-reporting" title="Link to this heading">#</a></h5>
<p>All constraints support limits on the minimum or maximum impulse applied for each row. There is a special flag for force limits: <a class="reference internal" href="../_api_build/structPx1DConstraintFlag.html#_CPPv4N18Px1DConstraintFlag4Type16eHAS_DRIVE_LIMITE" title="Px1DConstraintFlag::eHAS_DRIVE_LIMIT"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Px1DConstraintFlag::eHAS_DRIVE_LIMIT</span></code></a>. If this flag is set, the force limits will be scaled by the timestep unless <a class="reference internal" href="../_api_build/structPxConstraintFlag.html#_CPPv4N16PxConstraintFlag4Enum24eDRIVE_LIMITS_ARE_FORCESE" title="PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES</span></code></a> is set for the constraint.</p>
<p>The flag <a class="reference internal" href="../_api_build/structPx1DConstraintFlag.html#_CPPv4N18Px1DConstraintFlag4Type13eOUTPUT_FORCEE" title="Px1DConstraintFlag::eOUTPUT_FORCE"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Px1DConstraintFlag::eOUTPUT_FORCE</span></code></a> flag on a 1D constraint determines whether the force applied for this row should be included in the constraint force output. The reporting force is also used internally to determine joint breakage. For example, if creating a spherical joint with angular drive that breaks when the stress on the linear part exceeds a threshold, set the flag for the linear equality rows but not the angular drive rows.</p>
</section>
<section id="solver-preprocessing">
<h5>Solver Preprocessing<a class="headerlink" href="#solver-preprocessing" title="Link to this heading">#</a></h5>
<p>The joint solver attempts to preprocess hard constraints to improve convergence. The solveHint value controls preprocessing for each row (see <a class="reference internal" href="../_api_build/structPxConstraintSolveHint.html#_CPPv421PxConstraintSolveHint" title="PxConstraintSolveHint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraintSolveHint</span></code></a>):</p>
<ul class="simple">
<li><p>if the constraint is a hard equality constraint with unbounded impulse limits (i.e. the impulse limits are -PX_MAX_REAL and PX_MAX_REAL), set this to <a class="reference internal" href="../_api_build/structPxConstraintSolveHint.html#_CPPv4N21PxConstraintSolveHint4Enum9eEQUALITYE" title="PxConstraintSolveHint::eEQUALITY"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintSolveHint::eEQUALITY</span></code></a>.</p></li>
<li><p>If one of the force limits is zero and the other unbounded, set it to <a class="reference internal" href="../_api_build/structPxConstraintSolveHint.html#_CPPv4N21PxConstraintSolveHint4Enum11eINEQUALITYE" title="PxConstraintSolveHint::eINEQUALITY"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintSolveHint::eINEQUALITY</span></code></a>.</p></li>
<li><p>for all soft constraints, and hard constraints with impulse limits other than the above, set it to <a class="reference internal" href="../_api_build/structPxConstraintSolveHint.html#_CPPv4N21PxConstraintSolveHint4Enum5eNONEE" title="PxConstraintSolveHint::eNONE"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintSolveHint::eNONE</span></code></a>.</p></li>
</ul>
<p>The solver does not check that the hint value is consistent with the values in the Px1DConstraint. Using inconsistent values may result in undefined behavior.</p>
</section>
<section id="id3">
<h5>Mass Scaling<a class="headerlink" href="#id3" title="Link to this heading">#</a></h5>
<p>When using mass scaling or when constraining bodies with infinite inertia along some axes, the reduction in degrees of freedom of the rigid bodies combined with small inaccuracies in floating point calculation can produce arbitrarily stiff constraint responses trying to correct unnoticeably small errors. This can appear, for example, when attempting to perform 2D-simulation using infinite inertia to suppress velocity out of the plane of simulation. In these cases, set the flag <a class="reference internal" href="../_api_build/structPxConstraintFlag.html#_CPPv4N16PxConstraintFlag4Enum22eDISABLE_PREPROCESSINGE" title="PxConstraintFlag::eDISABLE_PREPROCESSING"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintFlag::eDISABLE_PREPROCESSING</span></code></a>, and set the minResponseThreshold on the constraint to a small value, e.g. 1e-8. This will result in such stiff constraint rows being ignored when encountered, and can considerably improve simulation quality.</p>
</section>
</section>
</section>
<section id="the-constraint-shader-table">
<h3>The Constraint Shader Table<a class="headerlink" href="#the-constraint-shader-table" title="Link to this heading">#</a></h3>
<p>After coding the behavior functions, define a structure of type <a class="reference internal" href="../_api_build/structPxConstraintShaderTable.html#_CPPv423PxConstraintShaderTable" title="PxConstraintShaderTable"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraintShaderTable</span></code></a>, which holds the pointers to the constraint functions. This structure will be passed as an argument to <a class="reference internal" href="../_api_build/classPxPhysics.html#_CPPv4N9PxPhysics16createConstraintEP12PxRigidActorP12PxRigidActorR21PxConstraintConnectorRK23PxConstraintShaderTable5PxU32" title="PxPhysics::createConstraint"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxPhysics::createConstraint()</span></code></a>, and is shared by all instances of the joint:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">PxConstraintShaderTable</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PxConstraintSolverPrep</span><span class="w">    </span><span class="n">solverPrep</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxConstraintVisualize</span><span class="w">     </span><span class="n">visualize</span><span class="p">;</span>
<span class="w">    </span><span class="n">PxConstraintFlag</span><span class="o">::</span><span class="n">Enum</span><span class="w">    </span><span class="n">flag</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The constraint visualizer allows the joint to generate visualization information using the <a class="reference internal" href="../_api_build/classPxConstraintVisualizer.html#_CPPv422PxConstraintVisualizer" title="PxConstraintVisualizer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraintVisualizer</span></code></a> interface. The functionality of this interface is somewhat biased towards the standard joints; examples of its use can be found in the extensions library.</p>
</section>
<section id="data-management">
<span id="constraint-infrastructure"></span><h3>Data Management<a class="headerlink" href="#data-management" title="Link to this heading">#</a></h3>
<p>Next, define the class which lets PhysX manage the joint. This class should inherit from the <a class="reference internal" href="../_api_build/classPxConstraintConnector.html#_CPPv421PxConstraintConnector" title="PxConstraintConnector"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraintConnector</span></code></a> interface.</p>
<p>To create a joint, call <a class="reference internal" href="../_api_build/classPxPhysics.html#_CPPv4N9PxPhysics16createConstraintEP12PxRigidActorP12PxRigidActorR21PxConstraintConnectorRK23PxConstraintShaderTable5PxU32" title="PxPhysics::createConstraint"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxPhysics::createConstraint()</span></code></a>. The arguments to this function are the constrained actors, the connector object, the shader table, and the size of the joint’s constant block. The return value is a pointer to a <a class="reference internal" href="../_api_build/classPxConstraint.html#_CPPv412PxConstraint" title="PxConstraint"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxConstraint</span></code></a> object.</p>
<p>PxConstraintConnector has a number of data management callbacks:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">    </span><span class="nf">prepareData</span><span class="p">();</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">onConstraintRelease</span><span class="p">();</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">onComShift</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">actor</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">onOriginShift</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">shift</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">    </span><span class="nf">getExternalReference</span><span class="p">(</span><span class="n">PxU32</span><span class="o">&amp;</span><span class="w"> </span><span class="n">typeID</span><span class="p">);</span>
</pre></div>
</div>
<p>These functions are usually boilerplate; sample implementations can be found for the joints in the extensions library:</p>
<ul class="simple">
<li><p>The prepareData() function requests a pointer to the joint constant block, and allows the joint to update any state caches etc. When the function returns, the scene makes an internal copy of this data, so that the joint may be modified during simulation without race conditions. The function is called at the start of the simulation step after the joint is inserted into the scene, and on a subsequent simulation step if PhysX is informed that the joint’s state has changed.  To inform PhysX that the joint state has changed, call <a class="reference internal" href="../_api_build/classPxConstraint.html#_CPPv4N12PxConstraint9markDirtyEv" title="PxConstraint::markDirty"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxConstraint::markDirty()</span></code></a>.</p></li>
<li><p>onConstraintRelease() is associated with joint deletion. To delete a joint, call <a class="reference internal" href="../_api_build/classPxConstraint.html#_CPPv4N12PxConstraint7releaseEv" title="PxConstraint::release"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxConstraint::release()</span></code></a> on the constraint. When it is safe to destroy the joint (because no internal references are being held by currently executing simulation threads) the constraint code will call PxConstraint::onConstraintRelease(). This function can safely run the destructor and release the joint’s memory etc.</p></li>
<li><p>onComShift() is called when the application calls <a class="reference internal" href="../_api_build/classPxRigidBody.html#_CPPv4N11PxRigidBody17setCMassLocalPoseERK11PxTransform" title="PxRigidBody::setCMassLocalPose"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">setCMassLocalPose()</span></code></a> on one of the actors connected by the joint. This is provided because the solver preparation function is defined using the frame of the underlying rigid body, but the joint configuration is typically defined in terms of the actors.</p></li>
<li><p>onOriginShift() is called when the application shifts the origin of a scene. This is necessary because some joints may have a NULL actor, signifying that they are attached to the world frame.</p></li>
<li><p>getExternalReference() is used by PhysX to report simulation events involving constraints, particularly breakage. The returned pointer is passed directly to the application in the event callback, along with the typeID which the application can use in order to cast the pointer to the appropriate type. The typeID should be distinct for each custom joint type, and not use any of the IDs reserved by PhysX (see <a class="reference internal" href="../_api_build/structPxConstraintExtIDs.html#_CPPv4N18PxConstraintExtIDs4Enum13eNEXT_FREE_IDE" title="PxConstraintExtIDs::eNEXT_FREE_ID"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxConstraintExtIDs::eNEXT_FREE_ID</span></code></a>).</p></li>
</ul>
</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="AdvancedCollisionDetection.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Advanced Collision Detection</p>
      </div>
    </a>
    <a class="right-next"
       href="Articulations.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Articulations</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joint-basics">Joint Basics</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#force-reporting">Force Reporting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#breakage">Breakage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#limits">Limits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#actuation">Actuation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mass-scaling">Mass Scaling</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fixed-joint">Fixed Joint</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spherical-joint">Spherical Joint</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#revolute-joint">Revolute Joint</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prismatic-joint">Prismatic Joint</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#distance-joint">Distance Joint</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gear-joint">Gear Joint</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rack-and-pinion-joint">Rack And Pinion Joint</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#d6-joint">D6 Joint</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#locking-and-unlocking-axes">Locking and Unlocking Axes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Limits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#drives">Drives</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#configuring-physx-joint-types-for-best-behavior">Configuring PhysX Joint Types for Best Behavior</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#custom-constraints">Custom Constraints</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#defining-constraint-behavior">Defining Constraint Behavior</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-solver-preparation-function">The Solver Preparation Function</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#hard-constraints">Hard Constraints</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#soft-constraints">Soft Constraints</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#force-limits-and-reporting">Force Limits and Reporting</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#solver-preprocessing">Solver Preprocessing</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Mass Scaling</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-constraint-shader-table">The Constraint Shader Table</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-management">Data Management</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
<a class="footer-brand logo" href="https://www.nvidia.com">
  <img src="../_static/nvidia-logo-horiz-rgb-1c-blk-for-screen.svg" class="logo__image only-light" alt="NVIDIA"/>
  <img src="../_static/nvidia-logo-horiz-rgb-1c-wht-for-screen.svg" class="logo__image only-dark" alt="NVIDIA"/>
</a></div>
      
        <div class="footer-item">



  <p class="copyright">
    
      Copyright © 2022-2025, NVIDIA Corporation.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item"><p class="last-updated">
  Last updated on Jul 22, 2025.
  <br/>
</p></div>
      
    </div>
  
  
  
</div>

  </footer>
  </body>
</html>