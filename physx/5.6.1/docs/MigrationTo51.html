

<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Migrating From PhysX SDK 4.0 to 5.1 &#8212; PhysX SDK Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/nvidia-sphinx-theme.css?v=c5edffae" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=767de534" />
    <link rel="stylesheet" type="text/css" href="../_static/api.css?v=6f210184" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script rel="preload" src="../_static/modal-table.js"></script>
    <script src="../_static/documentation_options.js?v=bbec3584"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scrollspy-patch.js?v=edc4054a"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'docs/MigrationTo51';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = '../versions1.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '5.6.1';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <script src="../_static/version-patch.js?v=c24f8c5d"></script>
    <script rel="preload" src="../_static/toctree.js"></script>
    <link rel="icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Migrating From PhysX SDK 5.1 to 5.2" href="MigrationTo52.html" />
    <link rel="prev" title="Migrating From PhysX SDK 3.4 to 4.0" href="MigrationTo40.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Jul 22, 2025"/>


  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA-Omniverse/PhysX" title="github" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">github</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        



  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a>


  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA-Omniverse/PhysX" title="github" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">github</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">


<nav class="bd-docs-nav bd-links"
     aria-label="Table of Contents">
  <p class="bd-links__title" role="heading" aria-level="1">Table of Contents</p>
  <div class="bd-toc-item navbar-nav"></div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">


<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
  </div>
  
  <div id="rtd-footer-container"></div>



      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">Migrating...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="migrating-from-physx-sdk-4-0-to-5-1">
<span id="migrationto51"></span><h1>Migrating From PhysX SDK 4.0 to 5.1<a class="headerlink" href="#migrating-from-physx-sdk-4-0-to-5-1" title="Link to this heading">#</a></h1>
<ul class="simple">
<li><p>This guide highlights all significant parts of the API that have changed in the last release.  An application with a working integration of the older version of PhysX should be able to easily migrate to the newer version by following these pointers.</p></li>
</ul>
<section id="removed-apis">
<h2>Removed APIs<a class="headerlink" href="#removed-apis" title="Link to this heading">#</a></h2>
<p>Newly removed APIs are:</p>
<ul class="simple">
<li><p>The double-buffering feature. It is not allowed anymore to add, remove or modify scene objects while the simulation is running. Users are now required to buffer their changes themselves, and apply them after fetchResults() has returned.</p></li>
</ul>
</section>
<section id="simulation">
<h2>Simulation<a class="headerlink" href="#simulation" title="Link to this heading">#</a></h2>
<p>The default constraint solver has been changed to <a class="reference internal" href="RigidBodyDynamics.html#temporalgaussseidel"><span class="std std-ref">Projected Gauss-Seidel and Temporal Gauss-Seidel</span></a>.
The previous PGS solver is still available by setting <a class="reference internal" href="../_api_build/classPxSceneDesc.html#_CPPv4N11PxSceneDesc10solverTypeE" title="PxSceneDesc::solverType"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PxSceneDesc::solverType</span></code></a> accordingly.</p>
</section>
<section id="generic">
<h2>Generic<a class="headerlink" href="#generic" title="Link to this heading">#</a></h2>
<p>The <em>PxFlags::set()</em> function is gone. Please use either <a class="reference internal" href="../_api_build/classPxFlags.html#_CPPv4N7PxFlags5raiseE8enumtype" title="PxFlags::raise"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxFlags::raise()</span></code></a> to set a single flag, or operator= to set all flags at once.</p>
<p><em>PxBroadPhaseCaps::maxNbObjects</em> is gone. It was unused and always set to zero.</p>
</section>
<section id="materials">
<h2>Materials<a class="headerlink" href="#materials" title="Link to this heading">#</a></h2>
<p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxMaterialFlag::eIMPROVED_PATCH_FRICTION</span></code> is now enabled by default on all PxMaterial objects. This generally provides higher quality friction for no performance cost, so it is recommended to use this flag. For exact compatibility with the PhysX behavior of previous versions, disable that flag on your materials.</p>
</section>
<section id="cooking">
<h2>Cooking<a class="headerlink" href="#cooking" title="Link to this heading">#</a></h2>
<p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxPhysicsInsertionCallback</span></code> is deprecated, renamed to <a class="reference internal" href="../_api_build/classPxInsertionCallback.html#_CPPv419PxInsertionCallback" title="PxInsertionCallback"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PxInsertionCallback</span></code></a>. The <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxCooking</span></code> object itself is deprecated, replaced with standalone cooking functions. For example <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxCooking::cookTriangleMesh()</span></code> is now simply <a class="reference internal" href="../_api_build/function_PxCooking_8h_1adb0bf96f474b4409f6eff94cb364aa68.html#_CPPv418PxCookTriangleMeshRKN5physx15PxCookingParamsERKN5physx18PxTriangleMeshDescERN5physx14PxOutputStreamEPN5physx27PxTriangleMeshCookingResult4EnumE" title="PxCookTriangleMesh"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxCookTriangleMesh()</span></code></a>. Generally speaking add a Px prefix to the previous cooking function name to find the replacement function. The <em>PxCooking</em> object made multithreaded cooking more difficult than necessary, because of the shared <a class="reference internal" href="../_api_build/structPxCookingParams.html#_CPPv415PxCookingParams" title="PxCookingParams"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxCookingParams</span></code></a> structure. The new cooking functions all take a <em>PxCookingParams</em> parameter, making them easier to call from multiple threads.</p>
</section>
<section id="shapes">
<h2>Shapes<a class="headerlink" href="#shapes" title="Link to this heading">#</a></h2>
<p>The return type of the <a class="reference internal" href="../_api_build/classPxShape.html#_CPPv4NK7PxShape11getGeometryEv" title="PxShape::getGeometry"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxShape::getGeometry()</span></code></a> function has changed. It previously returned a <a class="reference internal" href="../_api_build/classPxGeometryHolder.html#_CPPv416PxGeometryHolder" title="PxGeometryHolder"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxGeometryHolder</span></code></a> object by value, it now returns a reference to a <a class="reference internal" href="../_api_build/classPxGeometry.html#_CPPv410PxGeometry" title="PxGeometry"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxGeometry</span></code></a> object. The change was made possible after the removal of the double-buffering layer. Most code should still compile after the change, but patterns like these ones would break:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">shape</span><span class="o">-&gt;</span><span class="n">getGeometry</span><span class="p">().</span><span class="n">any</span><span class="p">()</span>
</pre></div>
</div>
<p>In most cases you can simply replace this with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">shape</span><span class="o">-&gt;</span><span class="n">getGeometry</span><span class="p">()</span>
</pre></div>
</div>
<p>In case the PxGeometryHolder class is really needed, you will now need to create one explicitly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxGeometryHolder</span><span class="w"> </span><span class="nf">geomHolder</span><span class="p">(</span><span class="n">shape</span><span class="o">-&gt;</span><span class="n">getGeometry</span><span class="p">());</span>
</pre></div>
</div>
</section>
<section id="joints">
<h2>Joints<a class="headerlink" href="#joints" title="Link to this heading">#</a></h2>
<p><em>PxJointLimitParameters::contactDistance</em> is deprecated and will be removed eventually. The parameter’s name has been changed to <em>PxJointLimitParameters::contactDistance_deprecated</em> to reflect this. The contact distance feature was a minor optimization that does not provide much gains in practice, while making the simulation sometimes worse. For example when the simulation goes from inactive limits (deactived because of the contact distance) to violated limits in one frame, the behavior is not as good as if the limits would have been active all the time.</p>
</section>
<section id="scene-queries">
<h2>Scene Queries<a class="headerlink" href="#scene-queries" title="Link to this heading">#</a></h2>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxGeometryQuery::getWorldBounds()</span></code> has been deprecated. Please use <a class="reference internal" href="../_api_build/classPxGeometryQuery.html#_CPPv4N15PxGeometryQuery17computeGeomBoundsER9PxBounds3RK10PxGeometryRK11PxTransformff20PxGeometryQueryFlags" title="PxGeometryQuery::computeGeomBounds"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxGeometryQuery::computeGeomBounds()</span></code></a> instead.</p>
<hr class="docutils" />
<p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxHitFlag::eMESH_ANY</span></code> is deprecated, please use <a class="reference internal" href="../_api_build/structPxHitFlag.html#_CPPv4N9PxHitFlag4Enum8eANY_HITE" title="PxHitFlag::eANY_HIT"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">PxHitFlag::eANY_HIT</span></code></a> instead. The name changed after the introduction of <a class="reference internal" href="../_api_build/classPxCustomGeometry.html#_CPPv416PxCustomGeometry" title="PxCustomGeometry"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxCustomGeometry</span></code></a>, since a <em>PxCustomGeometry</em> can now be a sub-scene that would also benefit from the <em>PxHitFlag::eANY_HIT</em> flag. This flag is thus not limited to meshes anymore.</p>
<hr class="docutils" />
<p>The <a class="reference internal" href="../_api_build/structPxQueryHit.html#_CPPv410PxQueryHit" title="PxQueryHit"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxQueryHit</span></code></a> structure does not contain the hit actor and shape pointers directly. As a result the <a class="reference internal" href="../_api_build/classPxQueryFilterCallback.html#_CPPv4N21PxQueryFilterCallback10postFilterERK12PxFilterDataRK10PxQueryHitPK7PxShapePK12PxRigidActor" title="PxQueryFilterCallback::postFilter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxQueryFilterCallback::postFilter()</span></code></a> function has changed. The hit actor and hit shape are now passed as extra arguments to the function.</p>
<p>Replace this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">PxQueryHitType</span><span class="o">::</span><span class="n">Enum</span><span class="w"> </span><span class="nf">postFilter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxFilterData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filterData</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxQueryHit</span><span class="o">&amp;</span><span class="w"> </span><span class="n">hit</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">PxRigidActor</span><span class="o">*</span><span class="w"> </span><span class="n">hitActor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hit</span><span class="p">.</span><span class="n">actor</span><span class="p">;</span>
<span class="w">        </span><span class="n">PxShape</span><span class="o">*</span><span class="w"> </span><span class="n">hitShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hit</span><span class="p">.</span><span class="n">shape</span><span class="p">;</span>
<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With that:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">PxQueryHitType</span><span class="o">::</span><span class="n">Enum</span><span class="w"> </span><span class="nf">postFilter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxFilterData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filterData</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxQueryHit</span><span class="o">&amp;</span><span class="w"> </span><span class="n">hit</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxShape</span><span class="o">*</span><span class="w"> </span><span class="n">shape</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxRigidActor</span><span class="o">*</span><span class="w"> </span><span class="n">actor</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">PxRigidActor</span><span class="o">*</span><span class="w"> </span><span class="n">hitActor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">actor</span><span class="p">;</span>
<span class="w">        </span><span class="n">PxShape</span><span class="o">*</span><span class="w"> </span><span class="n">hitShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shape</span><span class="p">;</span>
<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Support for batched scene queries has been removed from the PhysX SDK and a replacement <a class="reference internal" href="../_api_build/classPxBatchQueryExt.html#_CPPv415PxBatchQueryExt" title="PxBatchQueryExt"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PxBatchQueryExt</span></code></a> has been added to the extensions layer. The replacement <em>PxBatchQueryExt</em> aims to replicate the core functionality of <em>PxBatchQuery</em>. The class <em>PxBatchQueryExt</em> wraps calls to <a class="reference internal" href="../_api_build/classPxScene.html#_CPPv4NK7PxScene7raycastERK6PxVec3RK6PxVec3K6PxRealR17PxRaycastCallback10PxHitFlagsRK17PxQueryFilterDataP21PxQueryFilterCallbackPK12PxQueryCache20PxGeometryQueryFlags" title="PxScene::raycast"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::raycast()</span></code></a>, <a class="reference internal" href="../_api_build/classPxScene.html#_CPPv4NK7PxScene5sweepERK10PxGeometryRK11PxTransformRK6PxVec3K6PxRealR15PxSweepCallback10PxHitFlagsRK17PxQueryFilterDataP21PxQueryFilterCallbackPK12PxQueryCacheK6PxReal20PxGeometryQueryFlags" title="PxScene::sweep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::sweep()</span></code></a> and <a class="reference internal" href="../_api_build/classPxScene.html#_CPPv4NK7PxScene7overlapERK10PxGeometryRK11PxTransformR17PxOverlapCallbackRK17PxQueryFilterDataP21PxQueryFilterCallbackPK12PxQueryCache20PxGeometryQueryFlags" title="PxScene::overlap"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxScene::overlap()</span></code></a> and consequently employs the same data types <em>PxRaycastBuffer/PxSweepBuffer/PxOverlapBuffer</em> and <em>PxRaycastHit/PxSweepHit/PxOverlapHit</em>.</p>
<p>The following table illustrates the structs, classes, callback and functions that need to be replaced to migrate from <em>PxBatchQuery</em> to <em>PxBatchQueryExt</em>:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>5.0</p></td>
<td><p>5.1</p></td>
</tr>
<tr class="row-even"><td><p>PxBatchQuery</p></td>
<td><p>PxBatchQueryExt</p></td>
</tr>
<tr class="row-odd"><td><p>PxRaycastQueryResult</p></td>
<td><p>PxRaycastBuffer</p></td>
</tr>
<tr class="row-even"><td><p>PxSweepQueryResult</p></td>
<td><p>PxSweepBuffer</p></td>
</tr>
<tr class="row-odd"><td><p>PxOverlapQueryResult</p></td>
<td><p>PxOverlapBuffer</p></td>
</tr>
<tr class="row-even"><td><p>PxBatchQueryPreFilterShader</p></td>
<td><p>PxQueryFilterCallback::preFilter()</p></td>
</tr>
<tr class="row-odd"><td><p>PxBatchQueryPostFilterShader</p></td>
<td><p>PxQueryFilterCallback::postFilter()</p></td>
</tr>
<tr class="row-even"><td><p>PxBatchQueryResult::queryStatus</p></td>
<td><p>PxBatchQueryStatus::getStatus()</p></td>
</tr>
<tr class="row-odd"><td><p>PxScene::createBatchQuery()</p></td>
<td><p>PxCreateBatchQueryExt()</p></td>
</tr>
</tbody>
</table>
</div>
<p>A <em>PxBatchQueryExt</em> instance is instantiated with a call to <a class="reference internal" href="../_api_build/function_PxSceneQueryExt_8h_1a793696c25094939ca56bb72b9faf10e1.html#_CPPv421PxCreateBatchQueryExtRK7PxSceneP21PxQueryFilterCallbackP15PxRaycastBufferK5PxU32P12PxRaycastHitK5PxU32P13PxSweepBufferK5PxU32P10PxSweepHitK5PxU32P15PxOverlapBufferK5PxU32P12PxOverlapHitK5PxU32" title="PxCreateBatchQueryExt"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxCreateBatchQueryExt()</span></code></a>. As an example, the following code will generate a batch query able to perform up to 2 raycast queries with a total of 4 touches, 6 sweep queries with a total of 8 touches, and 10 overlap queries with 12 overlap touches:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxBachQueryExt</span><span class="o">*</span><span class="w"> </span><span class="n">bq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateBatchQueryExt</span><span class="p">(</span><span class="n">getScene</span><span class="p">(),</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span>
</pre></div>
</div>
<p>An alternative is to provide the query and result buffers rather than ask <em>PxCreateBatchQueryExt</em> to allocate them:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxRaycastBuffer</span><span class="w"> </span><span class="n">raycasts</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">PxRaycastHit</span><span class="w"> </span><span class="n">raycastHits</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">PxSweepBuffer</span><span class="w"> </span><span class="n">sweeps</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">PxSweepHit</span><span class="w"> </span><span class="n">sweepHits</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">PxOvelapBuffer</span><span class="w"> </span><span class="n">overlaps</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">PxOverlapHit</span><span class="w"> </span><span class="n">overlapHits</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="n">PxBatchQueryExt</span><span class="o">*</span><span class="w"> </span><span class="n">bq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateBatchQueryExt</span><span class="p">(</span><span class="n">getScene</span><span class="p">(),</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">raycasts</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">raycastHits</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">sweeps</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">sweepHits</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">overlaps</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">overlapHits</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span>
</pre></div>
</div>
<p>Each query returns a pointer to a corresponding <em>PxRaycastBuffer/PxSweepBuffer/PxOverlapBuffer</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxRaycastBuffer</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bq</span><span class="o">-&gt;</span><span class="n">raycast</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">unitDir</span><span class="p">,</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>
</pre></div>
</div>
<p>If query and result buffers are supplied to <em>PxCreateBatchQueryExt()</em> then each pointer returned corresponds to an element in the provided result buffer. The third call to <a class="reference internal" href="../_api_build/classPxBatchQueryExt.html#_CPPv4N15PxBatchQueryExt5sweepERK10PxGeometryRK11PxTransformRK6PxVec3K6PxRealK5PxU1610PxHitFlagsRK17PxQueryFilterDataPK12PxQueryCacheK6PxReal" title="PxBatchQueryExt::sweep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxBatchQueryExt::sweep()</span></code></a>, for example, will return &amp;sweeps[2] in the example above.  A NULL pointer will be returned if the number of calls to a particular query exceeds the length of the allocated or provided buffer. For example, the 9th call to bq-&gt;sweep() will return a NULL ptr in the above example.</p>
<p>After calling <a class="reference internal" href="../_api_build/classPxBatchQueryExt.html#_CPPv4N15PxBatchQueryExt7executeEv" title="PxBatchQueryExt::execute"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxBatchQueryExt::execute()</span></code></a> it is possible to determine if any individual query was unable to return all requested touches. This can happen if the touch buffer, either allocated or provided, was too small for the batch. This situation is an overflow and can be determined by calling <a class="reference internal" href="../_api_build/structPxBatchQueryStatus.html#_CPPv4N18PxBatchQueryStatus9getStatusERK15PxRaycastBuffer" title="PxBatchQueryStatus::getStatus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PxBatchQueryStatus::getStatus()</span></code></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxBatchQueryStatus</span><span class="o">::</span><span class="n">Enum</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxBatchQueryStatus</span><span class="o">::</span><span class="n">getStatus</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">overflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PxBatchQueryStatus</span><span class="o">::</span><span class="n">eOVERFLOW</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="pxbvhstructure">
<h2>PxBVHStructure<a class="headerlink" href="#pxbvhstructure" title="Link to this heading">#</a></h2>
<p>PxBVHStructure has been renamed to PxBVH. PxBVHStructureDesc has been renamed to PxBVHDesc. PxCooking::cookBVHStructure() is deprecated. Please use PxCooking::cookBVH() now.</p>
<p>The PxBVHStructure scene query functions have changed. The old API is deprecated:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">PxU32</span><span class="w">   </span><span class="nf">raycast</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unitDir</span><span class="p">,</span><span class="w"> </span><span class="n">PxReal</span><span class="w"> </span><span class="n">maxDist</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="w"> </span><span class="n">maxHits</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="o">*</span><span class="w"> </span><span class="n">PX_RESTRICT</span><span class="w"> </span><span class="n">rayHits</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="n">PxU32</span><span class="w">   </span><span class="nf">sweep</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxBounds3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">aabb</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unitDir</span><span class="p">,</span><span class="w"> </span><span class="n">PxReal</span><span class="w"> </span><span class="n">maxDist</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="w"> </span><span class="n">maxHits</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="o">*</span><span class="w"> </span><span class="n">PX_RESTRICT</span><span class="w"> </span><span class="n">sweepHits</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="n">PxU32</span><span class="w">   </span><span class="nf">overlap</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxBounds3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">aabb</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="w"> </span><span class="n">maxHits</span><span class="p">,</span><span class="w"> </span><span class="n">PxU32</span><span class="o">*</span><span class="w"> </span><span class="n">PX_RESTRICT</span><span class="w"> </span><span class="n">overlapHits</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>A new API has been added:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w">    </span><span class="nf">raycast</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unitDir</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">RaycastCallback</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cb</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w">    </span><span class="nf">sweep</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxGeometry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pose</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxVec3</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unitDir</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">RaycastCallback</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cb</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w">    </span><span class="nf">overlap</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PxGeometry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PxTransform</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pose</span><span class="p">,</span><span class="w"> </span><span class="n">OverlapCallback</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cb</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>It is recommended to switch to the new API.</p>
</section>
<section id="gpu-rigid-bodies">
<h2>GPU Rigid Bodies<a class="headerlink" href="#gpu-rigid-bodies" title="Link to this heading">#</a></h2>
<p>Configuring GPU memory usage has been overhauled and simplified in PhysX 5.1. There are not direct 1:1 replacements for all previous configurable properties, as some buffer sizes are now derived either at runtime or from other configurable properties. Previous buffer sizes were defined in terms of bytes, whereas replacements are defined in terms of the number of elements.</p>
<p>PxgDynamicsMemoryConfig::constraintBufferCapacity was removed. No equivalent replacement is provided. Buffer sizes controlled by this parameter are now computed dynamically.
PxgDynamicsMemoryConfig::contactBufferCapacity and PxgDynamicsMemoryConfig::contactStreamSize have been removed. Instead, the user can adjust maxRigidContactCount to define the maximum number of contacts the simulation can accept.
PxgDynamicsMemoryConfig::patchStreamSize has been removed. Instead, the user can adjust maxRigidPatchCount to define the maximum number of contact patches the simulation can accept.
PxgDynamicsMemoryConfig::forceStreamCapacity has been removed. No equivalent replacement is provided as this can be derived from maxRigidContactCount.
PxgDynamicsMemoryConfig::foundLostAggregatePairs and totalAggregatePairs fields were added. These control the maximum number of found/lost pairs that can be produced in a single frame and the maximum number of supported aggregate pairs respectively.</p>
</section>
<section id="character-controller">
<h2>Character controller<a class="headerlink" href="#character-controller" title="Link to this heading">#</a></h2>
<p>The ObstacleHandle typedef has been renamed PxObstacleHandle. The INVALID_OBSTACLE_HANDLE define has been renamed PX_INVALID_OBSTACLE_HANDLE.</p>
</section>
<section id="vehicles">
<h2>Vehicles<a class="headerlink" href="#vehicles" title="Link to this heading">#</a></h2>
<p>The Vehicle SDK has been deprecated and replaced with a new SDK with similar functionality but significantly different API. Many of the vehicle parameters, states and functions of the old Vehicle SDK are present in the new SDK albeit in a new form.  A mapping between the two shall now be presented.</p>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Link to this heading">#</a></h3>
<p>The data structures used to specify a vehicle and its simulation are quite different in 5.1. These changes shall now be presented.</p>
<section id="engine">
<h4>Engine<a class="headerlink" href="#engine" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of engine parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleEngineData::mMOI</p></td>
<td><p>PxVehicleEngineParams::moi</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleEngineData::eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES</p></td>
<td><p>PxVehicleEngineParams::eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleEngineData::mTorqueCurve</p></td>
<td><p>PxVehicleEngineParams::torqueCurve</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleEngineData::mPeakTorque</p></td>
<td><p>PxVehicleEngineParams::peakTorque</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleEngineData::mMaxOmega</p></td>
<td><p>PxVehicleEngineParams::maxOmega</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleEngineData::mDampingRateFullThrottle</p></td>
<td><p>PxVehicleEngineParams::dampingRateFullThrottle</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleEngineData::mDampingRateZeroThrottleClutchEngaged</p></td>
<td><p>PxVehicleEngineParams::dampingRateZeroThrottleClutchEngaged</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleEngineData::mDampingRateZeroThrottleClutchDisengaged</p></td>
<td><p>PxVehicleEngineParams::dampingRateZeroThrottleClutchDisengaged</p></td>
</tr>
</tbody>
</table>
</div>
<p>The PxVehicleEngineParams struct has a new parameter PxVehicleEngineParams::idleOmega, which governs the minimum rotation speed of the engine.  A value of 0.0  will replicate the behavior of the legacy Vehicle SDK.</p>
</section>
<section id="gearbox">
<h4>Gearbox<a class="headerlink" href="#gearbox" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of gearbox parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleGearsData::mRatios</p></td>
<td><p>PxVehicleGearboxParams::ratios</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleGearsData::mFinalRatio</p></td>
<td><p>PxVehicleGearboxParams::finalRatio</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleGearsData::mNbRatios</p></td>
<td><p>PxVehicleGearboxParams::nbRatios</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleGearsData::mSwitchTime</p></td>
<td><p>PxVehicleGearboxParams::switchTime</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleGearsData::Enum</p></td>
<td><p>Removed</p></td>
</tr>
</tbody>
</table>
</div>
<p>The enumerated list of gears specified by PxVehicleGearsData::Enum does not have an equivalent in 5.1. A related change is the addition of a new parameter PxVehicleGearboxParams::neutralGear.  The original hard-coded enumerated list limited gearing to a single reverse gear.  Removing the enumerated list and adding a neutral gear specifier allows any number of reverse gears to be modelled.  To replicate legacy behavior with a single reverse gear, set PxVehicleGearboxParams::neutralGear to 1. With this configuration, gear 0 is the reverse gear, gear 1 is neutral gear and all other gears are forward gears. A general rule is that if there are N reverse gears then PxVehicleGearboxParams::neutralGear should be set to N.</p>
</section>
<section id="autobox">
<h4>Autobox<a class="headerlink" href="#autobox" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of autobox parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleAutoBoxData::mUpRatios</p></td>
<td><p>PxVehicleAutoboxParams::upRatios</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleAutoBoxData::mDownRatios</p></td>
<td><p>PxVehicleAutoboxParams::downRatios</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleAutoBoxData::setLatency()</p></td>
<td><p>PxVehicleAutoboxParams::latency</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleAutoBoxData::getLatency()</p></td>
<td><p>PxVehicleAutoboxParams::latency</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="n-wheel-drive-differential">
<h4>N-Wheel Drive Differential<a class="headerlink" href="#n-wheel-drive-differential" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of N-wheel differential parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDifferentialNWData::setDrivenWheel()</p></td>
<td><p>PxVehicleMultiWheelDriveDifferentialParams::isConnected</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDifferentialNWData::getIsDrivenWheel()</p></td>
<td><p>PxVehicleMultiWheelDriveDifferentialParams::isConnected</p></td>
</tr>
</tbody>
</table>
</div>
<p>The class PxVehicleDifferentialNWData permitted only an equal split of torque between all wheels connected to the differential.  It also weighted each connected wheel equally when computing the contribution of each wheel’s rotational speed to the rotational speed at the wheel-side clutch plate. This has been generalised to allow any conservative split of torque between the wheels connected to the differential. It has been further generalised to allow any weighting of each connected wheel to the rotational speed at the wheel-side clutch plate. The array PxVehicleMultiWheelDriveDifferentialParams::torqueRatios may be used to specify the fraction of torque to be delivered by the differential to each wheel. Further, the array PxVehicleMultiWheelDriveDifferentialParams::aveWheelSpeedRatios specifies the contribution of each wheels’s rotational speed to the rotational speed of the wheel-side clutch plate.  To replicate the behaviour of the old  Vehicle SDK, set each connected wheel’s entry in the arrays PxVehicleMultiWheelDriveDifferentialParams::torqueRatios and PxVehicleMultiWheelDriveDifferentialParams::aveWheelSpeedRatios to be 1/N with N denoting the number of wheels connected to the differential.</p>
</section>
<section id="four-wheel-drive-differential">
<h4>Four-Wheel Drive Differential<a class="headerlink" href="#four-wheel-drive-differential" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of four-wheel drive differential parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDifferential4WData::mFrontRearSplit</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::frontRearSplit</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDifferential4WData::mFrontLeftRightSplit</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::frontNegPosSplit</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDifferential4WData::mRearLeftRightSplit</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::rearNegPosSplit</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDifferential4WData::mCentreBias</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::centerBias</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDifferential4WData::mFrontBias</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::frontBias</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDifferential4WData::mRearBias</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::rearBias</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDifferential4WData::mType</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::type</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDifferential4WData::Enum</p></td>
<td><p>PxVehicleFourWheelDriveDifferentialParams::Enum</p></td>
</tr>
</tbody>
</table>
</div>
<p>The parameters PxVehicleDifferential4WData::mFrontLeftRightSplit and PxVehicleDifferential4WData::mRearLeftRightSplit have been renamed as PxVehicleFourWheelDriveDifferentialParams::frontNegPosSplit and PxVehicleFourWheelDriveDifferentialParams::rearNegPosSplit.  Terms such as “left” and “right are ambiguous in PhysX, which has no specific handedness.  Meanwhile, terms such as “neg”and “pos”, denoting negative and positive on the lateral axis, are more precise.</p>
<p>The enumerated list PxVehicleDifferential4WData::Enum has been replaced with a shorter list in 5.1.  In particular, the entries relating to open differential types have been removed.  These are PxVehicleDifferential4WData::eDIFF_TYPE_OPEN_4WD, PxVehicleDifferential4WData::eDIFF_TYPE_OPEN_FRONTWD and PxVehicleDifferential4WData::eDIFF_TYPE_OPEN_REARWD.  The functionality of these differential types may be replicated by using PxVehicleMultiWheelDriveDifferentialParams and configuring the torque split fractions per wheel (PxVehicleMultiWheelDriveDifferentialParams::torqueRatios and PxVehicleMultiWheelDriveDifferentialParams::aveWheelSpeedRatios) to match the torque split specified by the combinations of PxVehicleDifferential4WData::mFrontRearSplit, PxVehicleDifferential4WData::mFrontLeftRightSplit and PxVehicleDifferential4WData::mRearLeftRightSplit.</p>
<p>The wheel indexing in the old Vehicle SDK had a strict ordering that defined the four wheels connected to the differential in terms of left/right, front/forward.  There is no hard-coded indexing in the new Vehicle SDK.  The four wheels that participate in the four-wheel drive differential must therefore now be specified using the 2-element arrays PxVehicleFourWheelDriveDifferentialParams::frontWheelIds and PxVehicleFourWheelDriveDifferentialParams::rearWheelIds.</p>
</section>
<section id="clutch">
<h4>Clutch<a class="headerlink" href="#clutch" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of clutch parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleClutchAccuracyMode::Enum</p></td>
<td><p>PxVehicleClutchAccuracyMode::Enum</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleClutchData::mAccuracyMode</p></td>
<td><p>PxVehicleClutchParams::accuracyMode</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleClutchData::mEstimateIterations</p></td>
<td><p>PxVehicleClutchParams::estimateIterations</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleClutchData::mStrength</p></td>
<td><p>PxVehicleClutchCommandResponseParams::maxResponse</p></td>
</tr>
</tbody>
</table>
</div>
<p>The applied clutch strength is now modelled using a normalised clutch pedal input in conjunction with a specified clutch pedal response. The parameter PxVehicleClutchCommandResponseParams::maxResponse is the clutch response that occurs when the clutch pedal is fully depressed; that is, when the two plates at the clutch are pressed together.  The product of normalised clutch pedal input and maximum clutch response generates an instantaneous clutch strength to be used at each simulation step.  When the clutch pedal is fully depressed, PxVehicleClutchCommandResponseParams::maxResponse is the exact equivalent of PxVehicleClutchData::mStrength.  The difference in the new Vehicle SDK is that the applied clutch strength may be more readily modulated with a clutch pedal input.  This was only possible in the old Vehicle SDK by repeatedly updating PxVehicleClutchData::mStrength to simulate the effect of the clutch pedal on the applied clutch strength.</p>
</section>
<section id="ackermann-correction">
<h4>Ackermann Correction<a class="headerlink" href="#ackermann-correction" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of Ackermann correction parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleAckermannGeometryData::mAccuracy</p></td>
<td><p>PxVehicleAckermannCorrection::strength</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleAckermannGeometryData::mFrontWidth</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleAckermannGeometryData::mRearWidth</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleAckermannGeometryData::mAxleSeparation</p></td>
<td><p>PxVehicleAckermannCorrection::wheelBase</p></td>
</tr>
</tbody>
</table>
</div>
<p>The old Vehicle SDK used a hard-coded indexing system to identify the wheels in terms of front/rear and left/right. Moreover, the Ackermann correction was applied to the front wheels and to the rear wheels. For this reason, PxVehicleAckermannGeometryData required a front axle width and a rear axle width to be specified.  Both front and rear correction shared the same correction strength, as specified by PxVehicleAckermannGeometryData::mAccuracy. Furthermore, PxVehicleAckermannGeometryData::mAxleSeparation applied equally to both front and rear axle corrections. In most cases, the rear wheels did not accept a steer angle and the Ackermann correction would only affect the front wheels.</p>
<p>The new Vehicle SDK has further generalised Ackermann correction so that it is now specified as an array of individual corrections to be applied.  Given the absence of hard-coded wheel indexing, each Ackermann correction requires the affected wheels and their axle to be specified using the 2-element array PxVehicleAckermannCorrection::wheelIds and the parameter PxVehicleAckermannCorrection::axleId.  Each correction is applied to only a single axle so there is only a need to specify the track width of the affected axle for each Ackermann correction.  This is achieved using the PxVehicleAckermannCorrection::trackWidth parameter. For front axle correction, PxVehicleAckermannCorrection::trackWidth plays the same role as PxVehicleAckermannGeometryData::mFrontWidth.  Similarly, for rear axle correction,   PxVehicleAckermannCorrection::trackWidth plays the same role as PxVehicleAckermannGeometryData::mRearWidth.</p>
<p>In most cases, only a single PxVehicleAckermannCorrection is required to replicate the behavior of the old Vehicle SDK.  To replicate the situation where front and rear wheels are noticeably corrected, it is necessary to use two PxVehicleAckermannCorrection instances: one instance for each axle to be affected by Ackermann correction. The struct PxVehicleAckermannParams has been introduced as a container for multiple PxVehicleAckermannCorrection instances.</p>
<p>It is important to note that PxVehicleAckermannCorrection::wheelBase is the distance between the axle being corrected and any reference axle. In most cases, this will be the distance between front and rear axles but this is not a strict rule:  correction may be applied to any axle using any other axle as a reference.</p>
</section>
<section id="wheels">
<h4>Wheels<a class="headerlink" href="#wheels" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of wheel parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelData::mRadius</p></td>
<td><p>PxVehicleWheelParams::radius</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelData::mWidth</p></td>
<td><p>PxVehicleWheelParams::halfWidth</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelData::mMass</p></td>
<td><p>PxVehicleWheelParams::mass</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelData::mMOI</p></td>
<td><p>PxVehicleWheelParams::moi</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelData::mDampingRate</p></td>
<td><p>PxVehicleWheelParams::dampingRate</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelData::mMaxBrakeTorque</p></td>
<td><p>PxVehicleBrakeCommandResponseParams::maxResponse</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelData::mMaxHandBrakeTorque</p></td>
<td><p>PxVehicleBrakeCommandResponseParams::maxResponse</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelData::mMaxSteer</p></td>
<td><p>PxVehicleSteerCommandResponseParams::maxResponse</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelData::mToeAngle</p></td>
<td><p>PxVehicleSuspensionComplianceParams::wheelToeAngle</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelsSimData::setWheelCentreOffset()</p></td>
<td><p>PxVehicleSuspensionParams::suspensionAttachment</p></td>
</tr>
</tbody>
</table>
</div>
<p>It is worth noting that PxVehicleWheelData::mWidth has been replaced with PxVehicleWheelParams::halfWidth.  A wheel with PxVehicleWheelData::mWidth of value 1.0 should now be represented using a wheel with PxVehicleWheelParams::halfWidth of value 0.5.</p>
<p>The old Vehicle SDK assumed a linear relationship between pedal and response. For example, a brake pedal value of 0.5 generated a brake torque of 0.5*PxVehicleWheelData::mMaxBrakeTorque.  This was true for the per-wheel brake, handbrake and pre-Ackermann corrected steer values. This relationship has been generalised in order to provide the flexibility to implement non-linear responses to controller inputs.  Data structures such as PxVehicleBrakeCommandResponseParams specify the per-wheel maximum response that occurs when the brake pedal has value 1.0.  It’s important to note that this does not make any assumptions about brake torques or steer angles having a linear relationship with brake pedal or steering wheel. The pipeline of the new Vehicle SDK converts the per-wheel maximum responses specified by constant parameters to per-wheel maximum responses stored as volatile state data representing torques and steer angles to apply to wheels.  This conversion may implement a linear or non-linear response to control input.</p>
<p>The old Vehicle SDK assumed a constant toe angle. The toe angle, however, is a function of suspension compression and is far from constant. With this in mind, a suspension compliance system has been introduced. The compliance system allows properties such as toe and camber angle to be specified as graphs with normalised suspension compression serving as the x-axis of each graph.  Currently, a maximum of 3 graph points is permitted for each value affected by suspension compliance. This allows, for example, toe to be specified at maximum droop (x=0.0), half-way in-between maximum droop and maximum compression (x=0.5), and at maximum compression (x=1.0).  Alternatively, a single graph point will generate a constant toe angle, while a graph with zero graph points will generate a toe angle of 0.0.  The parameter PxVehicleSuspensionComplianceParams::wheelToeAngle stores the graph of toe angle as a function of suspension compression.  It is worth noting that PxVehicleSuspensionComplianceParams::wheelToeAngle defaults to an empty graph; that is, a constant toe angle of 0.0.</p>
<p>The old Vehicle SDK allowed a reference pose to be specified for each wheel. This reference pose dictated the pose adopted by the vehicle at rest with all wheels contacting a flat plane.  The reference pose was typically chosen to be the pose that was the equilibrium state of the suspension; that is, the suspension compression that generated forces to equally balance the gravitational force on the sprung mass.  This, however, was not a strict requirement. The reference pose in the new Vehicle SDK is specified by PxVehicleSuspensionParams::suspensionAttachment. This pose does not automatically dictate the pose adopted by the vehicle at rest. Instead, the reference pose now describes the pose of the wheel at the maximum suspension compression state. Furthermore, the equilibrium pose of the wheel on a flat plane is governed by the algorithm chosen to compute the suspension force.</p>
</section>
<section id="tire-load-filter">
<h4>Tire Load Filter<a class="headerlink" href="#tire-load-filter" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of tire load filter parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleTireLoadFilterData::mMinNormalisedLoad</p></td>
<td><p>PxVehicleTireForceParams::loadFilter[0][0]</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleTireLoadFilterData::mMinFilteredNormalisedLoad</p></td>
<td><p>PxVehicleTireForceParams::loadFilter[0][1]</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleTireLoadFilterData::mMaxNormalisedLoad</p></td>
<td><p>PxVehicleTireForceParams::loadFilter[1][0]</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleTireLoadFilterData::mMaxFilteredNormalisedLoad</p></td>
<td><p>PxVehicleTireForceParams::loadFilter[1][1]</p></td>
</tr>
</tbody>
</table>
</div>
<p>The old Vehicle SDK specified a single tire load filter instance per vehicle.  This has been generalised to a per-wheel tire load filter.</p>
</section>
<section id="tire">
<h4>Tire<a class="headerlink" href="#tire" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of tire parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleTireData::mLatStiffX</p></td>
<td><p>PxVehicleTireForceParams::latStiffX</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleTireData::mLatStiffY</p></td>
<td><p>PxVehicleTireForceParams::latStiffY</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleTireData::mLongitudinalStiffnessPerUnitGravity</p></td>
<td><p>PxVehicleTireForceParams::longStiff</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleTireData::mCamberStiffnessPerUnitGravity</p></td>
<td><p>PxVehicleTireForceParams::camberStiff</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleTireData::mFrictionVsSlipGraph</p></td>
<td><p>PxVehicleTireForceParams::frictionVsSlip</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleTireData::mType</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelsSimData::setTireForceAppPointOffset()</p></td>
<td><p>PxVehicleSuspensionComplianceParams::tireForceAppPointLongitudinal
PxVehicleSuspensionComplianceParams::tireForceAppPointLateral
PxVehicleSuspensionComplianceParams::tireForceAppPointVertical</p></td>
</tr>
</tbody>
</table>
</div>
<p>The first thing to note is that PxVehicleTireData::mLatStiffX and PxVehicleTireForceParams::latStiffX have identical meaning. Values from the old SDK may be directly applied to 5.1.  The same is true for PxVehicleTireData::mFrictionVsSlipGraph and PxVehicleTireForceParams::frictionVsSlip.</p>
<p>PxVehicleTireForceParams::latStiffY performs the same role as PxVehicleTireData::mLatStiffY but is now the stiffness per radian rather than a normalised stiffness per radian. A simple formula describes the conversion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleTireForceParams</span><span class="o">::</span><span class="n">latStiffY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxVehicleTireData</span><span class="o">::</span><span class="n">mLatStiffY</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">PxVehicleWheelData</span><span class="o">::</span><span class="n">mMass</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PxVehicleSuspensionData</span><span class="o">::</span><span class="n">mSprungMass</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w">  </span><span class="o">|</span><span class="n">gravitationalAcceleration</span><span class="o">|</span>
</pre></div>
</div>
<p>PxVehicleTireForceParams::longStiff and PxVehicleTireData::mLongitudinalStiffnessPerUnitGravity perform the same role but are expressed in different units. A simple formula describes the conversion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleTireForceParams</span><span class="o">::</span><span class="n">longStiff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxVehicleTireData</span><span class="o">::</span><span class="n">mLongitudinalStiffnessPerUnitGravity</span><span class="o">*|</span><span class="n">gravitationalAcceleration</span><span class="o">|</span>
</pre></div>
</div>
<p>PxVehicleTireForceParams::camberStiff and PxVehicleTireData::mCamberStiffnessPerUnitGravity perform the same role but are expressed in different units. Furthermore, the old Vehicle SDK expected camber stiffness to be a negative value, while the new Vehicle SDK expects camber stiffness to be a positive value. A simple formula describes the conversion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleTireForceParams</span><span class="o">::</span><span class="n">camberStiff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">PxVehicleTireData</span><span class="o">::</span><span class="n">mCamberStiffnessPerUnitGravity</span><span class="o">*|</span><span class="n">gravitationalAcceleration</span><span class="o">|</span>
</pre></div>
</div>
<p>PxVehicleTireData::mType has been removed. This parameter played a role in the computation of tire friction. The new Vehicle SDK introduces a simpler and more flexible system to determine tire friction.</p>
<p>The tire force application point in the old Vehicle SDK was set using the function PxVehicleWheelsSimData::setTireForceAppPointOffset(). This function specified a position in the rigid body frame. The application point, however, ought to be a function of suspension state. With this in mind, a compliance system has been introduced in the new Vehicle SDK. The compliance system allows properties such as tire force application point to be specified as graphs with normalised suspension compression serving as the x-axis of each graph. Currently, a maximum of 3 graph points is permitted for each value affected by suspension compliance. This allows, for example, a lateral force offset to be specified at maximum droop (x=0.0), half-way in-between maximum droop and maximum compression (x=0.5), and at maximum compression (x=1.0). Alternatively, a single graph point will generate a constant offset, while a graph with zero graph points will generate an offset of 0.0. The parameters PxVehicleSuspensionComplianceParams::tireForceAppPointLongitudinal, PxVehicleSuspensionComplianceParams::tireForceAppPointLateral and PxVehicleSuspensionComplianceParams::tireForceAppPointVertical collectively describe the (x,y,z) offsets in the suspension frame with the suspension frame  specified by PxVehicleSuspensionParams::suspensionAttachment.</p>
<p>The tire force application point may be configured to produce legacy behavior. The first step is to configure the three relevant graphs with a single graph point.  This will generate a constant offset in the suspension frame that is independent of the suspension compression state. If the offset in the suspension frame is V, the suspension frame is W and PxVehicleWheelsSimData::setTireForceAppPointOffset() has value X then we have the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">W</span><span class="p">.</span><span class="n">getInverse</span><span class="p">()</span><span class="o">*</span><span class="n">X</span>
</pre></div>
</div>
<p>With knowledge of V it is straightforward to apply each component of the 3-vector to PxVehicleSuspensionComplianceParams::tireForceAppPointLongitudinal, PxVehicleSuspensionComplianceParams::tireForceAppPointLateral and PxVehicleSuspensionComplianceParams::tireForceAppPointVertical.</p>
</section>
<section id="tire-contact-friction">
<span id="id1"></span><h4>Tire Contact Friction<a class="headerlink" href="#tire-contact-friction" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK computed tire contact friction using a lookup table that contained a unique entry for each combination of two integers that represented the tire type and surface material type. The tire type was specified by PxVehicleTireData::mType. The material type was computed using a lookup table that mapped PxMaterial instances to an integer material type. The class PxVehicleDrivableSurfaceToTireFrictionPairs maintained the mapping between PxMaterial instance and integer material type. It also maintained the lookup table for each combination of tire and surface material type. This class has been removed.</p>
<p>The new Vehicle SDK uses a per wheel contact friction value stored in PxVehicleRoadGeometryState::friction. The value stored in the state PxVehicleRoadGeometryState::friction will be consumed by the tire force computation. It is worth noting that the new Vehicle SDK is independent of the subsystem used to determine the value of PxVehicleRoadGeometryState::friction. The only requirement here is that PxVehicleRoadGeometryState::friction has a value that represents the desired contact friction. This being the case, the friction value will be forwarded to the tire force computation, which will consume the friction in order to compute tire forces.</p>
<p>The new Vehicle SDK introduces a friction subsystem that has some similarities with PxVehicleDrivableSurfaceToTireFrictionPairs. The data structure PxVehiclePhysXMaterialFrictionParams maintains a list of direct mappings between PxMaterial instance and friction. It also specifies a default friction to use in the event that the PxMaterial instance under the wheel is not present in the list of mappings. The default friction is specified by PxVehiclePhysXMaterialFrictionParams::defaultFriction.</p>
<p>The class PxVehiclePhysXMaterialFrictionParams is designed to be used in conjunction with scene queries against a PxScene instance. The entire subsystem of scene queries and contact friction calculation is wrapped in the component PxVehiclePhysXRoadGeometrySceneQueryComponent.</p>
</section>
<section id="suspension">
<h4>Suspension<a class="headerlink" href="#suspension" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of suspension parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleSuspensionData::mSpringStrength</p></td>
<td><p>PxVehicleSuspensionForceParams::stiffness</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleSuspensionData::mSpringDamperRate</p></td>
<td><p>PxVehicleSuspensionForceParams::damping</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleSuspensionData::mSprungMass</p></td>
<td><p>PxVehicleSuspensionForceParams::sprungMass</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleSuspensionData::mMaxCompression</p></td>
<td><p>PxVehicleSuspensionParams::suspensionTravelDist</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleSuspensionData::mMaxDroop</p></td>
<td><p>PxVehicleSuspensionParams::suspensionTravelDist</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleSuspensionData::mCamberAtRest</p></td>
<td><p>PxVehicleSuspensionComplianceParams::wheelCamberAngle</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleSuspensionData::mCamberAtMaxCompression</p></td>
<td><p>PxVehicleSuspensionComplianceParams::wheelCamberAngle</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleSuspensionData::mCamberAtMaxDroop</p></td>
<td><p>PxVehicleSuspensionComplianceParams::wheelCamberAngle</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelsSimData::setSuspTravelDirection()</p></td>
<td><p>PxVehicleSuspensionParams::suspensionTravelDir</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelsSimData::setSuspForceAppPointOffset()</p></td>
<td><p>PxVehicleSuspensionComplianceParams::suspForceAppPointLongitudinal
PxVehicleSuspensionComplianceParams::suspForceAppPointLateral
PxVehicleSuspensionComplianceParams::suspForceAppPointVertical</p></td>
</tr>
</tbody>
</table>
</div>
<p>PxVehicleSuspensionData::mMaxCompression and PxVehicleSuspensionData::mMaxDroop have been replaced by a single parameter PxVehicleSuspensionParams::suspensionTravelDist.  PxVehicleSuspensionData::mMaxCompression and PxVehicleSuspensionData::mMaxDroop described the maximum spring compression and elongation from a reference spring pose that was typically taken to be the rest pose of the spring; that is, the spring compression that generated a spring force that balanced the gravitational force acting on the sprung mass.  The new Vehicle SDK uses a different reference pose.  Instead of using the spring’s rest pose, the new reference pose is taken to be the pose at maximum spring compression. The spring can only move in one direction from this reference pose. As a consequence, only a single travel limit needs to be specified. This travel limit is specified by the parameter PxVehicleSuspensionParams::suspensionTravelDist. A simple formula governs the relationship between PxVehicleSuspensionData::mMaxDroop, PxVehicleSuspensionData::mMaxCompression and  PxVehicleSuspensionParams::suspensionTravelDist:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleSuspensionParams</span><span class="o">::</span><span class="n">suspensionTravelDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxVehicleSuspensionData</span><span class="o">::</span><span class="n">mMaxDroop</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PxVehicleSuspensionData</span><span class="o">::</span><span class="n">mMaxCompression</span>
</pre></div>
</div>
<p>The parameters governing the camber angle have been replaced with a more generic suspension compliance system. The compliance system allows properties such as toe and camber angle to be specified as graphs with normalised suspension compression serving as the x-axis of each graph. Currently, a maximum of 3 graph points is permitted for each value affected by suspension compliance. This allows, for example, camber to be specified at maximum droop (x=0.0), half-way in-between maximum droop and maximum compression (x=0.5), and at maximum compression (x=1.0). Alternatively, a single graph point will generate a constant camber angle, while a graph with zero graph points will generate a camber angle of 0.0. It is worth noting that PxVehicleSuspensionComplianceParams::wheelCamberAngle defaults to an empty graph; that is, a constant camber angle of 0.0.</p>
<p>The suspension force application point in the old Vehicle SDK was set using the function PxVehicleWheelsSimData::setSuspForceAppPointOffset(). This function specified a position in the rigid body frame. The application point, however, ought to be a function of suspension state. With this in mind, a compliance systsem has been introduced in the new Vehicle SDK. The compliance system allows properties such as suspension force application point to be specified as graphs with normalised suspension compression serving as the x-axis of each graph. Currently, a maximum of 3 graph points is permitted for each value affected by suspension compliance. This allows, for example, a lateral force offset to be specified at maximum droop (x=0.0), half-way in-between maximum droop and maximum compression (x=0.5), and at maximum compression (x=1.0). Alternatively, a single graph point will generate a constant lateral offset, while a graph with zero graph points will generate an offset of 0.0. The parameters PxVehicleSuspensionComplianceParams::suspForceAppPointLongitudinal, PxVehicleSuspensionComplianceParams::suspForceAppPointLateral and PxVehicleSuspensionComplianceParams::suspForceAppPointVertical collectively describe the (x,y,z) offsets in the suspension frame with the suspension frame specified by PxVehicleSuspensionParams::suspensionAttachment.</p>
<p>The suspension force application point may be configured to produce legacy behavior. The first step is to configure the three relevant graphs with a single graph point. This will generate a constant offset in the suspension frame that is independent of the suspension compression state. If the offset in the suspension frame is V, the suspension frame is W and PxVehicleWheelsSimData::setSuspForceAppPointOffset() has value X then we have the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">W</span><span class="p">.</span><span class="n">getInverse</span><span class="p">()</span><span class="o">*</span><span class="n">X</span>
</pre></div>
</div>
<p>With knowledge of V it is straightforward to apply each component of the 3-vector to PxVehicleSuspensionComplianceParams::suspForceAppPointLongitudinal, PxVehicleSuspensionComplianceParams::suspForceAppPointLateral and PxVehicleSuspensionComplianceParams::suspForceAppPointVertical.</p>
<p>The new Vehicle SDK introduces a new parameter PxVehicleSuspensionParams::wheelAttachment.  This parameter allows the wheel to be in a frame that is the child of the suspension frame. Legacy behavior may be replicated by setting PxVehicleSuspensionParams::wheelAttachment to the identity transform.</p>
</section>
<section id="anti-roll-bars">
<h4>Anti-Roll Bars<a class="headerlink" href="#anti-roll-bars" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of anti-roll parameters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleAntiRollBarData::mWheel0</p></td>
<td><p>PxVehicleAntiRollBar::wheel0</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleAntiRollBarData::mWheel1</p></td>
<td><p>PxVehicleAntiRollBar::wheel1</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleAntiRollBarData::mStiffness</p></td>
<td><p>PxVehicleAntiRollBar::stiffness</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelsSimData::addAntiRollBarData()</p></td>
<td><p>PxVehicleAntiRollForceParams::nbAntiRolls</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="telemetry">
<h4>Telemetry<a class="headerlink" href="#telemetry" title="Link to this heading">#</a></h4>
<p>Telemetry is not supported in the new Vehicle SDK. The class PxVehicleTelemetryData, associated classes, and the function PxVehicleUpdateSingleVehicleAndStoreTelemetryData have all been removed.</p>
</section>
<section id="longitudinal-slip-parameters">
<h4>Longitudinal Slip Parameters<a class="headerlink" href="#longitudinal-slip-parameters" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK had the function PxVehicleWheelsSimData::setMinLongSlipDenominator().  The  equivalent in the new Vehicle SDK is the parameter PxVehicleTireSlipParams::minPassiveLongSlipDenominator.</p>
</section>
</section>
<section id="simulation-state">
<h3>Simulation State<a class="headerlink" href="#simulation-state" title="Link to this heading">#</a></h3>
<p>The data structures used to record the state of a vehicle are quite different in 5.1. These changes shall now be presented.</p>
<section id="tertiary-properties">
<h4>Tertiary Properties<a class="headerlink" href="#tertiary-properties" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK maintained per wheel tertiary variables used internally in the vehicle update and stored in the struct PxWheelQueryResult.  The following table illustrates the corresponding mapping from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::suspLineStart</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::suspLineDir</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::suspLineLength</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::isInAir</p></td>
<td><p>!PxVehicleIsWheelOnGround()</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::tireContactActor</p></td>
<td><p>PxVehiclePhysXRoadGeometryQueryState::actor</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::tireContactShape</p></td>
<td><p>PxVehiclePhysXRoadGeometryQueryState::shape</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::tireSurfaceMaterial</p></td>
<td><p>PxVehiclePhysXRoadGeometryQueryState::material</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::tireSurfaceType</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::tireContactPoint</p></td>
<td><p>PxVehiclePhysXRoadGeometryQueryState::hitPosition</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::tireContactNormal</p></td>
<td><p>PxVehicleAntiRollForceParams::plane.n</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::tireFriction</p></td>
<td><p>PxVehicleRoadGeometryState::stiffness</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::suspJounce</p></td>
<td><p>PxVehicleSuspensionState::jounce</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::suspSpringForce</p></td>
<td><p>PxVehicleSuspensionForce::force</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::tireLongitudinalDir</p></td>
<td><p>PxVehicleTireDirectionState::directions[PxVehicleTireDirectionModes::eLONGITUDINAL]</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::tireLateralDir</p></td>
<td><p>PxVehicleTireDirectionState::directions[PxVehicleTireDirectionModes::eLATERAL]</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::longitudinalSlip</p></td>
<td><p>PxVehicleTireSlipState::slips[PxVehicleTireDirectionModes::eLONGITUDINAL]</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::lateralSlip</p></td>
<td><p>PxVehicleTireSlipState::slips[PxVehicleTireDirectionModes::eLATERAL]</p></td>
</tr>
<tr class="row-odd"><td><p>PxWheelQueryResult::steerAngle</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-even"><td><p>PxWheelQueryResult::localPose</p></td>
<td><p>PxVehicleWheelLocalPose::localPose</p></td>
</tr>
</tbody>
</table>
</div>
<p>The suspension start, direction and length were recorded in the state variables PxWheelQueryResult::suspLineStart, PxWheelQueryResult::suspLineDir and PxWheelQueryResult::suspLineLength.  These quantities are no longer  recorded in the new Vehicle SDK.  The helper functions PxComputeSuspensionRaycast() and PxComputeSuspensionSweep(), however, may be used to compute the equivalent properties.</p>
<p>The old Vehicle SDK had a helper function PxVehicleIsInAir() to determine if a vehicle had all wheels in the air. This function made use of the per-wheel state PxWheelQueryResult::isInAir.  The new Vehicle SDK has no direct equivalent of either PxVehicleIsInAir() or PxWheelQueryResult::isInAir.  Instead, a helper function PxVehicleIsWheelOnGround() is provided. A return value of false indicates that the wheel is in the air. It is a straightforward exercise to determine if no wheels are on the ground in order to implement the equivalent of PxVehicleIsInAir().</p>
<p>The property PxWheelQueryResult::tireSurfaceType has no equivalent in the new Vehicle SDK.  This is discussed in more detail in Section Section <a class="reference internal" href="#tire-contact-friction"><span class="std std-ref">Tire Contact Friction</span></a>.</p>
<p>The old Vehicle SDK allowed the suspension state to be queried with the parameter PxWheelQueryResult::suspJounce.  The equivalent in the new Vehicle SDK is the state variable PxVehicleSuspensionState::jounce.  It is important to note that jounce has a different meaning in the new Vehicle SDK.  A jounce of 0.0 now corresponds to a suspension in the fully elongated state, while a jounce with value PxVehicleSuspensionParams::suspensionTravelDist corresponds to a suspension in the fully compressed state.  As a consequence, jounce is now positive semi-definite.</p>
<p>The property PxWheelQueryResult::steerAngle has no equivalent in the new Vehicle SDK.  It may, however, be directly calculated using the following formula:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">steerAngle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">steerAngles</span><span class="p">[</span><span class="n">wheelId</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PxVehicleSuspensionComplianceState</span><span class="o">::</span><span class="n">toe</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="dynamic-state">
<h4>Dynamic State<a class="headerlink" href="#dynamic-state" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of dynamic state getters and setters from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelsDynData::setWheelRotationSpeed()</p></td>
<td><p>PxVehicleWheelRigidBody1dState::rotationSpeed</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelsDynData::getWheelRotationSpeed()</p></td>
<td><p>PxVehicleWheelRigidBody1dState::correctedRotationSpeed</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleWheelsDynData::setWheelRotationAngle()</p></td>
<td><p>PxVehicleWheelRigidBody1dState::rotationAngle</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleWheelsDynData::getWheelRotationAngle()</p></td>
<td><p>PxVehicleWheelRigidBody1dState::rotationAngle</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDriveDynData::getEngineRotationSpeed()</p></td>
<td><p>PxVehicleEngineState::rotationSpeed</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDriveDynData::setEngineRotationSpeed()</p></td>
<td><p>PxVehicleEngineState::rotationSpeed</p></td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Link to this heading">#</a></h3>
<section id="startup-and-shutdown">
<h4>Startup And Shutdown<a class="headerlink" href="#startup-and-shutdown" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of initialisation and shutdown functions from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxInitVehicleSDK()</p></td>
<td><p>PxInitVehicleExtension()</p></td>
</tr>
<tr class="row-odd"><td><p>PxCloseVehicleSDK()</p></td>
<td><p>PxCloseVehicleExtension()</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="id2">
<h4>Scene Queries<a class="headerlink" href="#id2" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK separated out scene queries and simulation step. Scene queries against a PxScene instance were performed using the functions PxVehicleSuspensionRaycast() and PxVehicleSuspensionSweeps().  These functions have been removed.</p>
<p>The new Vehicle SDK makes no requirement that scene queries are performed against a PxScene.  The only requirement is that a subsystem writes to the state variables PxVehicleRoadGeometryState::plane, PxVehicleRoadGeometryState::friction and PxVehicleRoadGeometryState::hitState. These three variables allow subsequent subsystems to conditionally consume the contact plane and friction.</p>
<p>The new Vehicle SDK introduces a subsystem that is similar to PxVehicleSuspensionRaycast() and PxVehicleSuspensionSweeps() in the sense that it performs scene queries against a PxScene instance. This is found in the component PxVehiclePhysXRoadGeometrySceneQueryComponent, which may be configured to perform either raycasts or sweeps.  More specifically, PxVehiclePhysXRoadGeometryQueryParams::roadGeometryQueryType is used to determine if scene queries should be implemented as sweeps or as raycasts.  Furthermore, PxVehiclePhysXRoadGeometryQueryType::filterData and PxVehiclePhysXRoadGeometryQueryType::filterCallback may be used to make choices about the types of geometry that serve as road geometry.</p>
</section>
<section id="vehicle-update">
<h4>Vehicle Update<a class="headerlink" href="#vehicle-update" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK separated out scene queries and simulation step. Moreover, the simulation step was separated into two steps: a mandatory call to PxVehicleUpdates() and an optional call to PxVehiclePostUpdates().  The purpose of PxVehicleUpdates() was to compute velocity changes to apply to the vehicle’s PxRigidDynamic actor. The purpose of PxVehiclePostUpdates(), on the other hand, was to apply the velocity changes to the vehicle’s PxRigidDynamic actor.  This deferral was important when simulating multiple vehicle instances across multiple threads because PhysX write operations have a tendency to serialize the computation due to the necessity of PhysX write locks. Both PxVehicleUpdates() and PxVehiclePostUpdates() have been removed.</p>
<p>The new Vehicle SDK more naturally separates out velocity calculation from velocity application. This is achieved using two components:  PxVehiclePhysXActorBeginComponent and PxVehiclePhysXActorEndComponent.  The component PxVehiclePhysXActorBeginComponent is designed to read poses and velocities from the PhysX actor. The vehicle simulation step begins with these poses and velocities and proceeds to update both using the suspension and tire forces that develop on the vehicle. The component PxVehiclePhysXActorEndComponent is designed to write velocities back to the PhysX actor so that the PxScene may forward integrate the vehicle’s PxRigidDynamic actor and manage any rigid body collisions that it may encounter.</p>
<p>The new Vehicle SDK performs vehicle simulation steps by sequentially updating customisable components in a customisable order, where each component represents a vehicle feature such as the suspension system or a rigid body or the drivetrain. As a consequence, there is no specific update function that plays the role of PxVehicleUpdates() or PxVehiclePostUpdates().  Instead, vehicles are forward integrated by updating the sequence of components using the function PxVehicleComponentSequence::update().  The nature of each update, however, depends on the sequence of components and the functions executed by those components.</p>
<p>If multiple vehicles are to be run on multiple threads, it is recommended to batch process all the PxVehiclePhysXActorBeginComponent instances at the beginning of the vehicle simulation step.  Similarly, all the PxVehiclePhysXActorEndComponent instances should be batch processed at the end of the vehicle simulation step. This serializes all PhysX read and write operations in a manner similar to PxVehiclePostUpdates(). The remaining component sequence for each vehicle is now focused exclusively on computing a velocity. These component sequences may be updated in parallel without the risk of PhysX read/write locks serializing the computation.</p>
</section>
<section id="update-mode">
<h4>Update Mode<a class="headerlink" href="#update-mode" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK had a function PxVehicleSetUpdateMode().  The effect of this function was to apply changes to the vehicle’s PxRigidDynamic actor as either a velocity change or an acceleration change. The equivalent choice is made in the new Vehicle SDK by setting PxVehiclePhysXSimulationContext::physxActorUpdateMode to either PxVehiclePhysXActorUpdateMode::eAPPLY_VELOCITY or PxVehiclePhysXActorUpdateMode::eAPPLY_ACCELERATION.</p>
</section>
<section id="wheel-shapes">
<h4>Wheel Shapes<a class="headerlink" href="#wheel-shapes" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK allowed a mapping to be made between the PxShape instance that represented the wheel and the wheel index used by the Vehicle SDK. This was implemented using the function PxVehicleWheelsSimData::setWheelShapeMapping(). The mapping set by PxVehicleWheelsSimData::setWheelShapeMapping() allowed the Vehicle SDK to update the PxShape instances that represented the wheels with the correct pose that reflected jounce, steer, camber etc.  The new Vehicle SDK stores the corresponding PxShape pointers in the array PxVehiclePhysXActor::wheelShapes with the ith element of the array storing the PxShape instance of the ith wheel.</p>
<p>It is worth noting that the old Vehicle SDK could only perform sweeps against the PxScene if a PxShape instance had been specified for each wheel. This is no longer the case.  Sweeps are now possible even if PxVehiclePhysXActor::wheelShapes contains only NULL pointers, provided that PxVehiclePhysXSimulationContext::physxUnitCylinderSweepMesh has been configured with a cylinder shape of unit radius and halfwidth.  The function PxVehicleUnitCylinderSweepMeshCreate() may be used to create the cylinder shape that will be swept against the PxScene:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehiclePhysXSimulationContext</span><span class="o">::</span><span class="n">physxUnitCylinderSweepMesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxVehicleUnitCylinderSweepMeshCreate</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="sprung-mass-computation">
<h4>Sprung Mass Computation<a class="headerlink" href="#sprung-mass-computation" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK had a helper function PxVehicleComputeSprungMasses(). The aim of this function was to compute sprung masses that match the centre of mass and mass of the vehicle’s rigid body. The new Vehicle SDK has a similar helper function with identical name. The primary difference between the two is that the function in the new Vehicle SDK requires the sprung mass coordinates to be specified in the rigid body frame rather than in the frame of the associated PhysX actor. The function in the old Vehicle SDK specified the direction of gravity as a PxU32. This has been replaced with an enum PxVehicleAxes::Enum. It is important to note that the PxU32 does not automatically map to PxVehicleAxes::Enum. For the purposes of clarity: the equivalent of using 0 in the old SDK is now PxVehicleAxes::eNegX and 1 maps to PxVehicleAxes::eNegY and 2 maps to PxVehicleAxes::eNegZ.</p>
</section>
<section id="disabling-wheels">
<h4>Disabling Wheels<a class="headerlink" href="#disabling-wheels" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK supported the disabling and enabling of wheels using the functions PxVehicleWheelsSimData::disableWheel() and PxVehicleWheelsSimData::enableWheel().  The new Vehicle SDK provides no direct equivalent function but does provide the flexibility to readily enable or disable wheels.</p>
<p>The axles of a vehicle and the wheels on each axle are now described with the struct PxVehicleAxleDescription.  The configuration of PxVehicleAxleDescription can be changed at any time before or after a vehicle simulation step.  To disable or enable a wheel it is necesary to reconfigure PxVehicleAxleDescription with a fresh set of axles and wheels.  One difficulty here is that vehicle configuration parameters such as PxAckermannCorrection and PxVehicleFourWheelDriveDifferentialParams might now maintain a reference to a disable wheel.   These parameters will need to be adjusted or removed from simulation.</p>
</section>
<section id="simulation-substeps">
<h4>Simulation Substeps<a class="headerlink" href="#simulation-substeps" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK supported substeps with the function PxVehicleWheelsSimData::setSubStepCount().  This function allowed an inner loop of the vehicle update to be conditionally simulated with substeps. More specifically, the function specified the number of substeps to run when the longitudional speed of the vehicle was less than or equal to a threshold speed, and the number to run when the longitudinal speed exceeded the threshold speed.</p>
<p>The new Vehicle SDK also supports substeps but this time in a more general sense. For example, the inner loop that is substepped is not fixed, as it was in the previous version. Moreover, there is no hard-coded condition to decide the number of substeps that will be applied to any inner loop. To describe this in further detail a quick summary of vehicle components is required.</p>
<p>A vehicle simulation update proceeds by updating the components of the vehicle in sequence. Each component represents a high-level feature of a vehicle such as a drivetrain or a suspension system or a rigid body.  The components and the sequence order of a vehicle are customisable.  A key point here is that the class PxVehicleComponentSequence is configured for each vehicle with an ordered sequence of components. The sequence order is dictated by the order that components are added to the sequence.</p>
<p>The class PxVehicleComponentSequence allows groups of sequential components to be collected into substep groups using the functions PxVehicleComponentSequence::beginSubstepGroup() and PxVehicleComponentSequence::endSubstepGroup().  These two functions are used to book-end any components that are added to the sequence using the function PxVehicleComponentSequence::add().  Each time PxVehicleComponentSequence::beginSubstepGroup() is called, a new subgroup is instantiated and a unique identifier for that subgroup is returned.  The following pseudo-code illustrates the creation of a subgroup:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleComponentSequence</span><span class="w"> </span><span class="n">sequence</span><span class="p">;</span>
<span class="n">sequence</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Component1</span><span class="p">);</span>
<span class="n">PxU32</span><span class="w"> </span><span class="n">subgroupId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sequence</span><span class="p">.</span><span class="n">beginSubstepGroup</span><span class="p">();</span>
<span class="n">sequence</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Component2</span><span class="p">);</span>
<span class="n">sequence</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Component3</span><span class="p">);</span>
<span class="n">sequence</span><span class="p">.</span><span class="n">endSubstepGroup</span><span class="p">();</span>
<span class="n">sequence</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Component4</span><span class="p">);</span>
</pre></div>
</div>
<p>The example above creates a subgroup containing an instance of Component2 and Component3. The unique identifier of the subgroup is stored in the parameter subgroupId.  The parameter subgroupId may be used to set the number of substeps for this subgroup.  The following pseudo-code sets the number of substeps to 3:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sequence</span><span class="p">.</span><span class="n">setSubsteps</span><span class="p">(</span><span class="n">subgroupId</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>An update of the sequence with timstep dt will now proceed as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">component1</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="n">component2</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
<span class="n">component3</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
<span class="n">component2</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
<span class="n">component3</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
<span class="n">component2</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
<span class="n">component3</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
<span class="n">component4</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
</pre></div>
</div>
<p>It’s important to note that there is no pre-defined logic to decide the number of substeps applied to any substep group.  This is left an an exercise to users of the Vehicle SDK.  Another point to note is that substeps may be nested.  This will be useful for systems that have a stiff component that needs updated with small timesteps. Rather than update the entire vehicle with small timesteps, it may be advantageous to target computational effort at only those subgroups that need it.</p>
<p>SnippetVehicle2DirectDrive provide an examples of a subgroup that replicates the inner loop and substepping condition that was found in the old SDK.</p>
</section>
<section id="serialization">
<h4>Serialization<a class="headerlink" href="#serialization" title="Link to this heading">#</a></h4>
<p>Due to the customizable nature of the new Vehicle SDK, no support for serialization is provided.  An example, however, is provided in the associated snippets. These snippets deserialize a vehicle from json format.</p>
</section>
<section id="removed-functions">
<h4>Removed Functions<a class="headerlink" href="#removed-functions" title="Link to this heading">#</a></h4>
<p>The following functions have all been removed and have no directly supported equivalent in the new Vehicle SDK:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicle4WEnable3WTadpoleMode</span><span class="p">()</span>
<span class="n">PxVehicle4WEnable3WDeltaMode</span><span class="p">()</span>
<span class="n">PxVehicleUpdateCMassLocalPose</span><span class="p">()</span>
<span class="n">PxVehicleCopyDynamicsData</span><span class="p">()</span>
<span class="n">PxVehicleUpdateSingleVehicleAndStoreTelemetryData</span><span class="p">()</span>
<span class="n">PxVehicleSetSweepHitRejectionAngles</span><span class="p">()</span>
<span class="n">PxVehicleSetMaxHitActorAcceleration</span><span class="p">()</span>
<span class="n">PxVehicleIsInAir</span><span class="p">()</span>
<span class="n">PxVehicleDrive4WSmoothDigitalRawInputsAndSetAnalogInputs</span><span class="p">()</span>
<span class="n">PxVehicleDrive4WSmoothAnalogRawInputsAndSetAnalogInputs</span><span class="p">()</span>
<span class="n">PxVehicleDriveNWSmoothDigitalRawInputsAndSetAnalogInputs</span><span class="p">()</span>
<span class="n">PxVehicleDriveNWSmoothAnalogRawInputsAndSetAnalogInputs</span><span class="p">()</span>
<span class="n">PxVehicleDriveTankSmoothDigitalRawInputsAndSetAnalogInputs</span><span class="p">()</span>
<span class="n">PxVehicleDriveTankSmoothAnalogRawInputsAndSetAnalogInputs</span><span class="p">()</span>
<span class="n">PxVehicleModifyWheelContacts</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
<section id="behavior-changes">
<h3>Behavior Changes<a class="headerlink" href="#behavior-changes" title="Link to this heading">#</a></h3>
<section id="applying-gravity-on-substeps">
<h4>Applying Gravity on Substeps<a class="headerlink" href="#applying-gravity-on-substeps" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK applied gravitational acceleration during the PxScene update and ignored it during all substeps of the vehicle update. The default behaviour in the new Vehicle SDK is to apply gravity in the substeps of the vehicle update so that its effect accumulates in the velocity or acceleration forwarded to the PhysX actor.  Gravity is then not applied to the rigid body in the PxScene update.</p>
</section>
<section id="jounce">
<h4>Jounce<a class="headerlink" href="#jounce" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK defined zero jounce to be the suspension compression state at the reference pose dictated by PxVehicleWheelsSimData::setWheelCentreOffset(). A negative jounce indicated a suspension state nearer to the maximum droop state, while a positive jounce indicated a suspension state nearer to the maximum compression state.  The jounce was thus always in range [-maxDroop, maxCompression].  The new Vehicle SDK defines zero jounce to be the suspension state at maximum droop.  Further, it introduces a single parameter to describe the distance between maximum droop and maximum compression. This parameter is PxVehicleSuspensionParams::suspensionTravelDist.  The jounce in the new Vehicle SDK is therefore always in range [0, PxVehicleSuspensionParams::suspensionTravelDist].</p>
</section>
<section id="camber">
<h4>Camber<a class="headerlink" href="#camber" title="Link to this heading">#</a></h4>
<p>The camber logic in the old Vehicle SDK suffered from a historic bug that took the camber angle directly from the suspension parameters and ignored the relationship between the wheel pose and contact normal. This error has been fixed in the new Vehicle SDK. However, this means that setting camber to 0.0 is not the same as disabling the effect of camber because the camber angle parameter is a correction to the camber angle that develops between wheel pose and contact normal. Camber effects may only be disabled in the new Vehicle SDK by setting the camber stiffness to zero (PxVehicleTireForceParams::camberStiff).</p>
<p>The default value for camber stiffness in the old Vehicle SDK falsely suggested that it was specified per degree rather than the documented per radian.  As a clarification, the new Vehicle SDK requires a camber stiffness specified in Newtons per radians.</p>
</section>
<section id="suspension-compression-limit-constraint">
<h4>Suspension Compression Limit Constraint<a class="headerlink" href="#suspension-compression-limit-constraint" title="Link to this heading">#</a></h4>
<p>When the suspension compresses beyond the limit a PhysX constraint is used to push the rigid body so that the suspension compressions project  back into a valid jounce range. The old Vehicle SDK used the suspension direction as the constraint direction. A better choice is to use the contact normal and to treat the unresolved suspension compression in the manner of a rigid contact. The new Vehicle SDK offers choices for the constraint direction.  Legacy behavior may be produced using PxVehiclePhysXSuspensionLimitConstraintParams::eSUSPENSION.  The preferred choice, however, is to use PxVehiclePhysXSuspensionLimitConstraintParams::eROAD_GEOMETRY_NORMAL, which treats the unresolved suspension compression in the manner of a rigid contact.  An entirely new choice is to completely disable the application of PhysX constraints to resolve suspension discrepancies. This is achieved using PxVehiclePhysXSuspensionLimitConstraintParams::eNONE.</p>
</section>
<section id="sleep-state">
<h4>Sleep State<a class="headerlink" href="#sleep-state" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK set the wheel steer angles of a sleeping vehicle to 0.0. This had no impact on the poses of the wheel shapes of the rigid body because those shapes were not updated after the vehicle entered the sleep state. The steer angle reported by the vehicle, however, would have been 0.0 for the duration of the sleep state. This is no longer the case: the new Vehicle SDK allows a vehicle to enter the sleep state with a non-zero steer angle applied to each wheel.</p>
<p>The old Vehicle SDK set the suspension jounces of a sleeping vehicle to a special internal value that was used to impose a jounce speed of zero  on the suspensions of sleeping vehicles. This had no impact on the poses of the wheel shapes of the rigid body because those shapes were not updated after the vehicle entered the sleep state. The jounce reported by the vehicle, however, would have been equal to the special internal value for the duration of the sleep state. This is no longer the case: the new Vehicle SDK allows a vehicle to enter the sleep state with a legal jounce applied to each suspension that matches the geometry under each wheel.</p>
<p>The new Vehicle SDK forbids a vehicle entering the sleep state if a gear change is pending.  Moreover, the vehicle is woken up if a gear change is initiated and the vehicle is already in the sleep state.  This behavior was not present in the old Vehicle SDK.</p>
<p>The new Vehicle SDK maintains the vehicle in the woken state if the mass-normalized rotational kinetic energy of a wheel is above the actor’s sleep threshold. This behavior was not present in the old Vehicle SDK.</p>
</section>
<section id="gear-switching">
<h4>Gear Switching<a class="headerlink" href="#gear-switching" title="Link to this heading">#</a></h4>
<p>The state PxVehicleGearboxState::gearSwitchTime now has the special value PX_VEHICLE_NO_GEAR_SWITCH_PENDING to denote that no gear change is underway. This is in contrast to PxVehicleDriveDynData::mGearSwitchTime, which was ambiguously set to 0.0 to denote that no gear change was underway.  It is hoped that PX_VEHICLE_NO_GEAR_SWITCH_PENDING better communicates the state of the gearbox.</p>
</section>
<section id="id3">
<h4>Autobox<a class="headerlink" href="#id3" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK allowed the autobox to be disabled using the boolean PxVehicleDriveDynData::mUseAutoGears. The new Vehicle SDK offers a different path to disable the autobox that is more in keeping with real-world behavior.  When PxVehicleEngineDriveTransmissionCommandState::targetGear has value PxVehicleEngineDriveTransmissionCommandState::eAUTOMATIC_GEAR, the target gear enables automatic gear mode, similar to the Drive mode “D” in real cars with automatic transmission. If the target gear has not been assigned to this special value, the transmission will be considered to be in manual mode and the autobox will not initiate a gear change.</p>
<p>The old Vehicle SDK allowed automatic shifting from neutral to first gear.  This is no longer supported: a vehicle in neutral gear will remain in neutral gear until a manual change is indicated.</p>
<p>The old Vehicle SDK initialized PxVehicleDriveDynData::mAutoBoxSwitchTime to 0.0.  The autobox could only instantiate a gear change after PxVehicleDriveDynData::mAutoBoxSwitchTime had accumulated a value greater than or equal to PxVehicleAutoBoxData::getLatency().  This introduced an initial latency to any gear change instantiated by the autobox. This behavior has changed in the new Vehicle SDK.  The equivalent timer is now initialized to a special value PX_VEHICLE_UNSPECIFIED_TIME_SINCE_LAST_SHIFT. This special value allows gear changes to be initiated by the autobox without any time accumulation; that is, without latency. Moreover, the autobox timer PxVehicleAutoboxState::timeSinceLastShift is reset to  PX_VEHICLE_UNSPECIFIED_TIME_SINCE_LAST_SHIFT every time the autobox is disabled.</p>
</section>
<section id="tire-sticky-constraint">
<h4>Tire Sticky Constraint<a class="headerlink" href="#tire-sticky-constraint" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK reduced the target speed of each active tire sticky constraint using a hard-coded damping value that was applied as a simple multiplier each substep of the vehicle simulation. This was not timestep aware, meaning that smaller timesteps would result in the target speeds more quickly approaching 0.0. The new Vehicle SDK exposes separate damping values that directly map to the damping values of the constraints being used to reach a zero target velocity. These damping values are configured in the parameters PxVehicleTireStickyParams::stickyParams[PxVehicleTireDirectionModes::eLONGITUDINAL]::damping and PxVehicleTireStickyParams::stickyParams[PxVehicleTireDirectionModes::eLATERAL]::damping. Note that the default values for these parameters reduce damping significantly compared to the old Vehicle SDK. To achieve the previous degree of damping, values in the range 100-1000 are a good starting point.</p>
</section>
<section id="tire-slip">
<h4>Tire Slip<a class="headerlink" href="#tire-slip" title="Link to this heading">#</a></h4>
<p>The longitudinal slip computation has been modified for the case that either a brake or drive torque is applied to the wheel. The denominator use to be sum of an constant term and and the maximum of the wheel’s linear speed at the road contact point and the longitudinal speed of the rigid body at the road contact point. The denominator is now the sum of a constant term and the longitudinal speed of the rigid body at the road contact point.  This change leads to higher values of longitudinal slip, especially when the vehicle is aggressively throttled from rest, and greater longitudinal force. A consequence of this is that smaller timesteps may be required to maintain numerical stability.  The class PxVehicleLegacyTireComponent has been introduced to implement the legacy longitudinal slip computation.</p>
</section>
<section id="limiting-suspension-expansion-velocity">
<h4>Limiting Suspension Expansion Velocity<a class="headerlink" href="#limiting-suspension-expansion-velocity" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK introduced the flag PxVehicleWheelsSimFlag::eLIMIT_SUSPENSION_EXPANSION_VELOCITY.  The purpose of this flag was to limit suspension expansion to the distance that could physically be achieved in any given simulation step.  If the flag was not set, the suspension would instantaneously reach the compression state required to place the wheel on the ground, provided this state lay within the suspension travel limits.</p>
<p>The new Vehicle SDK introduces the flag PxVehicleSuspensionStateCalculationParams::limitSuspensionExpansionVelocity, which performs a role similar to PxVehicleWheelsSimFlag::eLIMIT_SUSPENSION_EXPANSION_VELOCITY.  The implementation in 5.1 follows a different algorithm that better incorporates damping and jounce accelerations to generate more detailed but subtly different behavior.</p>
</section>
</section>
<section id="analog-control-inputs">
<h3>Analog Control Inputs<a class="headerlink" href="#analog-control-inputs" title="Link to this heading">#</a></h3>
<p>The old Vehicle SDK offered a variety of data structures and functions to pre-process analog control inputs from gamepads and keyboards.  These have all been removed from the new Vehicle SDK. Pre-processing of control inputs is left as an exercise for users of the new Vehicle SDK.</p>
<section id="four-wheel-drive">
<h4>Four Wheel Drive<a class="headerlink" href="#four-wheel-drive" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of control values for four wheel drive from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDrive4WControl::eANALOG_INPUT_ACCEL)</p></td>
<td><p>PxVehicleCommandState::throttle</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDrive4WControl::eANALOG_INPUT_BRAKE)</p></td>
<td><p>PxVehicleCommandState::brakes[0]</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDrive4WControl::eANALOG_INPUT_HANDBRAKE)</p></td>
<td><p>PxVehicleCommandState::brakes[1]</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDrive4WControl::eANALOG_INPUT_STEER_LEFT)</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDrive4WControl::eANALOG_INPUT_STEER_RIGHT)</p></td>
<td><p>Removed</p></td>
</tr>
</tbody>
</table>
</div>
<p>There is no equivalent of PxVehicleDrive4WControl::eANALOG_INPUT_STEER_LEFT or PxVehicleDrive4WControl::eANALOG_INPUT_STEER_RIGHT in the new Vehicle SDK.  Instead, the state of the steering wheel is specified by a single parameter PxVehicleCommandState::steer with values in range [-1, 1].</p>
</section>
<section id="multi-wheel-drive">
<h4>Multi Wheel Drive<a class="headerlink" href="#multi-wheel-drive" title="Link to this heading">#</a></h4>
<p>The following table illustrates the mapping of control values for N wheel drive from old to new SDK:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>old</p></td>
<td><p>new</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDriveNWControl::eANALOG_INPUT_ACCEL)</p></td>
<td><p>PxVehicleCommandState::throttle</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDriveNWControl::eANALOG_INPUT_BRAKE)</p></td>
<td><p>PxVehicleCommandState::brakes[0]</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDriveNWControl::eANALOG_INPUT_HANDBRAKE)</p></td>
<td><p>PxVehicleCommandState::brakes[1]</p></td>
</tr>
<tr class="row-odd"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDriveNWControl::eANALOG_INPUT_STEER_LEFT)</p></td>
<td><p>Removed</p></td>
</tr>
<tr class="row-even"><td><p>PxVehicleDriveDynData::setAnalogInput(PxVehicleDrive4WControl::eANALOG_INPUT_STEER_RIGHT)</p></td>
<td><p>Removed</p></td>
</tr>
</tbody>
</table>
</div>
<p>There is no equivalent of PxVehicleDriveNWControl::eANALOG_INPUT_STEER_LEFT or PxVehicleDriveNWControl::eANALOG_INPUT_STEER_RIGHT in the new Vehicle SDK.  Instead, the state of the steering wheel is specified by a single parameter PxVehicleCommandState::steer with values in range [-1, 1].</p>
</section>
<section id="direct-drive">
<h4>Direct Drive<a class="headerlink" href="#direct-drive" title="Link to this heading">#</a></h4>
<p>The old Vehicle SDK applied brake torque, drive torques and steer angles to each wheel using the functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleNoDrive</span><span class="o">::</span><span class="n">setBrakeTorque</span><span class="p">()</span>
<span class="n">PxVehicleNoDrive</span><span class="o">::</span><span class="n">setDriveTorque</span><span class="p">()</span>
<span class="n">PxVehicleNoDrive</span><span class="o">::</span><span class="n">setSteerAngle</span><span class="p">()</span>
</pre></div>
</div>
<p>The new Vehicle SDK offers a number of alternatives to replicate this functionality.  The first strategy is to use the data structure PxVehicleCommandState in the same way it is applied for every other type of drive. The data structures PxVehicleBrakeCommandResponseParams, PxVehicleDirectDriveThrottleCommandResponseParams and PxVehicleSteerCommandResponseParams may be used to specify the per wheel response to brake, throttle and steer commands.  The combination of command, per vehicle maximum command response, and per wheel maximum command response allows a runtime computation of a value to apply per wheel.  It is straightforward to tune the per wheel responses to generate any specific per wheel torque or steering angle.  One thing to bear in mind with this strategy is that it additionally relies on PxVehicleDirectDriveTransmissionCommandState, which introduces a forward, neutral and reverse gear for direct drive.  PxVehicleDirectDriveTransmissionCommandState::gear must be set to the desired value prior to each simulation step.</p>
<p>A second strategy any alternative mechanism that writes per wheel values to float arrays representing torques and steering angles. This may be achieved with custom components that distribute torques and steer angles to each wheel. A custom component that implements AEB or a limited slip differential might serve as good examples. If the torques and angles are already known, the process is as simple as writing directly to the command response states and ensuring that the pipeline of components does not overwrite any values until they are applied to the wheels.</p>
</section>
</section>
<section id="digital-control-inputs">
<h3>Digital Control Inputs<a class="headerlink" href="#digital-control-inputs" title="Link to this heading">#</a></h3>
<p>The old Vehicle SDK provided a variety of methods  to change gear.  The functions PxVehicleDriveDynData::setTargetGear() and PxVehicleDriveDynData::startGearChange() instantiated a timed gear change from the current gear to a specified target gear.  Further functionality allowed incremental timed gear changes with the functions PxVehicleDriveDynData::setGearUp() and PxVehicleDriveDynData::setGearDown(). Finally, the function PxVehicleDriveDynData::forceGearChange() had the effect of an immediate change from the current gear to a specified target gear.</p>
<p>Just as in the old Vehicle SDK, timed gear changes are instantiated in the new Vehicle SDK when current and target gear are different.  The current gear is now stored in PxVehicleGearboxState::currentGear and the target gear is specified using PxVehicleEngineDriveTransmissionCommandState::targetGear.  Choices of PxVehicleEngineDriveTransmissionCommandState::targetGear allow either incremental or non-incremental timed gear changes to be instantiated:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleEngineDriveTransmissionCommandState</span><span class="o">::</span><span class="n">targetGear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">targetGear</span>
</pre></div>
</div>
<p>Immediate gear changes are also possible in the new Vehicle SDK. This is achieved by aligning internal state with the input gear command and resetting the gear timer. The relevant changes are are as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxVehicleEngineDriveTransmissionCommandState</span><span class="o">::</span><span class="n">targetGear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">targetGear</span>
<span class="n">PxVehicleGearboxState</span><span class="o">::</span><span class="n">currentGear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">targetGear</span>
<span class="n">PxVehicleGearboxState</span><span class="o">::</span><span class="n">targetGear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">targetGear</span>
<span class="n">PxVehicleGearboxState</span><span class="o">::</span><span class="n">gearSwitchTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PX_VEHICLE_NO_GEAR_SWITCH_PENDING</span>
</pre></div>
</div>
<p>Caution must be taken with immediate gear changes if the autobox is active.</p>
</section>
<section id="vehicle-frame-and-lengthscale">
<h3>Vehicle Frame And Lengthscale<a class="headerlink" href="#vehicle-frame-and-lengthscale" title="Link to this heading">#</a></h3>
<p>The old Vehicle SDK specified the vehicle frame using the function PxVehicleSetBasisVectors(). The equivalent in the new Vehicle SDK is the data structure PxVehicleFrame (PxVehicleSimulationContext::frame).</p>
<p>The old Vehicle SDK automatically configured the lengthscale using the lengthscale of the corresponding PxPhysics instance. The new Vehicle SDK requires the lengthscale to be explicitly specified using the data structure PxVehicleScale (PxVehicleSimulationContext::scale).</p>
</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="MigrationTo40.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Migrating From PhysX SDK 3.4 to 4.0</p>
      </div>
    </a>
    <a class="right-next"
       href="MigrationTo52.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Migrating From PhysX SDK 5.1 to 5.2</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#removed-apis">Removed APIs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#simulation">Simulation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#generic">Generic</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#materials">Materials</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cooking">Cooking</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shapes">Shapes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joints">Joints</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scene-queries">Scene Queries</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pxbvhstructure">PxBVHStructure</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gpu-rigid-bodies">GPU Rigid Bodies</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#character-controller">Character controller</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vehicles">Vehicles</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parameters">Parameters</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#engine">Engine</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#gearbox">Gearbox</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#autobox">Autobox</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#n-wheel-drive-differential">N-Wheel Drive Differential</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#four-wheel-drive-differential">Four-Wheel Drive Differential</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#clutch">Clutch</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ackermann-correction">Ackermann Correction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#wheels">Wheels</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tire-load-filter">Tire Load Filter</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tire">Tire</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tire-contact-friction">Tire Contact Friction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#suspension">Suspension</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#anti-roll-bars">Anti-Roll Bars</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#telemetry">Telemetry</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#longitudinal-slip-parameters">Longitudinal Slip Parameters</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simulation-state">Simulation State</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tertiary-properties">Tertiary Properties</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-state">Dynamic State</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#functions">Functions</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#startup-and-shutdown">Startup And Shutdown</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Scene Queries</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#vehicle-update">Vehicle Update</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#update-mode">Update Mode</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#wheel-shapes">Wheel Shapes</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sprung-mass-computation">Sprung Mass Computation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#disabling-wheels">Disabling Wheels</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#simulation-substeps">Simulation Substeps</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#serialization">Serialization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#removed-functions">Removed Functions</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#behavior-changes">Behavior Changes</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#applying-gravity-on-substeps">Applying Gravity on Substeps</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#jounce">Jounce</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#camber">Camber</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#suspension-compression-limit-constraint">Suspension Compression Limit Constraint</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sleep-state">Sleep State</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#gear-switching">Gear Switching</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Autobox</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tire-sticky-constraint">Tire Sticky Constraint</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tire-slip">Tire Slip</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#limiting-suspension-expansion-velocity">Limiting Suspension Expansion Velocity</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analog-control-inputs">Analog Control Inputs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#four-wheel-drive">Four Wheel Drive</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-wheel-drive">Multi Wheel Drive</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#direct-drive">Direct Drive</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#digital-control-inputs">Digital Control Inputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vehicle-frame-and-lengthscale">Vehicle Frame And Lengthscale</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
<a class="footer-brand logo" href="https://www.nvidia.com">
  <img src="../_static/nvidia-logo-horiz-rgb-1c-blk-for-screen.svg" class="logo__image only-light" alt="NVIDIA"/>
  <img src="../_static/nvidia-logo-horiz-rgb-1c-wht-for-screen.svg" class="logo__image only-dark" alt="NVIDIA"/>
</a></div>
      
        <div class="footer-item">



  <p class="copyright">
    
      Copyright © 2022-2025, NVIDIA Corporation.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item"><p class="last-updated">
  Last updated on Jul 22, 2025.
  <br/>
</p></div>
      
    </div>
  
  
  
</div>

  </footer>
  </body>
</html>