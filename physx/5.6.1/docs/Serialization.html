

<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Serialization &#8212; PhysX SDK Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/nvidia-sphinx-theme.css?v=c5edffae" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=767de534" />
    <link rel="stylesheet" type="text/css" href="../_static/api.css?v=6f210184" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script rel="preload" src="../_static/modal-table.js"></script>
    <script src="../_static/documentation_options.js?v=bbec3584"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scrollspy-patch.js?v=edc4054a"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'docs/Serialization';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = '../versions1.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '5.6.1';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <script src="../_static/version-patch.js?v=c24f8c5d"></script>
    <script rel="preload" src="../_static/toctree.js"></script>
    <link rel="icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Best Practices Guide" href="BestPractices.html" />
    <link rel="prev" title="Simulation Statistics" href="Statistics.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Jul 22, 2025"/>


  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA-Omniverse/PhysX" title="github" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">github</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        



  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="PhysX SDK Documentation - Home"/>
    <script>document.write(`<img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark" alt="PhysX SDK Documentation - Home"/>`);</script>
  
  
    <p class="title logo__title">PhysX SDK Documentation</p>
  
</a>


  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NVIDIA-Omniverse/PhysX" title="github" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">github</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/nvidiaomniverse" title="twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitter</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/channel/UCSKUoczbGAcMld7HjpCR8OA" title="youtube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">youtube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.instagram.com/nvidiaomniverse" title="instagram" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-instagram fa-lg" aria-hidden="true"></i>
            <span class="sr-only">instagram</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.nvidia.com/en-us/omniverse/" title="www" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-globe fa-lg" aria-hidden="true"></i>
            <span class="sr-only">www</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/showcase/nvidia-omniverse" title="linkedin" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">linkedin</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.twitch.tv/nvidiaomniverse" title="twitch" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitch fa-lg" aria-hidden="true"></i>
            <span class="sr-only">twitch</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">


<nav class="bd-docs-nav bd-links"
     aria-label="Table of Contents">
  <p class="bd-links__title" role="heading" aria-level="1">Table of Contents</p>
  <div class="bd-toc-item navbar-nav"></div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">


<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
  </div>
  
  <div id="rtd-footer-container"></div>



      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">Serialization</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="serialization">
<span id="id1"></span><h1>Serialization<a class="headerlink" href="#serialization" title="Link to this heading">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>PhysX features two approaches to serialization:</p>
<ul class="simple">
<li><p>API-level serialization to RepX (an XML format) - DEPRECATED</p></li>
<li><p>Binary serialization</p></li>
</ul>
<p>API-level serialization uses a human readable XML format - RepX - that directly corresponds to the PhysX API. It is therefore suitable for manual inspection and modification for debugging purposes.  It offers platform independence and further supports loading data that was serialized with a previous PhysX SDK version.  API-level serialization is not expected to be used in performance critical situations. This feature has been deprecated and is being replaced with the <em>USD Physics</em> data format.</p>
<p>The binary serialization approach on the other hand supports instantiation of PhysX objects directly from memory without copying data. This in-place deserialization method is well suited for performance critical real time situations. However, this approach is also less flexible as the binary format is specific to a given platform and PhysX SDK version.  PhysX provides functionality to convert binary serialized data from authoring platforms to run-time platforms to ease the asset management. The conversion functionality has been deprecated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>cooking</em> also generates a binary output stream. The primary purpose of cooking, however, is to translate from a user format to a format suitable for the SDK runtime, and so it is not considered a serialization mechanism. Loading a cooked mesh from a stream involves allocation and endian conversion. As a consequence, it is much less efficient than PhysX’ binary serialization mechanism.  See <a class="reference internal" href="RigidBodyCollision.html#rigidbodycollisionshapes"><span class="std std-ref">Shapes</span></a> for more details about cooking.</p>
</div>
<p>The following documentation will discuss how to use both serialization approaches.  It will show how to build collections of PhysX objects and how these collections are serialized and deserialized.  Further it will show how dependencies to other PhysX objects or application side objects can be re-established when deserializing.</p>
</section>
<section id="first-code">
<h2>First Code<a class="headerlink" href="#first-code" title="Link to this heading">#</a></h2>
<p>The following code creates and serializes a rigid dynamic using both RepX and binary formats:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a material, a shape and a rigid dynamic</span>
<span class="n">PxSphereGeometry</span><span class="w"> </span><span class="nf">geometry</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">PxMaterial</span><span class="o">*</span><span class="w"> </span><span class="n">material</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxGetPhysics</span><span class="p">().</span><span class="n">createMaterial</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">PxShape</span><span class="o">*</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxGetPhysics</span><span class="p">().</span><span class="n">createShape</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">material</span><span class="p">);</span>
<span class="n">PxTransform</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxTransform</span><span class="p">(</span><span class="n">PxIdentity</span><span class="p">);</span>
<span class="n">PxRigidDynamic</span><span class="o">*</span><span class="w"> </span><span class="n">dynamic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateDynamic</span><span class="p">(</span><span class="n">PxGetPhysics</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">geometry</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">material</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>

<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createSerializationRegistry</span><span class="p">(</span><span class="n">PxGetPhysics</span><span class="p">());</span>

<span class="c1">// Create a collection and all objects for serialization</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">dynamic</span><span class="p">);</span>
<span class="n">PxSerialization</span><span class="o">::</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>

<span class="c1">// Serialize either to binary or RepX</span>
<span class="n">PxDefaultFileOutputStream</span><span class="w"> </span><span class="n">outStream</span><span class="p">(</span><span class="s">&quot;serialized.dat&quot;</span><span class="p">);</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToBinary</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToXml</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~RepX</span>
</pre></div>
</div>
<p>Most operations related to serialization require an instance of <em>PxSerializationRegistry</em>, which provides information on how to serialize PhysX types.  In order to serialize a PhysX object, it needs to be added to a <em>PxCollection</em>.  If an object has dependencies on other PhysX objects, they need to be serialized as well. <em>PxSerialization::complete</em> adds all the required objects to the collection.</p>
<p>The following code deserializes the rigid dynamic and adds it to a scene for simulation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createSerializationRegistry</span><span class="p">(</span><span class="n">PxGetPhysics</span><span class="p">());</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="c1">// Open file and get file size</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;serialized.dat&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;rb&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">fseek</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">SEEK_END</span><span class="p">);</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">fileSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ftell</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="w">    </span><span class="n">fseek</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">SEEK_SET</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Allocate aligned memory, load data and deserialize</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">fileSize</span><span class="o">+</span><span class="n">PX_SERIAL_FILE_ALIGN</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memory128</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="kt">size_t</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PX_SERIAL_FILE_ALIGN</span><span class="p">)</span><span class="o">&amp;~</span><span class="p">(</span><span class="n">PX_SERIAL_FILE_ALIGN</span><span class="mi">-1</span><span class="p">));</span>
<span class="w">    </span><span class="n">fread</span><span class="p">(</span><span class="n">memory128</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">fileSize</span><span class="p">,</span><span class="w"> </span><span class="n">fp</span><span class="p">);</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">memory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="c1">// Load file and deserialize collection - needs cooking parameters</span>
<span class="w">    </span><span class="n">PxDefaultFileInputData</span><span class="w"> </span><span class="n">inputData</span><span class="p">(</span><span class="s">&quot;serialized.dat&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span>
<span class="w">                                                                        </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="n">scene</span><span class="o">-&gt;</span><span class="n">addCollection</span><span class="p">(</span><span class="o">*</span><span class="n">collection</span><span class="p">);</span>
</pre></div>
</div>
<p>When deserializing a binary serialized collection, the data first needs to be copied to a memory block that is aligned to 128 bytes. The memory block may not be deallocated before the objects have been released: it needs to persist for the entire lifetime of the objects. This does not apply to RepX deserialization, as the memory for the corresponding PhysX objects is allocated within PhysX. Finally the objects of the resulting collection can be added to the scene with <em>PxScene::addCollection</em>.</p>
</section>
<section id="in-depth-discussion">
<h2>In-depth Discussion<a class="headerlink" href="#in-depth-discussion" title="Link to this heading">#</a></h2>
<section id="collections">
<h3>Collections<a class="headerlink" href="#collections" title="Link to this heading">#</a></h3>
<p>The serialization system makes use of a class <em>PxCollection</em>, which manages references to objects deriving from <em>PxBase</em>. Each collection represents a set of objects. Collections maintain a mapping between IDs of type <em>PxSerialObjectId</em> and objects in the collection. IDs may be defined by the application. One caveat here is that the IDs must be unique within a collection, but do not have to be unique across different collections. If the latter is required by the application, it is the application’s responsibility to ensure it.</p>
<p>Here is an example of how to iterate over a collection, for instance to ensure that the objects intended for serialization have all been added to the collection. When doing so PhysX’ dynamic typing mechanism can be used to classify the objects:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="p">;</span>
<span class="n">PxU32</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">getNbObjects</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PxBase</span><span class="o">*</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">getObject</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxActor</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span>

<span class="w">    </span><span class="k">switch</span><span class="p">((</span><span class="n">PxConcreteType</span><span class="p">)</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getConcreteType</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PxConcreteType</span><span class="o">::</span><span class="no">eRIGID_DYNAMIC</span><span class="p">:</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order to simplify releasing object within a collection, PhysXExtensions contains a function to remove and release all objects from a collection: <em>PxCollectionExt::releaseObjects</em>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Releasing an object within a collection invalidates the mapping from indices to objects.</p>
</div>
<p>A collection is said to be <em>complete</em> if no contained objects depend on an object outside of the collection. For example, an actor, a shape with a box geometry, and the material of the shape would together form a complete collection. The same collection without the material would be incomplete.</p>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="../_images/Serialization_Complete.png"><img alt="../_images/Serialization_Complete.png" src="../_images/Serialization_Complete.png" style="width: 657.0px; height: 212.0px;" />
</a>
<figcaption>
<p><span class="caption-text">Figure 1: Left: Complete Collection, Right: Incomplete Collection</span><a class="headerlink" href="#id6" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>For a formal definition please refer to <a class="reference internal" href="#complete"><span class="std std-ref">Complete</span></a>.</p>
<p>Both complete and incomplete collections can be serialized, but when deserializing an incomplete collection, references to objects which were not serialized will need to be resolved. The following two sections describe how PhysX collections can be serialized and deserialized using the binary format or RepX (deprecated). The first section shows how to deal with complete collections, and the second section shows how to deal with incomplete collections.</p>
</section>
<section id="serializing-complete-collections">
<h3>Serializing Complete Collections<a class="headerlink" href="#serializing-complete-collections" title="Link to this heading">#</a></h3>
<p>This code snippet shows how to prepare a collection of PhysX objects for serialization (e.g. an actor, its shapes, and the materials and meshes they reference.):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxPhysics</span><span class="o">*</span><span class="w"> </span><span class="n">physics</span><span class="p">;</span><span class="w">                                         </span><span class="c1">// The physics SDK object</span>
<span class="n">PxRigidDynamic</span><span class="o">*</span><span class="w"> </span><span class="n">dynamic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateDynamic</span><span class="p">(...);</span><span class="w">             </span><span class="c1">// Create a rigid dynamic</span>

<span class="w">                                                            </span><span class="c1">//Create a serialization registry</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createSerializationRegistry</span><span class="p">(</span><span class="o">*</span><span class="n">physics</span><span class="p">);</span>

<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span><span class="w">            </span><span class="c1">// Create a collection</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">dynamic</span><span class="p">);</span><span class="w">                                  </span><span class="c1">// Add it to the collection</span>

<span class="n">PxSerialization</span><span class="o">::</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span><span class="w">          </span><span class="c1">// Adds all objects required to</span>
<span class="w">                                                            </span><span class="c1">// recreate the dynamic after</span>
<span class="w">                                                            </span><span class="c1">// deserialization</span>
</pre></div>
</div>
<p>Instead of using <em>PxSerialization::complete</em> it is possible to manually add the objects required for serialization. All objects the <em>PxRigidDynamic</em> references would need to be added and then all objects referenced by the newly added objects would need to be added as well and so forth. See definitions: <a class="reference internal" href="#requires"><span class="std std-ref">Requires</span></a>, <a class="reference internal" href="#complete"><span class="std std-ref">Complete</span></a>.</p>
<p>By default <em>PxSerialization::complete</em> follows references from joints to their actors, but not from actors to their joints. The <em>followJoint</em> parameter can be used to change the behavior of <em>PxSerialization::complete</em> to add the joints attached to each actor. This will cause entire actor-joint chains to be added to the collection.</p>
<p>When all the necessary objects have been added to a collection, create an implementation of the PxOutputStream interface, then serialize the collection:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxColletion</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="p">;</span><span class="w">                                  </span><span class="c1">// Complete collection without orphans</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">                        </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxOutputStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">outStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">                          </span><span class="c1">// Implemented by the application</span>

<span class="c1">// Serialize</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToBinary</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToXml</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="c1">// Collection and registry can be released if they are no longer required.</span>
<span class="c1">// Note that releasing the collection will not release the contained objects!</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Serialization of objects in a scene that is simultaneously being simulated is not supported and leads to undefined behavior.</p>
</div>
<p>The following code shows how to deserialize a collection from a memory block or XML:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">                        </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxCookingParams</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">;</span><span class="w">                            </span><span class="c1">// Cooking parameters needed for</span>
<span class="w">                                                          </span><span class="c1">// instantiating objects by RepX</span>

<span class="c1">// Deserialize</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memory128</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">                                </span><span class="c1">// A 128-byte aligned buffer previously</span>
<span class="w">                                                          </span><span class="c1">// loaded from disk by the user</span>

<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">memory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxInputData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">                         </span><span class="c1">// Implemented by the application</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span>
<span class="w">                                                                        </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~RepX</span>
</pre></div>
</div>
<p>To add all the objects to the scene and release the collection and registry:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxScene</span><span class="o">*</span><span class="w"> </span><span class="n">scene</span><span class="p">;</span><span class="w">                                           </span><span class="c1">// The scene object</span>
<span class="n">scene</span><span class="o">-&gt;</span><span class="n">addCollection</span><span class="p">(</span><span class="o">*</span><span class="n">collection</span><span class="p">);</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#serializable"><span class="std std-ref">Serializable</span></a> for the exact set of conditions a collection must satisfy in order to be serialized. These conditions can be checked with <em>PxSerialization::isSerializable(…)</em>.</p>
</section>
<section id="serializing-incomplete-collections">
<span id="serializingpartialobjectgraphs"></span><h3>Serializing Incomplete Collections<a class="headerlink" href="#serializing-incomplete-collections" title="Link to this heading">#</a></h3>
<p>Another common use case is where a collection of actors and joints - say, a rag doll - will be deserialized multiple times, with each instance sharing the same materials and meshes. To achieve this, serialize two collections:</p>
<ul class="simple">
<li><p>a collection A of the materials and meshes that will be deserialized just once</p></li>
<li><p>a collection B of actors and joints which will be copied and deserialized multiple times</p></li>
</ul>
<p>Collection B is <em>incomplete</em>, since it contains references to objects in A. When serializing B, the serialized format will remember each reference to an object in A using that object’s ID (if it doesn’t have an ID, then serialization will fail.) As long as an object of the right type with a matching ID is supplied when deserializing collection B, the reference can be resolved. Although collection B is incomplete, it is also said to be <em>complete relative to</em> collection A. For a formal definition of complete please refer to <a class="reference internal" href="#complete"><span class="std std-ref">Complete</span></a>.</p>
<figure class="align-center" id="id7">
<a class="reference internal image-reference" href="../_images/Serialization_Dependency.png"><img alt="../_images/Serialization_Dependency.png" src="../_images/Serialization_Dependency.png" style="width: 631.0px; height: 212.0px;" />
</a>
<figcaption>
<p><span class="caption-text">Figure 2: Left: Collection <em>A</em> with Sharable Objects, Right: Collection <em>B</em> depending on <em>A</em></span><a class="headerlink" href="#id7" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Concretely, to serialize and deserialize an incomplete collection:</p>
<ul class="simple">
<li><p>At serialization time, provide IDs for all objects in collection A that are referenced by objects in collection B.</p></li>
<li><p>When deserializing, provide a collection with matching IDs for all the objects in A that were referenced by objects in B.</p></li>
</ul>
<p>Here are examples of how the application can provide identities (<em>PxSerialObjectId</em>) to express requirements of one collection to another. This can be done explicitly when adding the object with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="p">;</span>
<span class="n">PxTriangleMesh</span><span class="o">*</span><span class="w"> </span><span class="n">triMesh</span><span class="p">;</span>
<span class="n">PxSerialObjectId</span><span class="w"> </span><span class="n">triMeshId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                                  </span><span class="c1">// PX_SERIAL_OBJECT_ID_INVALID</span>
<span class="w">                                                                 </span><span class="c1">// is a reserved value</span>

<span class="n">collection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">triMesh</span><span class="p">,</span><span class="w"> </span><span class="n">triMeshId</span><span class="p">);</span>
</pre></div>
</div>
<p>Or set the ID after adding the object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">triMesh</span><span class="p">);</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">addId</span><span class="p">(</span><span class="o">*</span><span class="n">triMesh</span><span class="p">,</span><span class="w"> </span><span class="n">triMeshId</span><span class="p">);</span>
</pre></div>
</div>
<p>There is a helper function to generate IDs for all objects in a collection that do not have IDs yet:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxSerialObjectId</span><span class="w"> </span><span class="n">baseId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                                     </span><span class="c1">// PX_SERIAL_OBJECT_ID_INVALID is</span>
<span class="w">                                                                 </span><span class="c1">// a reserved value</span>
<span class="n">PxSerialization</span><span class="o">::</span><span class="n">createSerialObjectIds</span><span class="p">(</span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="n">baseId</span><span class="p">);</span><span class="w">     </span><span class="c1">// Assigns incremental ID values</span>
<span class="w">                                                                 </span><span class="c1">// to the collection objects</span>
</pre></div>
</div>
<p>Already used ID values will be skipped by <em>createSerialObjectIds</em>, as well as objects that already have IDs.</p>
<p>After providing correct IDs, all required objects have been added to the collection to be serialized, but without adding the objects that are intended to be referenced. The <em>complete</em> function in <em>PxSerialization</em> supports completing a collection relative to another collection:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">                               </span><span class="c1">// Registry for serializable types</span>

<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collectionB</span><span class="p">;</span><span class="w">                                       </span><span class="c1">// Collection to be completed</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collectionA</span><span class="p">;</span><span class="w">                                       </span><span class="c1">// The collection, collectionB</span>
<span class="w">                                                                 </span><span class="c1">// will depend on</span>

<span class="n">PxSerialization</span><span class="o">::</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="n">collectionB</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">collectionA</span><span class="p">);</span><span class="w"> </span><span class="c1">// Completes collectionB, but</span>
<span class="w">                                                                 </span><span class="c1">// ignores objects in collectionA</span>
<span class="w">                                                                 </span><span class="c1">// (and also their requirements)</span>
</pre></div>
</div>
<p>Serialization example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxConvexMesh</span><span class="o">**</span><span class="w"> </span><span class="n">convexes</span><span class="p">;</span><span class="w">             </span><span class="c1">// An array of mNbConvexes convexes</span>
<span class="n">PxRigidDynamic</span><span class="o">**</span><span class="w"> </span><span class="n">actors</span><span class="p">;</span><span class="w">             </span><span class="c1">// An array of mNbConvexes actors referencing the convexes</span>

<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">   </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxOutputStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">convexStream</span><span class="p">;</span><span class="w">        </span><span class="c1">// Output stream for the convex collection</span>
<span class="n">PxOutputStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">actorStream</span><span class="p">;</span><span class="w">         </span><span class="c1">// Output stream for the actor collection</span>

<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">convexCollection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">actorCollection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span>

<span class="c1">// Add convexes to collection</span>
<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mNbConvexes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">convexCollection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">convexes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="c1">// Create IDs for the convexes, starting with 1</span>
<span class="n">PxSerialization</span><span class="o">::</span><span class="n">createSerialObjectIds</span><span class="p">(</span><span class="o">*</span><span class="n">convexCollection</span><span class="p">,</span><span class="w"> </span><span class="n">PxSerialObjectId</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// Serialize the convexes along with their IDs</span>

<span class="c1">// Binary</span>
<span class="w">   </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToBinary</span><span class="p">(</span><span class="n">convexStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">convexCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">   </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToXml</span><span class="p">(</span><span class="n">convexStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">convexCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="c1">// Add actors to other collection</span>
<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mNbActors</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">actorCollection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">actors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="c1">// Add all required objects except the convexes</span>
<span class="n">PxSerialization</span><span class="o">::</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="n">actorCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">convexCollection</span><span class="p">);</span>

<span class="c1">// Serialize the actors with references to convexCollection</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToBinary</span><span class="p">(</span><span class="n">actorStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">actorCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">convexCollection</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToXml</span><span class="p">(</span><span class="n">actorStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">actorCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">convexCollection</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="c1">// Release collections and registry</span>
<span class="n">convexCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">actorCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
<p>Deserialization example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxPhysics</span><span class="o">*</span><span class="w"> </span><span class="n">physics</span><span class="p">;</span><span class="w">                         </span><span class="c1">// The physics SDK object</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="w">           </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxCookingParams</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">;</span><span class="w">              </span><span class="c1">// Cooking params needed for instantiating objects (RepX)</span>
<span class="n">PxScene</span><span class="o">*</span><span class="w"> </span><span class="n">scene</span><span class="p">;</span><span class="w">                             </span><span class="c1">// The scene into which the objects will be inserted</span>

<span class="c1">// Deserialize convexes along with their IDs (no external dependencies)</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">convexMemory128</span><span class="p">;</span><span class="w">                  </span><span class="c1">// Aligned memory containing serialized convexes</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">convexCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">convexMemory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxInputData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">convexInputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">     </span><span class="c1">// Implemented by the application</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">convexCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">convexInputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="c1">// Deserialize actors referencing the convexCollection</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">actorMemory128</span><span class="p">;</span><span class="w">                   </span><span class="c1">// Aligned memory containing serialized actors</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">actorCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">actorMemory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">convexCollection</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxInputData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">actorInputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">      </span><span class="c1">// Implemented by the application</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">actorCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">actorInputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">convexCollection</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="c1">// Release convex collection</span>
<span class="n">convexCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

<span class="c1">// Add actors to scene and release collection and registry</span>
<span class="n">scene</span><span class="o">-&gt;</span><span class="n">addCollection</span><span class="p">(</span><span class="o">*</span><span class="n">actorCollection</span><span class="p">);</span>
<span class="n">actorCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
<p>The next example shows how to deal with situations where the serialized objects require objects that are not serialized and deserialized but created by other means:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">  </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxMaterial</span><span class="o">**</span><span class="w"> </span><span class="n">materials</span><span class="p">;</span><span class="w">             </span><span class="c1">// Created procedurally by application</span>
<span class="n">PxRigidDynamic</span><span class="o">**</span><span class="w"> </span><span class="n">actors</span><span class="p">;</span><span class="w">            </span><span class="c1">// An array of mNbConvexes actors referencing the convexes</span>
<span class="n">PxOutputStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">actorStream</span><span class="p">;</span><span class="w">        </span><span class="c1">// Output stream for the actor collection</span>

<span class="c1">// Add materials with IDs to collection</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">materialCollection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span>

<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mNbMaterials</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">materialCollection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">PxSerialObjectId</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// Create actor collection, complete and serialize</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">actorCollection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span>

<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mNbActors</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">actorCollection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">actors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="n">PxSerialization</span><span class="o">::</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="n">actorCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">materialCollection</span><span class="p">);</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToBinary</span><span class="p">(</span><span class="n">actorStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">actorCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">materialCollection</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToXml</span><span class="p">(</span><span class="n">actorStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">actorCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">materialCollection</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="n">actorCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">materialCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span><span class="w">          </span><span class="c1">// Note that materialCollection was not serialized</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
<p>Deserialization:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxScene</span><span class="o">*</span><span class="w"> </span><span class="n">scene</span><span class="p">;</span><span class="w">                         </span><span class="c1">// The scene into which the objects will be inserted</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">      </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxCookingParams</span><span class="w"> </span><span class="n">cookingPArams</span><span class="p">;</span><span class="w">          </span><span class="c1">// Cooking params needed for instantiating objects(RepX)</span>
<span class="n">PxMaterial</span><span class="o">**</span><span class="w"> </span><span class="n">materials</span><span class="p">;</span><span class="w">                 </span><span class="c1">// Created procedurally by application</span>

<span class="c1">// recreate material collection with consistent IDs, no deserialization</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">materialCollection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span>

<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mNbMaterials</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">materialCollection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">PxSerialObjectId</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// Deserialize actors with reference material collection</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">actorMemory128</span><span class="p">;</span><span class="w">                </span><span class="c1">// aligned memory containing serialized actors</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">actorCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">actorMemory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span>
<span class="w">        </span><span class="n">materialCollection</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxInputData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">actorInputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">   </span><span class="c1">// Implemented by the application</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">actorCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">actorInputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">materialCollection</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="n">materialCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">scene</span><span class="o">-&gt;</span><span class="n">addCollection</span><span class="p">(</span><span class="o">*</span><span class="n">actorCollection</span><span class="p">);</span>
<span class="n">actorCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="reference-counting-of-deserialized-objects">
<span id="deserializereferencecounting"></span><h3>Reference Counting of Deserialized Objects<a class="headerlink" href="#reference-counting-of-deserialized-objects" title="Link to this heading">#</a></h3>
<p>This section assumes the background in <a class="reference internal" href="API.html#basicreferencecounting"><span class="std std-ref">Reference Counting</span></a>.</p>
<p>Objects that are created by deserialization are always created with a reference that the application needs to give up by explicitly calling <em>release()</em>. The information whether the application gave up a reference to an object is <strong>not</strong> preserved on serialization.</p>
<p>See <a class="reference internal" href="RigidBodyCollision.html#rigidbodycollisionshapes"><span class="std std-ref">Shapes</span></a> for a discussion of the method <em>PxRigidActorExt::createExclusiveShape</em>, which automatically releases the initial reference to the shape, leaving only the actor’s reference. Again, the information that this reference has been released is not preserved by serialization.</p>
<p>Example for shapes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxOutputStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">outStream</span><span class="p">;</span><span class="w">          </span><span class="c1">// Output stream for the collection</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">  </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxRigidActor</span><span class="o">*</span><span class="w"> </span><span class="n">actor</span><span class="p">;</span><span class="w">                </span><span class="c1">// Any actor</span>

<span class="c1">// Creating shapes in different ways implies different rules for releasing</span>

<span class="c1">// Shape is automatically released when actor gets released</span>
<span class="n">PxShape</span><span class="o">*</span><span class="w"> </span><span class="n">shapeA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxRigidActorExt</span><span class="o">::</span><span class="n">createExclusiveShape</span><span class="p">(</span><span class="o">*</span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="c1">// Shape is either created as &quot;shared&quot; or &quot;exclusive&quot; and needs to be released by</span>
<span class="c1">// the application</span>
<span class="n">PxShape</span><span class="o">*</span><span class="w"> </span><span class="n">shapeB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxGetPhysics</span><span class="p">().</span><span class="n">createShape</span><span class="p">(...);</span>
<span class="n">actor</span><span class="o">-&gt;</span><span class="n">attachShape</span><span class="p">(</span><span class="o">*</span><span class="n">shapeB</span><span class="p">);</span>

<span class="c1">// Create collection with actor and shapes and serialize</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCreateCollection</span><span class="p">();</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">actor</span><span class="p">);</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">shapeA</span><span class="p">);</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">shapeB</span><span class="p">);</span>
<span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToBinary</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">collection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

<span class="c1">// Releasing actors and shapes</span>
<span class="n">actor</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span><span class="w">    </span><span class="c1">// Releases actor and shapeA (automatically)</span>
<span class="n">shapeB</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span><span class="w">   </span><span class="c1">// Releases shapeB (necessary since shapeB was created through PxPhysics)</span>

<span class="c1">// Deserialize collection</span>
<span class="p">...</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memory128</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">   </span><span class="c1">// Aligned memory for serialized data</span>
<span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">memory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// Release actors and release ALL shapes (necessary since shape creation history is</span>
<span class="c1">// not preserved across serialization</span>
<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">getNbObjects</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">getObject</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">getConcreteType</span><span class="p">()</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">PxConcreteType</span><span class="o">::</span><span class="no">eRIGID_DYNAMIC</span><span class="p">:</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">PxConcreteType</span><span class="o">::</span><span class="no">eRIGID_STATIC</span><span class="p">:</span>
<span class="w">            </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">PxActor</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">getObject</span><span class="p">(</span><span class="n">i</span><span class="p">)).</span><span class="n">release</span><span class="p">();</span><span class="w">   </span><span class="c1">// Doesn&#39;t release</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w">                                                       </span><span class="c1">// any shapes</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">PxConcreteType</span><span class="o">::</span><span class="no">eSHAPE</span><span class="p">:</span>
<span class="w">            </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">PxShape</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">getObject</span><span class="p">(</span><span class="n">i</span><span class="p">)).</span><span class="n">release</span><span class="p">();</span><span class="w">   </span><span class="c1">// All shapes need to be</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w">                                                       </span><span class="c1">// released explicitly</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a PhysXExtensions function to release all objects within a collection: <em>PxCollectionExt::releaseObjects</em>.</p>
</div>
</section>
<section id="reconnecting-physx-and-application-objects">
<h3>Reconnecting PhysX and Application-Objects<a class="headerlink" href="#reconnecting-physx-and-application-objects" title="Link to this heading">#</a></h3>
<p>Here is an example of how to fix up references with application objects by querying the IDs of a collection:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxPhysics</span><span class="o">*</span><span class="w"> </span><span class="n">physics</span><span class="p">;</span><span class="w">                     </span><span class="c1">// The physics SDK object</span>
<span class="n">PxCookingParams</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">;</span><span class="w">          </span><span class="c1">// Cooking params needed for instantiating objects(RepX)</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">      </span><span class="c1">// Registry for serializable types</span>

<span class="c1">// Deserialize objects along with IDs</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memory128</span><span class="p">;</span><span class="w">                    </span><span class="c1">// Aligned memory containing serialized objects</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">memory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxInputData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">        </span><span class="c1">// Implemented by the application</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">actorInputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">materialCollection</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="c1">// Receive a list of all deserialized IDs</span>
<span class="cp">#define MAX_IDS 100</span>
<span class="n">PxSerialObjectId</span><span class="w"> </span><span class="n">idBuffer</span><span class="p">[</span><span class="n">MAX_IDS</span><span class="p">];</span>
<span class="n">PxU32</span><span class="w"> </span><span class="n">numIds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">getIds</span><span class="p">(</span><span class="n">idBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_IDS</span><span class="p">);</span>

<span class="c1">// iterate over the list to patch up application objects</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">PxU32</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numIds</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PxActor</span><span class="o">*</span><span class="w"> </span><span class="n">actor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collection</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">idBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">is</span><span class="o">&lt;</span><span class="n">PxActor</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">actor</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// this assumes that findAppObjectFromId is able to locate</span>
<span class="w">        </span><span class="c1">// the corresponding application object from a PxSerialObjectId</span>
<span class="w">        </span><span class="n">actor</span><span class="o">-&gt;</span><span class="n">userData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findAppObjectFromId</span><span class="p">(</span><span class="n">idBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively <em>PxCollection::getObjects(…)</em> and <em>PxCollection::getId(PxBase&amp; object)</em> can be used to achieve the same.</p>
</section>
<section id="serializing-everything">
<h3>Serializing Everything<a class="headerlink" href="#serializing-everything" title="Link to this heading">#</a></h3>
<p>PhysX provides two utility functions for serializing the entirety of the PhysX runtime: <em>PxCollectionExt::createCollection(PxPhysics&amp; sdk)</em> and <em>PxCollectionExt::createCollection(PxScene&amp; scene)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxPhysics</span><span class="o">*</span><span class="w"> </span><span class="n">physics</span><span class="p">;</span><span class="w">                 </span><span class="c1">// The physics SDK object</span>
<span class="n">PxScene</span><span class="o">*</span><span class="w"> </span><span class="n">scene</span><span class="p">;</span><span class="w">                     </span><span class="c1">// The physics scene</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">  </span><span class="c1">// Registry for serializable types</span>
<span class="n">PxOutputStream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">outStream</span><span class="p">;</span><span class="w">          </span><span class="c1">// The user stream doing the actual write to disk</span>

<span class="c1">// 1) Create a collection from the set of all objects in the physics SDK that are shareable across</span>
<span class="c1">//    multiple scenes.</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">everythingCollection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCollectionExt</span><span class="o">::</span><span class="n">createCollection</span><span class="p">(</span><span class="o">*</span><span class="n">physics</span><span class="p">);</span>

<span class="c1">// 2) Create a collection from all objects in the scene and add it</span>
<span class="c1">//    to everythingCollection.</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collectionScene</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PxCollectionExt</span><span class="o">::</span><span class="n">createCollection</span><span class="p">(</span><span class="o">*</span><span class="n">scene</span><span class="p">);</span>
<span class="n">everythingCollection</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">collectionScene</span><span class="p">);</span>
<span class="n">collectionScene</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

<span class="c1">// 3) Complete collection</span>
<span class="n">PxSerialization</span><span class="o">::</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="n">everythingCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>

<span class="c1">// 4) serialize collection and release it</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToBinary</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">everythingCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToXml</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">everythingCollection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="n">everythingCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
<p>Deserialization is as previously:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxScene</span><span class="o">*</span><span class="w"> </span><span class="n">scene</span><span class="p">;</span><span class="w">                      </span><span class="c1">// The physics scene</span>
<span class="n">PxCookingParams</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">;</span><span class="w">       </span><span class="c1">// Cooking params needed for instantiating objects by RepX</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">   </span><span class="c1">// Registry for serializable types</span>

<span class="c1">// Binary</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memory128</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">           </span><span class="c1">// a 128-byte aligned buffer previously loaded from disk</span>
<span class="w">                                     </span><span class="c1">// by the user</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">everythingCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromBinary</span><span class="p">(</span><span class="n">memory128</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~Binary</span>

<span class="c1">// RepX - DEPRECATED</span>
<span class="w">    </span><span class="n">PxInputData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w">    </span><span class="c1">// Implemented by the application</span>
<span class="w">    </span><span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">everythingCollection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
<span class="c1">//~RepX</span>

<span class="n">scene</span><span class="o">-&gt;</span><span class="n">addCollection</span><span class="p">(</span><span class="o">*</span><span class="n">everythingCollection</span><span class="p">);</span>
<span class="n">everythingCollection</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="n">registry</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="serializability">
<h3>Serializability<a class="headerlink" href="#serializability" title="Link to this heading">#</a></h3>
<p>This section contains various definitions to describe serializability of a collection. Whether a collection can be successfully serialized and deserialized, optionally given an external references collection, can be queried by calling <em>PxSerialization::isSerializable(…)</em></p>
<section id="requires">
<span id="id2"></span><h4>Requires<a class="headerlink" href="#requires" title="Link to this heading">#</a></h4>
<p>An object <strong>A</strong> requires another object <strong>B</strong> if <strong>A</strong> maintains a reference to <strong>B</strong> that needs to be re-established for successfully deserializing <strong>A</strong>. This implies that <strong>B</strong> needs to be deserialized before <strong>A</strong>.</p>
<p>Here is the table of the relationship <strong>requires</strong> of all PhysX objects:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>joints</strong></p></td>
<td><p>require their <strong>actors</strong> and <strong>constraint</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>rigid actors</strong></p></td>
<td><p>require their <strong>shapes</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>shapes</strong></p></td>
<td><p>require their <strong>materials</strong> and <strong>mesh</strong> (triangle mesh, convex mesh or height field), if any</p></td>
</tr>
<tr class="row-even"><td><p><strong>articulations</strong></p></td>
<td><p>require their <strong>links</strong> and <strong>joints</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>aggregates</strong></p></td>
<td><p>require their <strong>actors</strong></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="subordinate">
<span id="id3"></span><h4>Subordinate<a class="headerlink" href="#subordinate" title="Link to this heading">#</a></h4>
<p>Subordinates are objects that cannot be instantiated without being owned by other objects. An articulation link, for example, can only be instantiated as part of its articulation.</p>
<p>The following three types are <strong>subordinates</strong>:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>articulation links</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>articulation joint</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>constraints</strong></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="complete">
<span id="id4"></span><h4>Complete<a class="headerlink" href="#complete" title="Link to this heading">#</a></h4>
<p>Definition of a complete set:</p>
<p>A set of objects <strong>C</strong> is <strong>complete</strong> if every object <strong>required</strong> by <strong>C</strong> is in <strong>C</strong>.</p>
<p>Definition of a set that is complete relative to another set:</p>
<p>A set of objects <strong>C</strong> is <strong>complete</strong> relative to a set <strong>D</strong> if every object <strong>required</strong> by <strong>C</strong> is in <strong>C</strong> or in <strong>D</strong>. This means that <strong>C</strong> can be deserialized given <strong>D</strong>.</p>
</section>
<section id="serializable">
<span id="id5"></span><h4>Serializable<a class="headerlink" href="#serializable" title="Link to this heading">#</a></h4>
<p>Here is the complete set of requirements on a collection <strong>C</strong> with dependencies to <strong>D</strong> such that <strong>C</strong> can be serialized:</p>
<ul class="simple">
<li><p><strong>C</strong> is complete relative to <strong>D</strong>. (“no dangling references”)</p></li>
<li><p>Every object in <strong>D</strong> required by an object in <strong>C</strong> has a valid ID. (“no unnamed references”)</p></li>
<li><p>Every subordinate object in <strong>C</strong> is required by another object in <strong>C</strong>. (“no orphans”)</p></li>
</ul>
</section>
</section>
<section id="binary-serialization-specifics">
<h3>Binary Serialization Specifics<a class="headerlink" href="#binary-serialization-specifics" title="Link to this heading">#</a></h3>
<p>The following sections describe specific properties of the binary serialization system.</p>
<section id="memory-management">
<h4>Memory Management<a class="headerlink" href="#memory-management" title="Link to this heading">#</a></h4>
<p>Management of memory blocks containing deserialized objects is left to users. It is the user’s responsibility to:</p>
<ul class="simple">
<li><p>allocate the memory block. Note that it must be properly aligned, to a <em>PX_SERIAL_FILE_ALIGN</em> (128) bytes boundary.</p></li>
<li><p>fill the block with serialized data, typically by loading it from disk.</p></li>
<li><p>deallocate the memory block when the objects within have been released by PhysX.</p></li>
</ul>
<p>Although the user owns the memory block, the PhysX runtime owns any deserialized objects it contains. Concretely, calling release() on an object that was created by deserialization will cause its destructor to run, but will not deallocate its memory. If the block is deallocated before the destructors have run for all the objects it contains, the PhysX runtime will likely crash. For more information about how deserialized objects need to be released see <a class="reference internal" href="#deserializereferencecounting"><span class="std std-ref">Reference Counting of Deserialized Objects</span></a>.</p>
</section>
<section id="versioning">
<span id="retargeting"></span><h4>Versioning<a class="headerlink" href="#versioning" title="Link to this heading">#</a></h4>
<p>The binary serialized data is typically specific to the version of the SDK it was produced with. However, a SDK version can load the data of older SDK versions if the binary format didn’t change. This is usually the case with bugfix releases. The global unique identifier PX_BINARY_SERIAL_VERSION is used to version the binary data and is updated for every release with changed format.</p>
</section>
<section id="object-names">
<h4>Object Names<a class="headerlink" href="#object-names" title="Link to this heading">#</a></h4>
<p>Some SDK objects, such as shapes and actors, can be given names using the <em>PxShape::setName()</em> and <em>PxActor::setName()</em> functions. By default these names are not serialized. The ‘exportNames’ parameter of the <em>PxSerialization::serializeCollectionToBinary()</em> can be set to true in order to serialize the names along with the objects.</p>
</section>
</section>
<section id="api-level-serialization-repx-specifics-deprecated">
<h3>API-level Serialization (RepX) Specifics - DEPRECATED<a class="headerlink" href="#api-level-serialization-repx-specifics-deprecated" title="Link to this heading">#</a></h3>
<p>RepX stands for Representation X and is the ASCII-XML serialization format for PhysX 3. As opposed to binary serialization, the RepX XML serialization is not intended to be used in performance critical or memory constrained situations. The following sections describe specifics of the RepX XML serialization system.</p>
<section id="upgrading-repx-data-deprecated">
<h4>Upgrading RepX Data - DEPRECATED<a class="headerlink" href="#upgrading-repx-data-deprecated" title="Link to this heading">#</a></h4>
<p>Upgrading RepX data from an older PhysX version to a newer one is easy. It happens implicitly when deserializing old RepX data with a newer PhysX SDK and re-serializing the resulting PxCollection.</p>
<p>Example for upgrading a RepX stream:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PxPhysics</span><span class="o">*</span><span class="w"> </span><span class="n">physics</span><span class="p">;</span><span class="w">                                       </span><span class="c1">// The physics SDK object (e.g.</span>
<span class="w">                                                          </span><span class="c1">// PhxsX 3.3)</span>
<span class="n">PxCookingParams</span><span class="w"> </span><span class="n">cookingPArams</span><span class="p">;</span><span class="w">                            </span><span class="c1">// Cooking params needed for</span>
<span class="w">                                                          </span><span class="c1">// instantiating objects</span>
<span class="n">PxSerializationRegistry</span><span class="o">*</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">                        </span><span class="c1">// Registry for serializable types</span>

<span class="n">PxDefaultFileInputData</span><span class="w"> </span><span class="nf">inputData</span><span class="p">(</span><span class="n">pathTo30RepXFile</span><span class="p">);</span><span class="w">       </span><span class="c1">//load an older 3.x RepX file</span>
<span class="n">PxCollection</span><span class="o">*</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">PxSerialization</span><span class="o">::</span><span class="n">createCollectionFromXml</span><span class="p">(</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">cookingParams</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>

<span class="n">PxDefaultFileOutputStream</span><span class="w"> </span><span class="nf">outStream</span><span class="p">(</span><span class="n">pathToNewRepXFile</span><span class="p">);</span>
<span class="n">PxSerialization</span><span class="o">::</span><span class="n">serializeCollectionToXml</span><span class="p">(</span><span class="n">outStream</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">collection</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">registry</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="object-names-deprecated">
<h4>Object Names - DEPRECATED<a class="headerlink" href="#object-names-deprecated" title="Link to this heading">#</a></h4>
<p>As opposed to binary serialization, the object names that can be specified with the <em>PxShape::setName()</em> and <em>PxActor::setName()</em> functions, are always included in the serialized format. On deserialization with <em>PxSerialization::createCollectionFromXml(…)</em> the names can be recovered by setting the <em>PxStringTable</em> parameter.</p>
<p>If <em>PxStringTable</em> parameter is set, the names will live within the memory which is allocated by the string table. The string table must not be released unless it can be guaranteed that the names will not be accessed any more.</p>
</section>
<section id="caching-cooked-geometry-data-deprecated">
<span id="cachingcookedgeometrydata"></span><h4>Caching Cooked Geometry Data - DEPRECATED<a class="headerlink" href="#caching-cooked-geometry-data-deprecated" title="Link to this heading">#</a></h4>
<p>In order to facilitate faster instantiation of XML data, it is possible to configure the XML serialization to store the cooked triangle and convex mesh data along with the plain data. The cooked data caching can be enabled by passing a <em>PxCookingParams</em> instance into <em>PxSerialization::serializeCollectionToXml(…)</em>. The cached cooked data is ignored when its format is incompatible with the current SDK version.</p>
</section>
</section>
</section>
<section id="common-use-cases">
<h2>Common Use Cases<a class="headerlink" href="#common-use-cases" title="Link to this heading">#</a></h2>
<p>DEPRECATED:
API-level RepX serialization should be used whenever compatibility and human readability are important. The PhysX plug-ins for the DCC tools 3ds Max and Maya use RepX to export PhysX objects. The resulting RepX files can then be deserialized and loaded into the PhysX runtime.  This is useful for rapid prototyping or for generally loading PhysX assets if performance is not of a big concern.  For quick loading of assets it is better to convert RepX data into binary serialized data.</p>
<p>Binary serialization should be used in performance and memory constrained situations.  The main target use-case is streaming in chunks of a large game level that can’t be loaded into memory at once.  Creating and loading save games is another application that could be optimized by using binary serialization.  PhysX objects in binary format can also be sent over the network to enable efficient game state synchronization.</p>
</section>
<section id="snippet-discussion">
<h2>Snippet Discussion<a class="headerlink" href="#snippet-discussion" title="Link to this heading">#</a></h2>
<p>The following snippets illustrate common operations such as managing collections, serialization, deserialization and re-targeting of binary data.</p>
<section id="snippetserialization">
<h3>SnippetSerialization<a class="headerlink" href="#snippetserialization" title="Link to this heading">#</a></h3>
<p>SnippetSerialization shows binary and XML (deprecated) serialization of a scene with a number of jointed rigid bodies representing a chain.  This is done in a way that allows the instantiation of multiple chains while sharing the shape and the material across all chains. The snippet shows how to create and populate collections, specify IDs to enable resolving dependencies, serialize collections, deserialize collections and add actors to the scene for simulation.</p>
<p>The snippet also shows how to allocate a data block aligned to 128 bytes and demonstrates how to copy binary serialized data into it. It further demonstrates that the data blocks containing the binary deserialized collections must be maintained until the corresponding objects are not needed anymore and have been released.</p>
<figure class="align-center" id="id8">
<a class="reference internal image-reference" href="../_images/Serialization_Snippet.png"><img alt="../_images/Serialization_Snippet.png" src="../_images/Serialization_Snippet.png" style="width: 657.0px; height: 434.0px;" />
</a>
<figcaption>
<p><span class="caption-text">Figure 4: SnippetSerialization</span><a class="headerlink" href="#id8" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="snippetconvert-deprecated">
<h3>SnippetConvert - DEPRECATED<a class="headerlink" href="#snippetconvert-deprecated" title="Link to this heading">#</a></h3>
<p>SnippetConvert illustrates how binary serialized data can be re-targeted from an authoring platform to a runtime platform such as a console.  The snippet is a simple command line tool that can load a binary serialized data file along with meta data files for both source and destination platforms and then output a converted binary data file.  See the snippet’s source documentation for more details on usage.</p>
</section>
<section id="snippetloadcollection">
<h3>SnippetLoadCollection<a class="headerlink" href="#snippetloadcollection" title="Link to this heading">#</a></h3>
<p>SnippetLoadCollection shows how to deserialize serialized collections from either binary or XML format. The snippet is a command line tool that can connect to the PhysX Visual Debugger application and display the content of serialized collection files. See the snippet’s source documentation for more details.</p>
</section>
</section>
<section id="best-practices-troubleshooting">
<h2>Best practices / Troubleshooting<a class="headerlink" href="#best-practices-troubleshooting" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Concurrent simulation and serialization is not supported and leads to undefined behavior.</p></li>
<li><p>If releasing PhysX objects leads to crashes or errors it is possible that the application is releasing some objects twice.  The following two reasons should be considered:  1.) A potential source of error is to release PhysX objects without updating collections referencing these objects.  2.) Shapes that where created through an actor have their application reference automatically released on creation.  If such a shape is serialized and deserialized the creation history will be lost.  It might be convenient to use the extension function <em>PxCollectionExt::releaseObjects</em> because it deals with the different cases as required.  See <a class="reference internal" href="#deserializereferencecounting"><span class="std std-ref">Reference Counting of Deserialized Objects</span></a>.</p></li>
<li><p>If accessing binary deserialized PhysX objects, including accesses during simulation, causes crashes it might be due to the premature release of the memory block that holds the deserialized objects.</p></li>
<li><p>If binary files are too large and/or too slow to load it might be that shared assets have been serialized multiple times. An example of a shared asset might be a mesh that is referenced by multiple shapes.  The solution is to separate shared PhysX objects into a separate collection. See <a class="reference internal" href="#serializingpartialobjectgraphs"><span class="std std-ref">Serializing Incomplete Collections</span></a>.</p></li>
<li><p>If loading PhysX objects from RepX files is too slow two things should be considered: 1.) Could binary serialization be used instead? Even for debugging it might make sense to convert RepX files into binary serialized data by re-serializing them with the binary approach. 2.) Meshes tend to load very slowly from text files. RepX serialization offers an option to cache cooked mesh data by in-lining binary data into the RepX file. If such a cache is present and valid, the loading can become significantly faster. See <a class="reference internal" href="#cachingcookedgeometrydata"><span class="std std-ref">Caching Cooked Geometry Data - DEPRECATED</span></a>.</p></li>
</ul>
</section>
<section id="pvd-deprecated">
<span id="pvd"></span><h2>PVD - DEPRECATED<a class="headerlink" href="#pvd-deprecated" title="Link to this heading">#</a></h2>
<p>The PhysX Remote Debugger provides the functionality to export single frames of PhysX scenes as RepX files. The resulting files can be used to playback a snapshot of the PhysX state.  In many cases this is sufficient to isolate an issue. The option can be found in the menu of PVD:
[Menu &gt; File &gt; Export Current Frame To RepX]</p>
<figure class="align-center" id="id9">
<a class="reference internal image-reference" href="../_images/Serialization_PVD.png"><img alt="../_images/Serialization_PVD.png" src="../_images/Serialization_PVD.png" style="width: 656.0px; height: 431.0px;" />
</a>
<figcaption>
<p><span class="caption-text">Figure 5: RepX Functionality in PVD</span><a class="headerlink" href="#id9" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="Statistics.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Simulation Statistics</p>
      </div>
    </a>
    <a class="right-next"
       href="BestPractices.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Best Practices Guide</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#first-code">First Code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#in-depth-discussion">In-depth Discussion</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#collections">Collections</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#serializing-complete-collections">Serializing Complete Collections</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#serializing-incomplete-collections">Serializing Incomplete Collections</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reference-counting-of-deserialized-objects">Reference Counting of Deserialized Objects</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reconnecting-physx-and-application-objects">Reconnecting PhysX and Application-Objects</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#serializing-everything">Serializing Everything</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#serializability">Serializability</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#requires">Requires</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#subordinate">Subordinate</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#complete">Complete</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#serializable">Serializable</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-serialization-specifics">Binary Serialization Specifics</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-management">Memory Management</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#versioning">Versioning</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#object-names">Object Names</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#api-level-serialization-repx-specifics-deprecated">API-level Serialization (RepX) Specifics - DEPRECATED</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#upgrading-repx-data-deprecated">Upgrading RepX Data - DEPRECATED</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#object-names-deprecated">Object Names - DEPRECATED</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#caching-cooked-geometry-data-deprecated">Caching Cooked Geometry Data - DEPRECATED</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#common-use-cases">Common Use Cases</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#snippet-discussion">Snippet Discussion</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#snippetserialization">SnippetSerialization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#snippetconvert-deprecated">SnippetConvert - DEPRECATED</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#snippetloadcollection">SnippetLoadCollection</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#best-practices-troubleshooting">Best practices / Troubleshooting</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pvd-deprecated">PVD - DEPRECATED</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
<a class="footer-brand logo" href="https://www.nvidia.com">
  <img src="../_static/nvidia-logo-horiz-rgb-1c-blk-for-screen.svg" class="logo__image only-light" alt="NVIDIA"/>
  <img src="../_static/nvidia-logo-horiz-rgb-1c-wht-for-screen.svg" class="logo__image only-dark" alt="NVIDIA"/>
</a></div>
      
        <div class="footer-item">



  <p class="copyright">
    
      Copyright © 2022-2025, NVIDIA Corporation.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item"><p class="last-updated">
  Last updated on Jul 22, 2025.
  <br/>
</p></div>
      
    </div>
  
  
  
</div>

  </footer>
  </body>
</html>