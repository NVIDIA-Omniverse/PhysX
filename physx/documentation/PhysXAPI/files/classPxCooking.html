<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PxCooking Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PhysXLogoBlack.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classPxCooking.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classPxCooking-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxCooking Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__cooking.html">Cooking</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides methods to cook (where cooking means to prepare the data and convert it to the right format potentially including the construction of acceleration structures and other support data) all kind of simulation data.  
 <a href="classPxCooking.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxCooking_8h_source.html">PxCooking.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf1f0cfa4c76ccbe42e84af17a90fb3e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#acf1f0cfa4c76ccbe42e84af17a90fb3e">release</a> ()=0</td></tr>
<tr class="memdesc:acf1f0cfa4c76ccbe42e84af17a90fb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes this instance of the interface.  <a href="#acf1f0cfa4c76ccbe42e84af17a90fb3e">More...</a><br /></td></tr>
<tr class="separator:acf1f0cfa4c76ccbe42e84af17a90fb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebe112057bd03660dd78dee384d5321"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321">setParams</a> (const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;params)=0</td></tr>
<tr class="memdesc:afebe112057bd03660dd78dee384d5321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets cooking parameters.  <a href="#afebe112057bd03660dd78dee384d5321">More...</a><br /></td></tr>
<tr class="separator:afebe112057bd03660dd78dee384d5321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83607708fd1cb2f58a3d758a558f5b28"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a83607708fd1cb2f58a3d758a558f5b28">getParams</a> () const =0</td></tr>
<tr class="memdesc:a83607708fd1cb2f58a3d758a558f5b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets cooking parameters.  <a href="#a83607708fd1cb2f58a3d758a558f5b28">More...</a><br /></td></tr>
<tr class="separator:a83607708fd1cb2f58a3d758a558f5b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e0864b92d51d409f3134cc8f740102"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a82e0864b92d51d409f3134cc8f740102">platformMismatch</a> () const =0</td></tr>
<tr class="memdesc:a82e0864b92d51d409f3134cc8f740102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks endianness is the same between cooking &amp; target platforms.  <a href="#a82e0864b92d51d409f3134cc8f740102">More...</a><br /></td></tr>
<tr class="separator:a82e0864b92d51d409f3134cc8f740102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bea4d23794e1521a0a6cbfa8e62464"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464">cookTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structPxTriangleMeshCookingResult.html#abe8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:a29bea4d23794e1521a0a6cbfa8e62464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a triangle mesh. The results are written to the stream.  <a href="#a29bea4d23794e1521a0a6cbfa8e62464">More...</a><br /></td></tr>
<tr class="separator:a29bea4d23794e1521a0a6cbfa8e62464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8fc39263baf82f0feafde2303c919d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#aed8fc39263baf82f0feafde2303c919d">createTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structPxTriangleMeshCookingResult.html#abe8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:aed8fc39263baf82f0feafde2303c919d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a triangle mesh without going through a stream.  <a href="#aed8fc39263baf82f0feafde2303c919d">More...</a><br /></td></tr>
<tr class="separator:aed8fc39263baf82f0feafde2303c919d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c823a069c67ead8bde7c4ef75c01ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#aa4c823a069c67ead8bde7c4ef75c01ae">createTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:aa4c823a069c67ead8bde7c4ef75c01ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a triangle mesh without going through a stream. Convenience function for standalone objects.  <a href="#aa4c823a069c67ead8bde7c4ef75c01ae">More...</a><br /></td></tr>
<tr class="separator:aa4c823a069c67ead8bde7c4ef75c01ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca9fe3e3bb8b4943d35475f80f37d2e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#afca9fe3e3bb8b4943d35475f80f37d2e">validateTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc) const =0</td></tr>
<tr class="memdesc:afca9fe3e3bb8b4943d35475f80f37d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.  <a href="#afca9fe3e3bb8b4943d35475f80f37d2e">More...</a><br /></td></tr>
<tr class="separator:afca9fe3e3bb8b4943d35475f80f37d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a35687880224ce3e3a2d5c29bf29acf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a7a35687880224ce3e3a2d5c29bf29acf">cookSoftBodyMesh</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classPxSoftBodySimulationDataDesc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:a7a35687880224ce3e3a2d5c29bf29acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a softbody mesh. The results are written to the stream.  <a href="#a7a35687880224ce3e3a2d5c29bf29acf">More...</a><br /></td></tr>
<tr class="separator:a7a35687880224ce3e3a2d5c29bf29acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c1136a67992414409ee9ee3e216187"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a37c1136a67992414409ee9ee3e216187">createSoftBodyMesh</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classPxSoftBodySimulationDataDesc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a37c1136a67992414409ee9ee3e216187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a softbody mesh without going through a stream.  <a href="#a37c1136a67992414409ee9ee3e216187">More...</a><br /></td></tr>
<tr class="separator:a37c1136a67992414409ee9ee3e216187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167b685f8418dd5744403f378d21512d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a167b685f8418dd5744403f378d21512d">createSoftBodyMesh</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classPxSoftBodySimulationDataDesc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc) const</td></tr>
<tr class="memdesc:a167b685f8418dd5744403f378d21512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a softbody mesh without going through a stream. Convenience function for standalone objects.  <a href="#a167b685f8418dd5744403f378d21512d">More...</a><br /></td></tr>
<tr class="separator:a167b685f8418dd5744403f378d21512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06555179e2c785aa57d6ebb3fe2647da"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a06555179e2c785aa57d6ebb3fe2647da">cookTetrahedronMesh</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:a06555179e2c785aa57d6ebb3fe2647da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a tetrahedron mesh. The results are written to the stream.  <a href="#a06555179e2c785aa57d6ebb3fe2647da">More...</a><br /></td></tr>
<tr class="separator:a06555179e2c785aa57d6ebb3fe2647da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4241882e816761a013fc06d6f36d5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a3f4241882e816761a013fc06d6f36d5b">createTetrahedronMesh</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a3f4241882e816761a013fc06d6f36d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a tetrahedron mesh without going through a stream.  <a href="#a3f4241882e816761a013fc06d6f36d5b">More...</a><br /></td></tr>
<tr class="separator:a3f4241882e816761a013fc06d6f36d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54320c2a566e31cc0e7f4914ab506df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#ad54320c2a566e31cc0e7f4914ab506df">createTetrahedronMesh</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc) const</td></tr>
<tr class="memdesc:ad54320c2a566e31cc0e7f4914ab506df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a tetrahedron mesh without going through a stream. Convenience function for standalone objects.  <a href="#ad54320c2a566e31cc0e7f4914ab506df">More...</a><br /></td></tr>
<tr class="separator:ad54320c2a566e31cc0e7f4914ab506df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223657abf123a8f66babb6f39b364c89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxCollisionMeshMappingData.html">PxCollisionMeshMappingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a223657abf123a8f66babb6f39b364c89">computeModelsMapping</a> (<a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;simulationMesh, const <a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;collisionMesh, const <a class="el" href="classPxSoftBodyCollisionData.html">PxSoftBodyCollisionData</a> &amp;collisionData, const <a class="el" href="structPxBoundedData.html">PxBoundedData</a> *vertexToTet=NULL) const =0</td></tr>
<tr class="memdesc:a223657abf123a8f66babb6f39b364c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mapping between collision and simulation mesh.  <a href="#a223657abf123a8f66babb6f39b364c89">More...</a><br /></td></tr>
<tr class="separator:a223657abf123a8f66babb6f39b364c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2381fa090c3eb595f31745d4f12389ce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxCollisionTetrahedronMeshData.html">PxCollisionTetrahedronMeshData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a2381fa090c3eb595f31745d4f12389ce">computeCollisionData</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc) const =0</td></tr>
<tr class="memdesc:a2381fa090c3eb595f31745d4f12389ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes data to accelerate collision detection of tetrahedral meshes.  <a href="#a2381fa090c3eb595f31745d4f12389ce">More...</a><br /></td></tr>
<tr class="separator:a2381fa090c3eb595f31745d4f12389ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8586f6f193f4ca511ee1b09d9db260c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxSimulationTetrahedronMeshData.html">PxSimulationTetrahedronMeshData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a8586f6f193f4ca511ee1b09d9db260c1">computeSimulationData</a> (const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc) const =0</td></tr>
<tr class="memdesc:a8586f6f193f4ca511ee1b09d9db260c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes data to accelerate collision detection of tetrahedral meshes.  <a href="#a8586f6f193f4ca511ee1b09d9db260c1">More...</a><br /></td></tr>
<tr class="separator:a8586f6f193f4ca511ee1b09d9db260c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4df9e9a14ef7f0594446522cb959895"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#aa4df9e9a14ef7f0594446522cb959895">assembleSoftBodyMesh</a> (<a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;simulationMesh, <a class="el" href="classPxSoftBodySimulationData.html">PxSoftBodySimulationData</a> &amp;simulationData, <a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;collisionMesh, <a class="el" href="classPxSoftBodyCollisionData.html">PxSoftBodyCollisionData</a> &amp;collisionData, <a class="el" href="classPxCollisionMeshMappingData.html">PxCollisionMeshMappingData</a> &amp;mappingData, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:aa4df9e9a14ef7f0594446522cb959895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles all data required for softbody simulation.  <a href="#aa4df9e9a14ef7f0594446522cb959895">More...</a><br /></td></tr>
<tr class="separator:aa4df9e9a14ef7f0594446522cb959895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98672a6cac46e364a91932085c067a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#aa98672a6cac46e364a91932085c067a9">assembleSoftBodyMesh</a> (<a class="el" href="classPxSimulationTetrahedronMeshData.html">PxSimulationTetrahedronMeshData</a> &amp;simulationMesh, <a class="el" href="classPxCollisionTetrahedronMeshData.html">PxCollisionTetrahedronMeshData</a> &amp;collisionMesh, <a class="el" href="classPxCollisionMeshMappingData.html">PxCollisionMeshMappingData</a> &amp;mappingData, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:aa98672a6cac46e364a91932085c067a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles all data required for softbody simulation.  <a href="#aa98672a6cac46e364a91932085c067a9">More...</a><br /></td></tr>
<tr class="separator:aa98672a6cac46e364a91932085c067a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8e845a8a4253292aed0ef93177ffa1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1">cookConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structPxConvexMeshCookingResult.html#ac1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:ade8e845a8a4253292aed0ef93177ffa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a convex mesh. The results are written to the stream.  <a href="#ade8e845a8a4253292aed0ef93177ffa1">More...</a><br /></td></tr>
<tr class="separator:ade8e845a8a4253292aed0ef93177ffa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282c2ba36ea6362f18d3033d798e7863"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a282c2ba36ea6362f18d3033d798e7863">createConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structPxConvexMeshCookingResult.html#ac1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:a282c2ba36ea6362f18d3033d798e7863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a convex mesh without going through a stream.  <a href="#a282c2ba36ea6362f18d3033d798e7863">More...</a><br /></td></tr>
<tr class="separator:a282c2ba36ea6362f18d3033d798e7863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4478013fe47d4f9062def8fbcae6defc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a4478013fe47d4f9062def8fbcae6defc">createConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a4478013fe47d4f9062def8fbcae6defc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a convex mesh without going through a stream. Convenience function for standalone objects.  <a href="#a4478013fe47d4f9062def8fbcae6defc">More...</a><br /></td></tr>
<tr class="separator:a4478013fe47d4f9062def8fbcae6defc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8a3c270cc6db602ad250c82c1225bc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#aea8a3c270cc6db602ad250c82c1225bc">validateConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc) const =0</td></tr>
<tr class="memdesc:aea8a3c270cc6db602ad250c82c1225bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.  <a href="#aea8a3c270cc6db602ad250c82c1225bc">More...</a><br /></td></tr>
<tr class="separator:aea8a3c270cc6db602ad250c82c1225bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c77a6b39563de7b2d3736e0aaac85b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a75c77a6b39563de7b2d3736e0aaac85b">computeHullPolygons</a> (const <a class="el" href="classPxSimpleTriangleMesh.html">PxSimpleTriangleMesh</a> &amp;mesh, <a class="el" href="classPxAllocatorCallback.html">PxAllocatorCallback</a> &amp;inCallback, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbVerts, <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> *&amp;vertices, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbIndices, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *&amp;indices, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbPolygons, <a class="el" href="structPxHullPolygon.html">PxHullPolygon</a> *&amp;hullPolygons) const =0</td></tr>
<tr class="memdesc:a75c77a6b39563de7b2d3736e0aaac85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh. ">PxConvexMeshDesc</a> rather than triangles.  <a href="#a75c77a6b39563de7b2d3736e0aaac85b">More...</a><br /></td></tr>
<tr class="separator:a75c77a6b39563de7b2d3736e0aaac85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4f0fe5c9a709cde84338c5bdf7cde4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#abf4f0fe5c9a709cde84338c5bdf7cde4">cookHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:abf4f0fe5c9a709cde84338c5bdf7cde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a heightfield. The results are written to the stream.  <a href="#abf4f0fe5c9a709cde84338c5bdf7cde4">More...</a><br /></td></tr>
<tr class="separator:abf4f0fe5c9a709cde84338c5bdf7cde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84fd602f1ae4bedf4ed0a1019a30566"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#ac84fd602f1ae4bedf4ed0a1019a30566">createHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:ac84fd602f1ae4bedf4ed0a1019a30566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>.  <a href="#ac84fd602f1ae4bedf4ed0a1019a30566">More...</a><br /></td></tr>
<tr class="separator:ac84fd602f1ae4bedf4ed0a1019a30566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2561d597b98591c89e8deb2e80ec4d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxHeightField.html">PxHeightField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a2561d597b98591c89e8deb2e80ec4d94">createHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a2561d597b98591c89e8deb2e80ec4d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. Convenience function for standalone objects.  <a href="#a2561d597b98591c89e8deb2e80ec4d94">More...</a><br /></td></tr>
<tr class="separator:a2561d597b98591c89e8deb2e80ec4d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142cbc47a0cce7eca032e6d40f133937"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a142cbc47a0cce7eca032e6d40f133937">cookBVH</a> (const <a class="el" href="classPxBVHDesc.html">PxBVHDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:a142cbc47a0cce7eca032e6d40f133937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a bounding volume hierarchy. The results are written to the stream.  <a href="#a142cbc47a0cce7eca032e6d40f133937">More...</a><br /></td></tr>
<tr class="separator:a142cbc47a0cce7eca032e6d40f133937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26504bbb31892aa9320aae648d7fa52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gafd8f8779793627061774cfcfa1b9fbd7">PX_DEPRECATED</a> <a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#ab26504bbb31892aa9320aae648d7fa52">cookBVHStructure</a> (const <a class="el" href="group__cooking.html#gadda442a3edfeeeee8bf6ab436be3f6ff">PxBVHStructureDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream) const</td></tr>
<tr class="memdesc:ab26504bbb31892aa9320aae648d7fa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward compatibility helper. Cooks a bounding volume hierarchy. The results are written to the stream.  <a href="#ab26504bbb31892aa9320aae648d7fa52">More...</a><br /></td></tr>
<tr class="separator:ab26504bbb31892aa9320aae648d7fa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d72cd0311c88c0d6d236e62e52d5282"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBVH.html">PxBVH</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a1d72cd0311c88c0d6d236e62e52d5282">createBVH</a> (const <a class="el" href="classPxBVHDesc.html">PxBVHDesc</a> &amp;desc, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a1d72cd0311c88c0d6d236e62e52d5282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a bounding volume hierarchy without going through a stream.  <a href="#a1d72cd0311c88c0d6d236e62e52d5282">More...</a><br /></td></tr>
<tr class="separator:a1d72cd0311c88c0d6d236e62e52d5282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5268b8620b4900797197c0abed05f20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxBVH.html">PxBVH</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a5268b8620b4900797197c0abed05f20a">createBVH</a> (const <a class="el" href="classPxBVHDesc.html">PxBVHDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a5268b8620b4900797197c0abed05f20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a bounding volume hierarchy without going through a stream. Convenience function for standalone objects.  <a href="#a5268b8620b4900797197c0abed05f20a">More...</a><br /></td></tr>
<tr class="separator:a5268b8620b4900797197c0abed05f20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3e70db872c9ae5261440949a1eeca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gafd8f8779793627061774cfcfa1b9fbd7">PX_DEPRECATED</a> <a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__geomutils.html#ga21aa55d2f3876056c7f92b23d7e9b9ad">PxBVHStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a9e3e70db872c9ae5261440949a1eeca7">createBVHStructure</a> (const <a class="el" href="group__cooking.html#gadda442a3edfeeeee8bf6ab436be3f6ff">PxBVHStructureDesc</a> &amp;desc, <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:a9e3e70db872c9ae5261440949a1eeca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward compatibility helper. Cooks and creates a bounding volume hierarchy without going through a stream.  <a href="#a9e3e70db872c9ae5261440949a1eeca7">More...</a><br /></td></tr>
<tr class="separator:a9e3e70db872c9ae5261440949a1eeca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aae719140d45c8a44c3b7f4ba5a3f06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a8aae719140d45c8a44c3b7f4ba5a3f06">getStandaloneInsertionCallback</a> ()=0</td></tr>
<tr class="memdesc:a8aae719140d45c8a44c3b7f4ba5a3f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets standalone object insertion interface.  <a href="#a8aae719140d45c8a44c3b7f4ba5a3f06">More...</a><br /></td></tr>
<tr class="separator:a8aae719140d45c8a44c3b7f4ba5a3f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a22a1e6a4a68af0bb0f6568bb59108938"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#a22a1e6a4a68af0bb0f6568bb59108938">~PxCooking</a> ()</td></tr>
<tr class="separator:a22a1e6a4a68af0bb0f6568bb59108938"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides methods to cook (where cooking means to prepare the data and convert it to the right format potentially including the construction of acceleration structures and other support data) all kind of simulation data. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a22a1e6a4a68af0bb0f6568bb59108938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a1e6a4a68af0bb0f6568bb59108938">&#9670;&nbsp;</a></span>~PxCooking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCooking::~PxCooking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa4df9e9a14ef7f0594446522cb959895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4df9e9a14ef7f0594446522cb959895">&#9670;&nbsp;</a></span>assembleSoftBodyMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a>* PxCooking::assembleSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSoftBodySimulationData.html">PxSoftBodySimulationData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSoftBodyCollisionData.html">PxSoftBodyCollisionData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxCollisionMeshMappingData.html">PxCollisionMeshMappingData</a> &amp;&#160;</td>
          <td class="paramname"><em>mappingData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundles all data required for softbody simulation. </p>
<p>Creates a container that provides everything to create a <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>The geometry (tetrahedral mesh) to be used as simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationData</td><td>Additional non-tetmesh data that contains mass information etc. for the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMesh</td><td>The geometry (tetrahedral mesh) to be used for collision detection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionData</td><td>Additional non-tetmesh data that contains surface information, acceleration structures etc. for the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mappingData</td><td>Mapping that describes how the collision mesh's vertices are embedded into the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxSoftBodyMesh.html" title="A softbody mesh, containing structures to store collision shape, simulation shape and deformation sta...">PxSoftBodyMesh</a> pointer that represents a softbody mesh bundling all data (simulation mesh, collision mesh etc.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> createSoftBody() </dd></dl>

</div>
</div>
<a id="aa98672a6cac46e364a91932085c067a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98672a6cac46e364a91932085c067a9">&#9670;&nbsp;</a></span>assembleSoftBodyMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a>* PxCooking::assembleSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSimulationTetrahedronMeshData.html">PxSimulationTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxCollisionTetrahedronMeshData.html">PxCollisionTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxCollisionMeshMappingData.html">PxCollisionMeshMappingData</a> &amp;&#160;</td>
          <td class="paramname"><em>mappingData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundles all data required for softbody simulation. </p>
<p>Creates a container that provides everything to create a <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>Container that provides all information about the simulation mesh (geometry, mass distribution etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMesh</td><td>Container that provides all information about the collision mesh (geometry, surface information, acceleration structures etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mappingData</td><td>Mapping that describes how the collision mesh's vertices are embedded into the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxSoftBodyMesh.html" title="A softbody mesh, containing structures to store collision shape, simulation shape and deformation sta...">PxSoftBodyMesh</a> pointer that represents a softbody mesh bundling all data (simulation mesh, collision mesh etc.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> createSoftBody() </dd></dl>

</div>
</div>
<a id="a2381fa090c3eb595f31745d4f12389ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2381fa090c3eb595f31745d4f12389ce">&#9670;&nbsp;</a></span>computeCollisionData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxCollisionTetrahedronMeshData.html">PxCollisionTetrahedronMeshData</a>* PxCooking::computeCollisionData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMeshDesc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes data to accelerate collision detection of tetrahedral meshes. </p>
<p>Computes data structures to speed up collision detection with tetrahedral meshes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMeshDesc</td><td>Raw tetrahedral mesh descriptor wich will be used for collision detection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxCollisionTetrahedronMeshData.html" title="Conbines PxTetrahedronMeshData and PxSoftBodyCollisionData. ">PxCollisionTetrahedronMeshData</a> pointer that describes the collision mesh </dd></dl>

</div>
</div>
<a id="a75c77a6b39563de7b2d3736e0aaac85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c77a6b39563de7b2d3736e0aaac85b">&#9670;&nbsp;</a></span>computeHullPolygons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::computeHullPolygons </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxSimpleTriangleMesh.html">PxSimpleTriangleMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxAllocatorCallback.html">PxAllocatorCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>inCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&#160;</td>
          <td class="paramname"><em>nbVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> *&amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&#160;</td>
          <td class="paramname"><em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *&amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&#160;</td>
          <td class="paramname"><em>nbPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHullPolygon.html">PxHullPolygon</a> *&amp;&#160;</td>
          <td class="paramname"><em>hullPolygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh. ">PxConvexMeshDesc</a> rather than triangles. </p>
<p>Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. The output vertices, indices and polygons must be used to construct a hull.</p>
<p>The provided <a class="el" href="classPxAllocatorCallback.html" title="Abstract base class for an application defined memory allocator that can be used by the Nv library...">PxAllocatorCallback</a> does allocate the out array's. It is the user responsibility to deallocated those array's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Simple triangle mesh containing vertices and triangles used to compute polygons. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inCallback</td><td>Memory allocator for out array allocations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nbVerts</td><td>Number of vertices used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>Vertices array used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nbIndices</td><td>Number of indices used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Indices array used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nbPolygons</td><td>Number of created polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hullPolygons</td><td>Polygons array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="group__cooking.html#ga36d3375ae49e62c3842c3fbe0c620651" title="collection of set bits defined in PxConvexFlag. ">PxConvexFlags</a> <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh. ">PxConvexMeshDesc</a> <a class="el" href="classPxSimpleTriangleMesh.html" title="A structure describing a triangle mesh. ">PxSimpleTriangleMesh</a> </dd></dl>

</div>
</div>
<a id="a223657abf123a8f66babb6f39b364c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223657abf123a8f66babb6f39b364c89">&#9670;&nbsp;</a></span>computeModelsMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxCollisionMeshMappingData.html">PxCollisionMeshMappingData</a>* PxCooking::computeModelsMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshData.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSoftBodyCollisionData.html">PxSoftBodyCollisionData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxBoundedData.html">PxBoundedData</a> *&#160;</td>
          <td class="paramname"><em>vertexToTet</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mapping between collision and simulation mesh. </p>
<p>The softbody deformation is computed on the simulation mesh. To deform the collision mesh accordingly it needs to be specified how its vertices need to be placed and updated inside the deformation mesh. This method computes that embedding information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>A tetrahedral mesh that defines the shape of the simulation mesh which is used to compute the body's deformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMesh</td><td>A tetrahedral mesh that defines the shape of the collision mesh which is used for collision detection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionData</td><td>A data container that contains acceleration structures and surface information of the collision mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexToTet</td><td>Optional indices (array of integers) that specifies the index of the tetrahedron in the simulation mesh that contains a collision mesh vertex. If not provided, the embedding will be computed internally. If the simulation mesh is obtained from <a class="el" href="classPxTetMaker.html#a152ef2d2547fb78b28cf8f7bfbf971f5" title="Create voxel-based tetrahedron mesh using TetMaker. ">PxTetMaker::createVoxelTetrahedronMesh</a>, then the vertexToTet map createVoxelTetrahedronMesh returned should be used here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxCollisionMeshMappingData.html" title="Contains information about how to update the collision mesh&#39;s vertices given a deformed simulation te...">PxCollisionMeshMappingData</a> pointer that describes how the collision mesh is embedded into the simulation mesh</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxTetMaker.html#a152ef2d2547fb78b28cf8f7bfbf971f5" title="Create voxel-based tetrahedron mesh using TetMaker. ">PxTetMaker::createVoxelTetrahedronMesh</a> </dd></dl>

</div>
</div>
<a id="a8586f6f193f4ca511ee1b09d9db260c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8586f6f193f4ca511ee1b09d9db260c1">&#9670;&nbsp;</a></span>computeSimulationData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSimulationTetrahedronMeshData.html">PxSimulationTetrahedronMeshData</a>* PxCooking::computeSimulationData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMeshDesc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes data to accelerate collision detection of tetrahedral meshes. </p>
<p>Computes data to compute and store a softbody's deformation using FEM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMeshDesc</td><td>Raw tetrahedral mesh descriptor wich will be used for FEM simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxSimulationTetrahedronMeshData.html" title="Conbines PxTetrahedronMeshData and PxSoftBodyCollisionData. ">PxSimulationTetrahedronMeshData</a> pointer that describes the simulation mesh </dd></dl>

</div>
</div>
<a id="a142cbc47a0cce7eca032e6d40f133937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142cbc47a0cce7eca032e6d40f133937">&#9670;&nbsp;</a></span>cookBVH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookBVH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBVHDesc.html">PxBVHDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a bounding volume hierarchy. The results are written to the stream. </p>
<p><a class="el" href="classPxCooking.html#a142cbc47a0cce7eca032e6d40f133937" title="Cooks a bounding volume hierarchy. The results are written to the stream. ">cookBVH()</a> allows a BVH description to be cooked into a binary stream suitable for loading and performing BVH detection at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The BVH descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxBVH.html" title="Class representing a bounding volume hierarchy. ">PxBVH</a> <a class="el" href="classPxRigidActorExt.html#aa9a87cc3fb664926a444280bfb1ebe43" title="Gets a list of bounds based on shapes in rigid actor. This list can be used to cook/create bounding v...">PxRigidActorExt::getRigidActorShapeLocalBoundsList</a> </dd></dl>

</div>
</div>
<a id="ab26504bbb31892aa9320aae648d7fa52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26504bbb31892aa9320aae648d7fa52">&#9670;&nbsp;</a></span>cookBVHStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gafd8f8779793627061774cfcfa1b9fbd7">PX_DEPRECATED</a> <a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> bool PxCooking::cookBVHStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cooking.html#gadda442a3edfeeeee8bf6ab436be3f6ff">PxBVHStructureDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backward compatibility helper. Cooks a bounding volume hierarchy. The results are written to the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The BVH descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="ade8e845a8a4253292aed0ef93177ffa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8e845a8a4253292aed0ef93177ffa1">&#9670;&nbsp;</a></span>cookConvexMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookConvexMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConvexMeshCookingResult.html#ac1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a convex mesh. The results are written to the stream. </p>
<p>To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.</p>
<p><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<dl class="section note"><dt>Note</dt><dd>The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 255. </dd>
<dd>
If those limits are exceeded in either the user-provided data or the final cooked mesh, an error is reported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from convex mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="structPxConvexMeshCookingResult.html#ac1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> </dd></dl>

</div>
</div>
<a id="abf4f0fe5c9a709cde84338c5bdf7cde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4f0fe5c9a709cde84338c5bdf7cde4">&#9670;&nbsp;</a></span>cookHeightField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookHeightField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a heightfield. The results are written to the stream. </p>
<p>To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.</p>
<p><a class="el" href="classPxCooking.html#abf4f0fe5c9a709cde84338c5bdf7cde4" title="Cooks a heightfield. The results are written to the stream. ">cookHeightField()</a> allows a heightfield description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxPhysics.html#a1806546c22306e8d44b7ff7719fbcc99" title="Creates a heightfield object from previously cooked stream. ">PxPhysics.createHeightField()</a> </dd></dl>

</div>
</div>
<a id="a7a35687880224ce3e3a2d5c29bf29acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a35687880224ce3e3a2d5c29bf29acf">&#9670;&nbsp;</a></span>cookSoftBodyMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSoftBodySimulationDataDesc.html">PxSoftBodySimulationDataDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>softbodyDataDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a softbody mesh. The results are written to the stream. </p>
<p>To create a softbody mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection and to store data used during the FEM calculations.</p>
<p><a class="el" href="classPxCooking.html#a7a35687880224ce3e3a2d5c29bf29acf" title="Cooks a softbody mesh. The results are written to the stream. ">cookSoftBodyMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<p>Example</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMeshDesc</td><td>The tetrahedron mesh descriptor to read the simulation mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMeshDesc</td><td>The tetrahedron mesh descriptor to read the collision mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softbodyDataDesc</td><td>The softbody data descriptor to read mapping information from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="structPxTriangleMeshCookingResult.html#abe8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> </dd></dl>

</div>
</div>
<a id="a06555179e2c785aa57d6ebb3fe2647da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06555179e2c785aa57d6ebb3fe2647da">&#9670;&nbsp;</a></span>cookTetrahedronMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookTetrahedronMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>meshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a tetrahedron mesh. The results are written to the stream. </p>
<p>To create a tetrahedron mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.</p>
<p><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<p>Example</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshDesc</td><td>The tetrahedron mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxPhysics.html#a74dd1804487589805f172d951d27d8c2" title="Creates a tetrahedron mesh object. ">PxPhysics.createTetrahedronMesh()</a> </dd></dl>

</div>
</div>
<a id="a29bea4d23794e1521a0a6cbfa8e62464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bea4d23794e1521a0a6cbfa8e62464">&#9670;&nbsp;</a></span>cookTriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxTriangleMeshCookingResult.html#abe8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a triangle mesh. The results are written to the stream. </p>
<p>To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.</p>
<p><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from triangle mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="structPxTriangleMeshCookingResult.html#abe8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> </dd></dl>

</div>
</div>
<a id="a1d72cd0311c88c0d6d236e62e52d5282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d72cd0311c88c0d6d236e62e52d5282">&#9670;&nbsp;</a></span>createBVH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBVH.html">PxBVH</a>* PxCooking::createBVH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBVHDesc.html">PxBVHDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a bounding volume hierarchy without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookBVH, but the produced BVH is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#a696d1f05c8b5f5bbcae4c80713be5d35" title="Gets PxPhysics object insertion interface. ">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classPxCooking.html#a8aae719140d45c8a44c3b7f4ba5a3f06" title="Gets standalone object insertion interface. ">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The BVH descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxBVH.html" title="Class representing a bounding volume hierarchy. ">PxBVH</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a142cbc47a0cce7eca032e6d40f133937" title="Cooks a bounding volume hierarchy. The results are written to the stream. ">cookBVH()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a5268b8620b4900797197c0abed05f20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5268b8620b4900797197c0abed05f20a">&#9670;&nbsp;</a></span>createBVH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxBVH.html">PxBVH</a>* PxCooking::createBVH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBVHDesc.html">PxBVHDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a bounding volume hierarchy without going through a stream. Convenience function for standalone objects. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookBVH, but the produced BVH is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The BVH descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxBVH.html" title="Class representing a bounding volume hierarchy. ">PxBVH</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a142cbc47a0cce7eca032e6d40f133937" title="Cooks a bounding volume hierarchy. The results are written to the stream. ">cookBVH()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a9e3e70db872c9ae5261440949a1eeca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3e70db872c9ae5261440949a1eeca7">&#9670;&nbsp;</a></span>createBVHStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gafd8f8779793627061774cfcfa1b9fbd7">PX_DEPRECATED</a> <a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__geomutils.html#ga21aa55d2f3876056c7f92b23d7e9b9ad">PxBVHStructure</a>* PxCooking::createBVHStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cooking.html#gadda442a3edfeeeee8bf6ab436be3f6ff">PxBVHStructureDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backward compatibility helper. Cooks and creates a bounding volume hierarchy without going through a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The BVH descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxBVH.html" title="Class representing a bounding volume hierarchy. ">PxBVH</a> pointer on success </dd></dl>

</div>
</div>
<a id="a282c2ba36ea6362f18d3033d798e7863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282c2ba36ea6362f18d3033d798e7863">&#9670;&nbsp;</a></span>createConvexMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a>* PxCooking::createConvexMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConvexMeshCookingResult.html#ac1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a convex mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookConvexMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#a696d1f05c8b5f5bbcae4c80713be5d35" title="Gets PxPhysics object insertion interface. ">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classPxCooking.html#a8aae719140d45c8a44c3b7f4ba5a3f06" title="Gets standalone object insertion interface. ">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from convex mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxConvexMesh.html" title="A convex mesh. ">PxConvexMesh</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a4478013fe47d4f9062def8fbcae6defc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4478013fe47d4f9062def8fbcae6defc">&#9670;&nbsp;</a></span>createConvexMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a>* PxCooking::createConvexMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a convex mesh without going through a stream. Convenience function for standalone objects. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookConvexMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxConvexMesh.html" title="A convex mesh. ">PxConvexMesh</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="ac84fd602f1ae4bedf4ed0a1019a30566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84fd602f1ae4bedf4ed0a1019a30566">&#9670;&nbsp;</a></span>createHeightField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a>* PxCooking::createHeightField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxHeightField.html" title="A height field class. ">PxHeightField</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a2561d597b98591c89e8deb2e80ec4d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2561d597b98591c89e8deb2e80ec4d94">&#9670;&nbsp;</a></span>createHeightField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxHeightField.html">PxHeightField</a>* PxCooking::createHeightField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. Convenience function for standalone objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The heightfield descriptor to read the HF from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxHeightField.html" title="A height field class. ">PxHeightField</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a37c1136a67992414409ee9ee3e216187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c1136a67992414409ee9ee3e216187">&#9670;&nbsp;</a></span>createSoftBodyMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a>* PxCooking::createSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSoftBodySimulationDataDesc.html">PxSoftBodySimulationDataDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>softbodyDataDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a softbody mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookSoftBodyMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#a696d1f05c8b5f5bbcae4c80713be5d35" title="Gets PxPhysics object insertion interface. ">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classPxCooking.html#a8aae719140d45c8a44c3b7f4ba5a3f06" title="Gets standalone object insertion interface. ">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMeshDesc</td><td>The tetrahedron mesh descriptor to read the simulation mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMeshDesc</td><td>The tetrahedron mesh descriptor to read the collision mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softbodyDataDesc</td><td>The softbody data descriptor to read mapping information from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxSoftBodyMesh.html" title="A softbody mesh, containing structures to store collision shape, simulation shape and deformation sta...">PxSoftBodyMesh</a> pointer on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a167b685f8418dd5744403f378d21512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167b685f8418dd5744403f378d21512d">&#9670;&nbsp;</a></span>createSoftBodyMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxSoftBodyMesh.html">PxSoftBodyMesh</a>* PxCooking::createSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSoftBodySimulationDataDesc.html">PxSoftBodySimulationDataDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>softbodyDataDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a softbody mesh without going through a stream. Convenience function for standalone objects. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookSoftBodyMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMeshDesc</td><td>The tetrahedron mesh descriptor to read the simulation mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMeshDesc</td><td>The tetrahedron mesh descriptor to read the collision mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softbodyDataDesc</td><td>The softbody data descriptor to read mapping information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxSoftBodyMesh.html" title="A softbody mesh, containing structures to store collision shape, simulation shape and deformation sta...">PxSoftBodyMesh</a> pointer on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a3f4241882e816761a013fc06d6f36d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4241882e816761a013fc06d6f36d5b">&#9670;&nbsp;</a></span>createTetrahedronMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a>* PxCooking::createTetrahedronMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>meshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a tetrahedron mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookTetrahedronMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#a696d1f05c8b5f5bbcae4c80713be5d35" title="Gets PxPhysics object insertion interface. ">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classPxCooking.html#a8aae719140d45c8a44c3b7f4ba5a3f06" title="Gets standalone object insertion interface. ">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshDesc</td><td>The tetrahedron mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxTetrahedronMesh.html" title="A tetramedron mesh, also called a &#39;tetrahedron soup&#39;. ">PxTetrahedronMesh</a> pointer on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a06555179e2c785aa57d6ebb3fe2647da" title="Cooks a tetrahedron mesh. The results are written to the stream. ">cookTetrahedronMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="ad54320c2a566e31cc0e7f4914ab506df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54320c2a566e31cc0e7f4914ab506df">&#9670;&nbsp;</a></span>createTetrahedronMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a>* PxCooking::createTetrahedronMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTetrahedronMeshDesc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>meshDesc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a tetrahedron mesh without going through a stream. Convenience function for standalone objects. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookTetrahedronMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshDesc</td><td>The tetrahedron mesh descriptor to read the mesh from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxTetrahedronMesh.html" title="A tetramedron mesh, also called a &#39;tetrahedron soup&#39;. ">PxTetrahedronMesh</a> pointer on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a06555179e2c785aa57d6ebb3fe2647da" title="Cooks a tetrahedron mesh. The results are written to the stream. ">cookTetrahedronMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="aed8fc39263baf82f0feafde2303c919d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8fc39263baf82f0feafde2303c919d">&#9670;&nbsp;</a></span>createTriangleMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a>* PxCooking::createTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxTriangleMeshCookingResult.html#abe8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a triangle mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookTriangleMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#a696d1f05c8b5f5bbcae4c80713be5d35" title="Gets PxPhysics object insertion interface. ">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classPxCooking.html#a8aae719140d45c8a44c3b7f4ba5a3f06" title="Gets standalone object insertion interface. ">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from triangle mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;. ">PxTriangleMesh</a> pointer on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="aa4c823a069c67ead8bde7c4ef75c01ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c823a069c67ead8bde7c4ef75c01ae">&#9670;&nbsp;</a></span>createTriangleMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a>* PxCooking::createTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a triangle mesh without going through a stream. Convenience function for standalone objects. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookTriangleMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;. ">PxTriangleMesh</a> pointer on success.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The triangle mesh descriptor to read the mesh from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> <a class="el" href="classPxPhysics.html#a29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object. ">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxInsertionCallback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

</div>
</div>
<a id="a83607708fd1cb2f58a3d758a558f5b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83607708fd1cb2f58a3d758a558f5b28">&#9670;&nbsp;</a></span>getParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structPxCookingParams.html">PxCookingParams</a>&amp; PxCooking::getParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets cooking parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>Current cooking parameters.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxCookingParams.html" title="Structure describing parameters affecting mesh cooking. ">PxCookingParams</a> <a class="el" href="classPxCooking.html#afebe112057bd03660dd78dee384d5321" title="Sets cooking parameters. ">setParams()</a> </dd></dl>

</div>
</div>
<a id="a8aae719140d45c8a44c3b7f4ba5a3f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aae719140d45c8a44c3b7f4ba5a3f06">&#9670;&nbsp;</a></span>getStandaloneInsertionCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxInsertionCallback.html">PxInsertionCallback</a>&amp; PxCooking::getStandaloneInsertionCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets standalone object insertion interface. </p>
<p>This interface allows the creation of standalone objects that can exist without a <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a> or <a class="el" href="classPxScene.html" title="A scene is a collection of bodies and constraints which can interact. ">PxScene</a> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#aed8fc39263baf82f0feafde2303c919d" title="Cooks and creates a triangle mesh without going through a stream. ">PxCooking::createTriangleMesh</a> PxCooking::createHeightfield <a class="el" href="classPxCooking.html#a3f4241882e816761a013fc06d6f36d5b" title="Cooks and creates a tetrahedron mesh without going through a stream. ">PxCooking::createTetrahedronMesh</a> <a class="el" href="classPxCooking.html#a1d72cd0311c88c0d6d236e62e52d5282" title="Cooks and creates a bounding volume hierarchy without going through a stream. ">PxCooking::createBVH</a> </dd></dl>

</div>
</div>
<a id="a82e0864b92d51d409f3134cc8f740102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e0864b92d51d409f3134cc8f740102">&#9670;&nbsp;</a></span>platformMismatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::platformMismatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks endianness is the same between cooking &amp; target platforms. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there is and endian mismatch. </dd></dl>

</div>
</div>
<a id="acf1f0cfa4c76ccbe42e84af17a90fb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1f0cfa4c76ccbe42e84af17a90fb3e">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCooking::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes this instance of the interface. </p>
<p>This function should be called to cleanly shut down the Cooking library before application exit.</p>
<dl class="section note"><dt>Note</dt><dd>This function is required to be called to release foundation usage. </dd></dl>

</div>
</div>
<a id="afebe112057bd03660dd78dee384d5321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebe112057bd03660dd78dee384d5321">&#9670;&nbsp;</a></span>setParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCooking::setParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets cooking parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Cooking parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a83607708fd1cb2f58a3d758a558f5b28" title="Gets cooking parameters. ">getParams()</a> </dd></dl>

</div>
</div>
<a id="aea8a3c270cc6db602ad250c82c1225bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8a3c270cc6db602ad250c82c1225bc">&#9670;&nbsp;</a></span>validateConvexMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::validateConvexMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies if the convex mesh is valid. Prints an error message for each inconsistency found. </p>
<p>The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be used if <a class="el" href="structPxConvexFlag.html#a4b7bd21fa96c72b320a39e880208b4b6a10a876ecefb45e1c7dbaec2afed5c3ad" title="Disables the convex mesh validation to speed-up hull creation. Please use separate validation functio...">PxConvexFlag::eDISABLE_MESH_VALIDATION</a> is planned to be used in release builds.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The convex mesh descriptor to read the mesh from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#ade8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream. ">cookConvexMesh()</a> </dd></dl>

</div>
</div>
<a id="afca9fe3e3bb8b4943d35475f80f37d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca9fe3e3bb8b4943d35475f80f37d2e">&#9670;&nbsp;</a></span>validateTriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::validateTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found. </p>
<p>The following conditions are true for a valid triangle mesh: 1. There are no duplicate vertices (within specified vertexWeldTolerance. See <a class="el" href="structPxCookingParams.html#a19bb7e28765df5c8ec1a86a45004c7b6" title="Mesh weld tolerance. If mesh welding is enabled, this controls the distance at which vertices are wel...">PxCookingParams::meshWeldTolerance</a>) 2. There are no large triangles (within specified <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are calculated in term...">PxTolerancesScale</a>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The triangle mesh descriptor to read the mesh from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCooking.html#a29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream. ">cookTriangleMesh()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxCooking_8h_source.html">PxCooking.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPxCooking.html">PxCooking</a></li>
    <li class="footer">Copyright &copy; 2008-2022 NVIDIA Corporation, 2788 San Tomas Expressway, Santa Clara, CA 95051 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a></li>
  </ul>
</div>
</body>
</html>
