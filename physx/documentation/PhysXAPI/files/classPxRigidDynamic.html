<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PxRigidDynamic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PhysXLogoBlack.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classPxRigidDynamic.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classPxRigidDynamic-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxRigidDynamic Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK. ">PxRigidDynamic</a> represents a dynamic rigid simulation object in the physics SDK.  
 <a href="classPxRigidDynamic.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxRigidDynamic_8h_source.html">PxRigidDynamic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PxRigidDynamic:</div>
<div class="dyncontent">
<div class="center"><img src="classPxRigidDynamic__inherit__graph.png" border="0" usemap="#PxRigidDynamic_inherit__map" alt="Inheritance graph"/></div>
<map name="PxRigidDynamic_inherit__map" id="PxRigidDynamic_inherit__map">
<area shape="rect" id="node2" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. " alt="" coords="16,229,113,256"/>
<area shape="rect" id="node3" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD..." alt="" coords="15,155,114,181"/>
<area shape="rect" id="node4" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. " alt="" coords="30,80,99,107"/>
<area shape="rect" id="node5" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection. " alt="" coords="31,5,99,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for PxRigidDynamic:</div>
<div class="dyncontent">
<div class="center"><img src="classPxRigidDynamic__coll__graph.png" border="0" usemap="#PxRigidDynamic_coll__map" alt="Collaboration graph"/></div>
<map name="PxRigidDynamic_coll__map" id="PxRigidDynamic_coll__map">
<area shape="rect" id="node2" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. " alt="" coords="33,337,131,364"/>
<area shape="rect" id="node3" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD..." alt="" coords="33,261,131,288"/>
<area shape="rect" id="node4" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. " alt="" coords="47,185,117,212"/>
<area shape="rect" id="node5" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection. " alt="" coords="48,109,116,136"/>
<area shape="rect" id="node6" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag\l::Enum, PxU16 \&gt;" alt="" coords="5,5,159,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kinematic Actors</div></td></tr>
<tr class="memitem:a4464d188e7a1e94582c9cf35da9bbc93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a4464d188e7a1e94582c9cf35da9bbc93">setKinematicTarget</a> (const <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> &amp;destination)=0</td></tr>
<tr class="memdesc:a4464d188e7a1e94582c9cf35da9bbc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves kinematically controlled dynamic actors through the game world.  <a href="#a4464d188e7a1e94582c9cf35da9bbc93">More...</a><br /></td></tr>
<tr class="separator:a4464d188e7a1e94582c9cf35da9bbc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6ed86370cfd04958ca7e1c637e310b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a3b6ed86370cfd04958ca7e1c637e310b">getKinematicTarget</a> (<a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> &amp;target) const =0</td></tr>
<tr class="memdesc:a3b6ed86370cfd04958ca7e1c637e310b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target pose of a kinematically controlled dynamic actor.  <a href="#a3b6ed86370cfd04958ca7e1c637e310b">More...</a><br /></td></tr>
<tr class="separator:a3b6ed86370cfd04958ca7e1c637e310b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxRigidBody"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxRigidBody')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxRigidBody.html">PxRigidBody</a></td></tr>
<tr class="memitem:ab152773926fe7b222d61e982c3cb6adf inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf">setCMassLocalPose</a> (const <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> &amp;pose)=0</td></tr>
<tr class="memdesc:ab152773926fe7b222d61e982c3cb6adf inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pose of the center of mass relative to the actor.  <a href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf">More...</a><br /></td></tr>
<tr class="separator:ab152773926fe7b222d61e982c3cb6adf inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdbdab1865112b15201aeabb23877b4 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#aafdbdab1865112b15201aeabb23877b4">getCMassLocalPose</a> () const =0</td></tr>
<tr class="memdesc:aafdbdab1865112b15201aeabb23877b4 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the center of mass pose relative to the actor frame.  <a href="classPxRigidBody.html#aafdbdab1865112b15201aeabb23877b4">More...</a><br /></td></tr>
<tr class="separator:aafdbdab1865112b15201aeabb23877b4 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a697a7a4b9bdd2c83a68e84b9bc3a35 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35">setMass</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> mass)=0</td></tr>
<tr class="memdesc:a8a697a7a4b9bdd2c83a68e84b9bc3a35 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass of a dynamic actor.  <a href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35">More...</a><br /></td></tr>
<tr class="separator:a8a697a7a4b9bdd2c83a68e84b9bc3a35 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1c475ca9cc6aebc168ac58256b7284 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a2b1c475ca9cc6aebc168ac58256b7284">getMass</a> () const =0</td></tr>
<tr class="memdesc:a2b1c475ca9cc6aebc168ac58256b7284 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the mass of the actor.  <a href="classPxRigidBody.html#a2b1c475ca9cc6aebc168ac58256b7284">More...</a><br /></td></tr>
<tr class="separator:a2b1c475ca9cc6aebc168ac58256b7284 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c82bd72a216c0460887cf94184560bd inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a4c82bd72a216c0460887cf94184560bd">getInvMass</a> () const =0</td></tr>
<tr class="memdesc:a4c82bd72a216c0460887cf94184560bd inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the inverse mass of the actor.  <a href="classPxRigidBody.html#a4c82bd72a216c0460887cf94184560bd">More...</a><br /></td></tr>
<tr class="separator:a4c82bd72a216c0460887cf94184560bd inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755d0c8a8d1dd8b29e59d50a6dfda5fd inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd">setMassSpaceInertiaTensor</a> (const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;m)=0</td></tr>
<tr class="memdesc:a755d0c8a8d1dd8b29e59d50a6dfda5fd inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the inertia tensor, using a parameter specified in mass space coordinates.  <a href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd">More...</a><br /></td></tr>
<tr class="separator:a755d0c8a8d1dd8b29e59d50a6dfda5fd inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063cce94190de44d86a15c1b49dd7f71 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a063cce94190de44d86a15c1b49dd7f71">getMassSpaceInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a063cce94190de44d86a15c1b49dd7f71 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  <a href="classPxRigidBody.html#a063cce94190de44d86a15c1b49dd7f71">More...</a><br /></td></tr>
<tr class="separator:a063cce94190de44d86a15c1b49dd7f71 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63830b4cd24cd6e5e9f5bb2d6a1d3dc3 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a63830b4cd24cd6e5e9f5bb2d6a1d3dc3">getMassSpaceInvInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a63830b4cd24cd6e5e9f5bb2d6a1d3dc3 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame.  <a href="classPxRigidBody.html#a63830b4cd24cd6e5e9f5bb2d6a1d3dc3">More...</a><br /></td></tr>
<tr class="separator:a63830b4cd24cd6e5e9f5bb2d6a1d3dc3 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81d09f36de3f2d1984709b559bb74ff inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ac81d09f36de3f2d1984709b559bb74ff">setLinearDamping</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> linDamp)=0</td></tr>
<tr class="memdesc:ac81d09f36de3f2d1984709b559bb74ff inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear damping coefficient.  <a href="classPxRigidBody.html#ac81d09f36de3f2d1984709b559bb74ff">More...</a><br /></td></tr>
<tr class="separator:ac81d09f36de3f2d1984709b559bb74ff inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb785dde2e8e0954db807c7ec69a26 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ad7fb785dde2e8e0954db807c7ec69a26">getLinearDamping</a> () const =0</td></tr>
<tr class="memdesc:ad7fb785dde2e8e0954db807c7ec69a26 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear damping coefficient.  <a href="classPxRigidBody.html#ad7fb785dde2e8e0954db807c7ec69a26">More...</a><br /></td></tr>
<tr class="separator:ad7fb785dde2e8e0954db807c7ec69a26 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8f357ce212cdf05250237073278d0c inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#adb8f357ce212cdf05250237073278d0c">setAngularDamping</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> angDamp)=0</td></tr>
<tr class="memdesc:adb8f357ce212cdf05250237073278d0c inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angular damping coefficient.  <a href="classPxRigidBody.html#adb8f357ce212cdf05250237073278d0c">More...</a><br /></td></tr>
<tr class="separator:adb8f357ce212cdf05250237073278d0c inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffbfa748d3a75e79a13dbca92aaa7ff inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#aaffbfa748d3a75e79a13dbca92aaa7ff">getAngularDamping</a> () const =0</td></tr>
<tr class="memdesc:aaffbfa748d3a75e79a13dbca92aaa7ff inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular damping coefficient.  <a href="classPxRigidBody.html#aaffbfa748d3a75e79a13dbca92aaa7ff">More...</a><br /></td></tr>
<tr class="separator:aaffbfa748d3a75e79a13dbca92aaa7ff inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399c1bb619f89ad1df4400a03a242051 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a399c1bb619f89ad1df4400a03a242051">setMaxLinearVelocity</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> maxLinVel)=0</td></tr>
<tr class="memdesc:a399c1bb619f89ad1df4400a03a242051 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum linear velocity permitted for this actor.  <a href="classPxRigidBody.html#a399c1bb619f89ad1df4400a03a242051">More...</a><br /></td></tr>
<tr class="separator:a399c1bb619f89ad1df4400a03a242051 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f7fee01b5d357fdeb840ee4322c7a4 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a00f7fee01b5d357fdeb840ee4322c7a4">getMaxLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:a00f7fee01b5d357fdeb840ee4322c7a4 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <a href="classPxRigidBody.html#a00f7fee01b5d357fdeb840ee4322c7a4">More...</a><br /></td></tr>
<tr class="separator:a00f7fee01b5d357fdeb840ee4322c7a4 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf8a649186d2b993b0e64d6228706db inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#afdf8a649186d2b993b0e64d6228706db">setMaxAngularVelocity</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> maxAngVel)=0</td></tr>
<tr class="memdesc:afdf8a649186d2b993b0e64d6228706db inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum angular velocity permitted for this actor.  <a href="classPxRigidBody.html#afdf8a649186d2b993b0e64d6228706db">More...</a><br /></td></tr>
<tr class="separator:afdf8a649186d2b993b0e64d6228706db inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052320915132f7d7f72ede4543b64ad inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a8052320915132f7d7f72ede4543b64ad">getMaxAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:a8052320915132f7d7f72ede4543b64ad inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <a href="classPxRigidBody.html#a8052320915132f7d7f72ede4543b64ad">More...</a><br /></td></tr>
<tr class="separator:a8052320915132f7d7f72ede4543b64ad inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b0a1ef0b6c5656a6063c5c38f5679c inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a22b0a1ef0b6c5656a6063c5c38f5679c">addForce</a> (const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;force, <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:a22b0a1ef0b6c5656a6063c5c38f5679c inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass.  <a href="classPxRigidBody.html#a22b0a1ef0b6c5656a6063c5c38f5679c">More...</a><br /></td></tr>
<tr class="separator:a22b0a1ef0b6c5656a6063c5c38f5679c inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb04ffc816d45afff2d04e93d7446e79 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#acb04ffc816d45afff2d04e93d7446e79">addTorque</a> (const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;torque, <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:acb04ffc816d45afff2d04e93d7446e79 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the actor.  <a href="classPxRigidBody.html#acb04ffc816d45afff2d04e93d7446e79">More...</a><br /></td></tr>
<tr class="separator:acb04ffc816d45afff2d04e93d7446e79 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe5174aa160a07d488de2a18ba61f94 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#aefe5174aa160a07d488de2a18ba61f94">clearForce</a> (<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:aefe5174aa160a07d488de2a18ba61f94 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the accumulated forces (sets the accumulated force back to zero).  <a href="classPxRigidBody.html#aefe5174aa160a07d488de2a18ba61f94">More...</a><br /></td></tr>
<tr class="separator:aefe5174aa160a07d488de2a18ba61f94 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae251132385cc0b082b612d709aa4375d inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ae251132385cc0b082b612d709aa4375d">clearTorque</a> (<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:ae251132385cc0b082b612d709aa4375d inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the impulsive torque defined in the global coordinate frame to the actor.  <a href="classPxRigidBody.html#ae251132385cc0b082b612d709aa4375d">More...</a><br /></td></tr>
<tr class="separator:ae251132385cc0b082b612d709aa4375d inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cf856d4059ff6b422b2c58f91d242f inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ae1cf856d4059ff6b422b2c58f91d242f">setForceAndTorque</a> (const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;force, const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;torque, <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:ae1cf856d4059ff6b422b2c58f91d242f inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the impulsive force and torque defined in the global coordinate frame to the actor.  <a href="classPxRigidBody.html#ae1cf856d4059ff6b422b2c58f91d242f">More...</a><br /></td></tr>
<tr class="separator:ae1cf856d4059ff6b422b2c58f91d242f inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b23b890404b1010bf0b67a225bd22e7 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a9b23b890404b1010bf0b67a225bd22e7">setRigidBodyFlag</a> (<a class="el" href="structPxRigidBodyFlag.html#a5fd4878ae66a98c030a9d976e8ba8596">PxRigidBodyFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:a9b23b890404b1010bf0b67a225bd22e7 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular rigid body flag.  <a href="classPxRigidBody.html#a9b23b890404b1010bf0b67a225bd22e7">More...</a><br /></td></tr>
<tr class="separator:a9b23b890404b1010bf0b67a225bd22e7 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6f3afd71605e037a5de47955d941e0 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a9e6f3afd71605e037a5de47955d941e0">setRigidBodyFlags</a> (<a class="el" href="group__physics.html#ga0759d7f23b4fa7e24cd69c51d3efe5bf">PxRigidBodyFlags</a> inFlags)=0</td></tr>
<tr class="separator:a9e6f3afd71605e037a5de47955d941e0 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef3c66318db72f2dd2c1b0d20513f18 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#ga0759d7f23b4fa7e24cd69c51d3efe5bf">PxRigidBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a2ef3c66318db72f2dd2c1b0d20513f18">getRigidBodyFlags</a> () const =0</td></tr>
<tr class="memdesc:a2ef3c66318db72f2dd2c1b0d20513f18 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> flags.  <a href="classPxRigidBody.html#a2ef3c66318db72f2dd2c1b0d20513f18">More...</a><br /></td></tr>
<tr class="separator:a2ef3c66318db72f2dd2c1b0d20513f18 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f4fe582726801cb09c2381de0c144d inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ac6f4fe582726801cb09c2381de0c144d">setMinCCDAdvanceCoefficient</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> advanceCoefficient)=0</td></tr>
<tr class="memdesc:ac6f4fe582726801cb09c2381de0c144d inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CCD minimum advance coefficient.  <a href="classPxRigidBody.html#ac6f4fe582726801cb09c2381de0c144d">More...</a><br /></td></tr>
<tr class="separator:ac6f4fe582726801cb09c2381de0c144d inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae787a717c8468dbf67345dde14ba85 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#abae787a717c8468dbf67345dde14ba85">getMinCCDAdvanceCoefficient</a> () const =0</td></tr>
<tr class="memdesc:abae787a717c8468dbf67345dde14ba85 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CCD minimum advance coefficient.  <a href="classPxRigidBody.html#abae787a717c8468dbf67345dde14ba85">More...</a><br /></td></tr>
<tr class="separator:abae787a717c8468dbf67345dde14ba85 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ce18fdc6cb81c0bfb46590db0867d inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a261ce18fdc6cb81c0bfb46590db0867d">setMaxDepenetrationVelocity</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> biasClamp)=0</td></tr>
<tr class="memdesc:a261ce18fdc6cb81c0bfb46590db0867d inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <a href="classPxRigidBody.html#a261ce18fdc6cb81c0bfb46590db0867d">More...</a><br /></td></tr>
<tr class="separator:a261ce18fdc6cb81c0bfb46590db0867d inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3304d26a39bbdd99dc0ad51d1d99aec4 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a3304d26a39bbdd99dc0ad51d1d99aec4">getMaxDepenetrationVelocity</a> () const =0</td></tr>
<tr class="memdesc:a3304d26a39bbdd99dc0ad51d1d99aec4 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <a href="classPxRigidBody.html#a3304d26a39bbdd99dc0ad51d1d99aec4">More...</a><br /></td></tr>
<tr class="separator:a3304d26a39bbdd99dc0ad51d1d99aec4 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3bbe100e644995742f80f19ea8f250 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a1a3bbe100e644995742f80f19ea8f250">setMaxContactImpulse</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> maxImpulse)=0</td></tr>
<tr class="memdesc:a1a3bbe100e644995742f80f19ea8f250 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body.  <a href="classPxRigidBody.html#a1a3bbe100e644995742f80f19ea8f250">More...</a><br /></td></tr>
<tr class="separator:a1a3bbe100e644995742f80f19ea8f250 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9e9e7946ab265013229612aad4c3c7 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a2f9e9e7946ab265013229612aad4c3c7">getMaxContactImpulse</a> () const =0</td></tr>
<tr class="memdesc:a2f9e9e7946ab265013229612aad4c3c7 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum impulse that may be applied at a contact.  <a href="classPxRigidBody.html#a2f9e9e7946ab265013229612aad4c3c7">More...</a><br /></td></tr>
<tr class="separator:a2f9e9e7946ab265013229612aad4c3c7 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3135b38a6e599e1fc411e3d56531e4 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#acb3135b38a6e599e1fc411e3d56531e4">setContactSlopCoefficient</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> slopCoefficient)=0</td></tr>
<tr class="memdesc:acb3135b38a6e599e1fc411e3d56531e4 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a distance scale whereby the angular influence of a contact on the normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. Rather than acting as an absolute value, this tolerance is scaled by the ratio rXn.dot(angVel)/normal.dot(linVel) such that contacts that have relatively larger angular velocity than linear normal velocity (e.g. rolling wheels) achieve larger slop values as the angular velocity increases.  <a href="classPxRigidBody.html#acb3135b38a6e599e1fc411e3d56531e4">More...</a><br /></td></tr>
<tr class="separator:acb3135b38a6e599e1fc411e3d56531e4 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fd46f099e84ee4136dcba78afd4eea inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#aa2fd46f099e84ee4136dcba78afd4eea">getContactSlopCoefficient</a> () const =0</td></tr>
<tr class="memdesc:aa2fd46f099e84ee4136dcba78afd4eea inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contact slop coefficient.  <a href="classPxRigidBody.html#aa2fd46f099e84ee4136dcba78afd4eea">More...</a><br /></td></tr>
<tr class="separator:aa2fd46f099e84ee4136dcba78afd4eea inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305476b788921e57c35235c44acac521 inherit pub_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxNodeIndex.html">PxNodeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a305476b788921e57c35235c44acac521">getInternalIslandNodeIndex</a> () const =0</td></tr>
<tr class="memdesc:a305476b788921e57c35235c44acac521 inherit pub_methods_classPxRigidBody"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the island node index.  <a href="classPxRigidBody.html#a305476b788921e57c35235c44acac521">More...</a><br /></td></tr>
<tr class="separator:a305476b788921e57c35235c44acac521 inherit pub_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxRigidActor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxRigidActor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxRigidActor.html">PxRigidActor</a></td></tr>
<tr class="memitem:a1130f92afcba590b04b1e51b86f5377a inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a1130f92afcba590b04b1e51b86f5377a">release</a> ()=0</td></tr>
<tr class="memdesc:a1130f92afcba590b04b1e51b86f5377a inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the rigid actor object.  <a href="classPxRigidActor.html#a1130f92afcba590b04b1e51b86f5377a">More...</a><br /></td></tr>
<tr class="separator:a1130f92afcba590b04b1e51b86f5377a inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc655c9d608a220a645ec17d4ee66dc6 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#abc655c9d608a220a645ec17d4ee66dc6">getInternalActorIndex</a> () const =0</td></tr>
<tr class="memdesc:abc655c9d608a220a645ec17d4ee66dc6 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal actor index.  <a href="classPxRigidActor.html#abc655c9d608a220a645ec17d4ee66dc6">More...</a><br /></td></tr>
<tr class="separator:abc655c9d608a220a645ec17d4ee66dc6 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5e3d590e6087c930f8141d40de722 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a6eb5e3d590e6087c930f8141d40de722">getGlobalPose</a> () const =0</td></tr>
<tr class="memdesc:a6eb5e3d590e6087c930f8141d40de722 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the actors world space transform.  <a href="classPxRigidActor.html#a6eb5e3d590e6087c930f8141d40de722">More...</a><br /></td></tr>
<tr class="separator:a6eb5e3d590e6087c930f8141d40de722 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26994d9594ed9a04bd412bdeb2a55f3e inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a26994d9594ed9a04bd412bdeb2a55f3e">setGlobalPose</a> (const <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> &amp;pose, bool autowake=true)=0</td></tr>
<tr class="memdesc:a26994d9594ed9a04bd412bdeb2a55f3e inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for setting an actor's pose in the world.  <a href="classPxRigidActor.html#a26994d9594ed9a04bd412bdeb2a55f3e">More...</a><br /></td></tr>
<tr class="separator:a26994d9594ed9a04bd412bdeb2a55f3e inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022e098ea67bc8ec87f93c2f18a4db6f inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a022e098ea67bc8ec87f93c2f18a4db6f">attachShape</a> (<a class="el" href="classPxShape.html">PxShape</a> &amp;shape)=0</td></tr>
<tr class="memdesc:a022e098ea67bc8ec87f93c2f18a4db6f inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a shape to an actor.  <a href="classPxRigidActor.html#a022e098ea67bc8ec87f93c2f18a4db6f">More...</a><br /></td></tr>
<tr class="separator:a022e098ea67bc8ec87f93c2f18a4db6f inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467f9dc1517978b8d517936a475d3c4c inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a467f9dc1517978b8d517936a475d3c4c">detachShape</a> (<a class="el" href="classPxShape.html">PxShape</a> &amp;shape, bool wakeOnLostTouch=true)=0</td></tr>
<tr class="memdesc:a467f9dc1517978b8d517936a475d3c4c inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a shape from an actor.  <a href="classPxRigidActor.html#a467f9dc1517978b8d517936a475d3c4c">More...</a><br /></td></tr>
<tr class="separator:a467f9dc1517978b8d517936a475d3c4c inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c3534de94642c5980d29f4c49bc112 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#ae5c3534de94642c5980d29f4c49bc112">getNbShapes</a> () const =0</td></tr>
<tr class="memdesc:ae5c3534de94642c5980d29f4c49bc112 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shapes assigned to the actor.  <a href="classPxRigidActor.html#ae5c3534de94642c5980d29f4c49bc112">More...</a><br /></td></tr>
<tr class="separator:ae5c3534de94642c5980d29f4c49bc112 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ef86619d7a6de688b9ef2b0ad7bcec inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a22ef86619d7a6de688b9ef2b0ad7bcec">getShapes</a> (<a class="el" href="classPxShape.html">PxShape</a> **userBuffer, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>
<tr class="memdesc:a22ef86619d7a6de688b9ef2b0ad7bcec inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the shape pointers belonging to the actor.  <a href="classPxRigidActor.html#a22ef86619d7a6de688b9ef2b0ad7bcec">More...</a><br /></td></tr>
<tr class="separator:a22ef86619d7a6de688b9ef2b0ad7bcec inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad941cfa63351e7ff6095a4afbe2d9172 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#ad941cfa63351e7ff6095a4afbe2d9172">getNbConstraints</a> () const =0</td></tr>
<tr class="memdesc:ad941cfa63351e7ff6095a4afbe2d9172 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraint shaders attached to the actor.  <a href="classPxRigidActor.html#ad941cfa63351e7ff6095a4afbe2d9172">More...</a><br /></td></tr>
<tr class="separator:ad941cfa63351e7ff6095a4afbe2d9172 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88777d5457f87247f5625094eb2be57 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#ac88777d5457f87247f5625094eb2be57">getConstraints</a> (<a class="el" href="classPxConstraint.html">PxConstraint</a> **userBuffer, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>
<tr class="memdesc:ac88777d5457f87247f5625094eb2be57 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the constraint shader pointers belonging to the actor.  <a href="classPxRigidActor.html#ac88777d5457f87247f5625094eb2be57">More...</a><br /></td></tr>
<tr class="separator:ac88777d5457f87247f5625094eb2be57 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxActor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structPxActorType.html#a25c5a270f1f5c1955a00d7554f7688d7">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a76a3489218f85ce9fe3ffb883ba8ce63">getType</a> () const =0</td></tr>
<tr class="memdesc:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <a href="classPxActor.html#a76a3489218f85ce9fe3ffb883ba8ce63">More...</a><br /></td></tr>
<tr class="separator:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxScene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a2bf2e48b1960ef8e4fc1a437473bd7a3">getScene</a> () const =0</td></tr>
<tr class="memdesc:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <a href="classPxActor.html#a2bf2e48b1960ef8e4fc1a437473bd7a3">More...</a><br /></td></tr>
<tr class="separator:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e" title="Retrieves the name string set with setName(). ">getName()</a>.  <a href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758">More...</a><br /></td></tr>
<tr class="separator:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e">getName</a> () const =0</td></tr>
<tr class="memdesc:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758" title="Sets a name string for the object that can be retrieved with getName(). ">setName()</a>.  <a href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e">More...</a><br /></td></tr>
<tr class="separator:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab89ce3ee6d27b580063d131a417721 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#acab89ce3ee6d27b580063d131a417721">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:acab89ce3ee6d27b580063d131a417721 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the actor.  <a href="classPxActor.html#acab89ce3ee6d27b580063d131a417721">More...</a><br /></td></tr>
<tr class="separator:acab89ce3ee6d27b580063d131a417721 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f">setActorFlag</a> (<a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1d">PxActorFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular actor flag.  <a href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f">More...</a><br /></td></tr>
<tr class="separator:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#af60720e190324e8ff36281a2360c6043">setActorFlags</a> (<a class="el" href="group__physics.html#ga468ad85db838378f0c58cfd02a96949b">PxActorFlags</a> inFlags)=0</td></tr>
<tr class="memdesc:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor flags.  <a href="classPxActor.html#af60720e190324e8ff36281a2360c6043">More...</a><br /></td></tr>
<tr class="separator:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#ga468ad85db838378f0c58cfd02a96949b">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#afb92fb228de76bbcd42210d060b558d1">getActorFlags</a> () const =0</td></tr>
<tr class="memdesc:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. ">PxActor</a> flags.  <a href="classPxActor.html#afb92fb228de76bbcd42210d060b558d1">More...</a><br /></td></tr>
<tr class="separator:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a614c46687cf76eb219ce47927fc90824">setDominanceGroup</a> (<a class="el" href="group__physics.html#gaf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> dominanceGroup)=0</td></tr>
<tr class="memdesc:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <a href="classPxActor.html#a614c46687cf76eb219ce47927fc90824">More...</a><br /></td></tr>
<tr class="separator:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#gaf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a24602fee489b3e797ff0f82613eef755">getDominanceGroup</a> () const =0</td></tr>
<tr class="memdesc:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classPxActor.html#a614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier. ">setDominanceGroup()</a>.  <a href="classPxActor.html#a24602fee489b3e797ff0f82613eef755">More...</a><br /></td></tr>
<tr class="separator:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a9bb8613863cf1d73e4d0c0227f25bc6e">setOwnerClient</a> (<a class="el" href="PxClient_8h.html#acb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> inClient)=0</td></tr>
<tr class="memdesc:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner client of an actor.  <a href="classPxActor.html#a9bb8613863cf1d73e4d0c0227f25bc6e">More...</a><br /></td></tr>
<tr class="separator:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="PxClient_8h.html#acb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a660828fb83c91f0ada2ca43e06aa2b35">getOwnerClient</a> () const =0</td></tr>
<tr class="memdesc:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner client that was specified at creation time.  <a href="classPxActor.html#a660828fb83c91f0ada2ca43e06aa2b35">More...</a><br /></td></tr>
<tr class="separator:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#aaedfdd3e9acc77afc2fc0ba51d968876">getAggregate</a> () const =0</td></tr>
<tr class="memdesc:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the aggregate the actor might be a part of.  <a href="classPxActor.html#aaedfdd3e9acc77afc2fc0ba51d968876">More...</a><br /></td></tr>
<tr class="separator:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a4bc720adef86ea68bfb5845f0e104d23">is</a> ()</td></tr>
<tr class="separator:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a85aa50ac0e5670a2be64411fea62b5e3">is</a> () const</td></tr>
<tr class="separator:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#ab4e0691a08e49631dc60014d49c7585f">getConcreteType</a> () const</td></tr>
<tr class="memdesc:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns concrete type of object.  <a href="classPxBase.html#ab4e0691a08e49631dc60014d49c7585f">More...</a><br /></td></tr>
<tr class="separator:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a1dd20bb574075df904e1878f2e771ef9">setBaseFlag</a> (<a class="el" href="structPxBaseFlag.html#ac258de0c7adaa37f81b6ab1b0c86a6ee">PxBaseFlag::Enum</a> flag, bool value)</td></tr>
<tr class="memdesc:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="structPxBaseFlag.html" title="Flags for PxBase. ">PxBaseFlag</a>.  <a href="classPxBase.html#a1dd20bb574075df904e1878f2e771ef9">More...</a><br /></td></tr>
<tr class="separator:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#afb391b692c561df0a54c413785e4ebd0">setBaseFlags</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> inFlags)</td></tr>
<tr class="memdesc:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PxBaseFlags.  <a href="classPxBase.html#afb391b692c561df0a54c413785e4ebd0">More...</a><br /></td></tr>
<tr class="separator:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#ad9b10efae7733ff9c8b8d3b7d90a9a5f">getBaseFlags</a> () const</td></tr>
<tr class="memdesc:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns PxBaseFlags.  <a href="classPxBase.html#ad9b10efae7733ff9c8b8d3b7d90a9a5f">More...</a><br /></td></tr>
<tr class="separator:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a38952fcb80e99f1f5dbf774a75ac2c3d">isReleasable</a> () const</td></tr>
<tr class="memdesc:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the object is subordinate.  <a href="classPxBase.html#a38952fcb80e99f1f5dbf774a75ac2c3d">More...</a><br /></td></tr>
<tr class="separator:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Sleeping</h2></td></tr>
<tr class="memitem:aaf537a84cd9b119ed5f77888c600f2ae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae">isSleeping</a> () const =0</td></tr>
<tr class="memdesc:aaf537a84cd9b119ed5f77888c600f2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this body is sleeping.  <a href="#aaf537a84cd9b119ed5f77888c600f2ae">More...</a><br /></td></tr>
<tr class="separator:aaf537a84cd9b119ed5f77888c600f2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac087213f7360a202eaccfab26e97e644"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#ac087213f7360a202eaccfab26e97e644">setSleepThreshold</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> threshold)=0</td></tr>
<tr class="memdesc:ac087213f7360a202eaccfab26e97e644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.  <a href="#ac087213f7360a202eaccfab26e97e644">More...</a><br /></td></tr>
<tr class="separator:ac087213f7360a202eaccfab26e97e644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0232d5a392e204e6b133fd2ab0879e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a1a0232d5a392e204e6b133fd2ab0879e">getSleepThreshold</a> () const =0</td></tr>
<tr class="memdesc:a1a0232d5a392e204e6b133fd2ab0879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mass-normalized kinetic energy below which an actor may go to sleep.  <a href="#a1a0232d5a392e204e6b133fd2ab0879e">More...</a><br /></td></tr>
<tr class="separator:a1a0232d5a392e204e6b133fd2ab0879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fb22d9402497cffe1b5e54d9ecd62f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a59fb22d9402497cffe1b5e54d9ecd62f">setStabilizationThreshold</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> threshold)=0</td></tr>
<tr class="memdesc:a59fb22d9402497cffe1b5e54d9ecd62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization.  <a href="#a59fb22d9402497cffe1b5e54d9ecd62f">More...</a><br /></td></tr>
<tr class="separator:a59fb22d9402497cffe1b5e54d9ecd62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9d98c9bd3b9ab0be7ce1b3ec4a4574"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a5f9d98c9bd3b9ab0be7ce1b3ec4a4574">getStabilizationThreshold</a> () const =0</td></tr>
<tr class="memdesc:a5f9d98c9bd3b9ab0be7ce1b3ec4a4574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mass-normalized kinetic energy below which an actor may participate in stabilization.  <a href="#a5f9d98c9bd3b9ab0be7ce1b3ec4a4574">More...</a><br /></td></tr>
<tr class="separator:a5f9d98c9bd3b9ab0be7ce1b3ec4a4574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88e055440d6c1cc846e32dbed017345"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#ga5ff75d3f2ba94c58e7f8f928b11ebb8d">PxRigidDynamicLockFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#aa88e055440d6c1cc846e32dbed017345">getRigidDynamicLockFlags</a> () const =0</td></tr>
<tr class="memdesc:aa88e055440d6c1cc846e32dbed017345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK. ">PxRigidDynamic</a> lock flags.  <a href="#aa88e055440d6c1cc846e32dbed017345">More...</a><br /></td></tr>
<tr class="separator:aa88e055440d6c1cc846e32dbed017345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf3e84117da3ec5b499262a3a9f5521"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a7cf3e84117da3ec5b499262a3a9f5521">setRigidDynamicLockFlag</a> (<a class="el" href="structPxRigidDynamicLockFlag.html#ae2e527a7cf32504d4b5c8c6d147280e1">PxRigidDynamicLockFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:a7cf3e84117da3ec5b499262a3a9f5521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular rigid dynamic lock flag.  <a href="#a7cf3e84117da3ec5b499262a3a9f5521">More...</a><br /></td></tr>
<tr class="separator:a7cf3e84117da3ec5b499262a3a9f5521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f9f0dfeae6e7877bcebca80df42c92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a16f9f0dfeae6e7877bcebca80df42c92">setRigidDynamicLockFlags</a> (<a class="el" href="group__physics.html#ga5ff75d3f2ba94c58e7f8f928b11ebb8d">PxRigidDynamicLockFlags</a> flags)=0</td></tr>
<tr class="separator:a16f9f0dfeae6e7877bcebca80df42c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3d6c8cbc844329b9c62990db6ff993"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#abf3d6c8cbc844329b9c62990db6ff993">getLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:abf3d6c8cbc844329b9c62990db6ff993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear velocity of an actor.  <a href="#abf3d6c8cbc844329b9c62990db6ff993">More...</a><br /></td></tr>
<tr class="separator:abf3d6c8cbc844329b9c62990db6ff993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cabe9e277eefd1b8fc28b3d786414a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a16cabe9e277eefd1b8fc28b3d786414a">setLinearVelocity</a> (const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;linVel, bool autowake=true)=0</td></tr>
<tr class="memdesc:a16cabe9e277eefd1b8fc28b3d786414a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear velocity of the actor.  <a href="#a16cabe9e277eefd1b8fc28b3d786414a">More...</a><br /></td></tr>
<tr class="separator:a16cabe9e277eefd1b8fc28b3d786414a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62983a76e973c06882cd51e1950dc5f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a62983a76e973c06882cd51e1950dc5f5">getAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:a62983a76e973c06882cd51e1950dc5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular velocity of the actor.  <a href="#a62983a76e973c06882cd51e1950dc5f5">More...</a><br /></td></tr>
<tr class="separator:a62983a76e973c06882cd51e1950dc5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79b0429d8abcba2c39dbbe4bcaef204"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#ac79b0429d8abcba2c39dbbe4bcaef204">setAngularVelocity</a> (const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;angVel, bool autowake=true)=0</td></tr>
<tr class="memdesc:ac79b0429d8abcba2c39dbbe4bcaef204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angular velocity of the actor.  <a href="#ac79b0429d8abcba2c39dbbe4bcaef204">More...</a><br /></td></tr>
<tr class="separator:ac79b0429d8abcba2c39dbbe4bcaef204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7de8c56c76461555219b2b98d5147a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a0f7de8c56c76461555219b2b98d5147a">setWakeCounter</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> wakeCounterValue)=0</td></tr>
<tr class="memdesc:a0f7de8c56c76461555219b2b98d5147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wake counter for the actor.  <a href="#a0f7de8c56c76461555219b2b98d5147a">More...</a><br /></td></tr>
<tr class="separator:a0f7de8c56c76461555219b2b98d5147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dc31fa470c5f37e3e9683534ad83aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a88dc31fa470c5f37e3e9683534ad83aa">getWakeCounter</a> () const =0</td></tr>
<tr class="memdesc:a88dc31fa470c5f37e3e9683534ad83aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wake counter of the actor.  <a href="#a88dc31fa470c5f37e3e9683534ad83aa">More...</a><br /></td></tr>
<tr class="separator:a88dc31fa470c5f37e3e9683534ad83aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1b9e9f437d8b8f27a6e9c2d9ea22fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd">wakeUp</a> ()=0</td></tr>
<tr class="memdesc:a4f1b9e9f437d8b8f27a6e9c2d9ea22fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up the actor if it is sleeping.  <a href="#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd">More...</a><br /></td></tr>
<tr class="separator:a4f1b9e9f437d8b8f27a6e9c2d9ea22fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae00aa2067a2fe268b999aad04f27c28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#aae00aa2067a2fe268b999aad04f27c28">putToSleep</a> ()=0</td></tr>
<tr class="memdesc:aae00aa2067a2fe268b999aad04f27c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the actor to sleep.  <a href="#aae00aa2067a2fe268b999aad04f27c28">More...</a><br /></td></tr>
<tr class="separator:aae00aa2067a2fe268b999aad04f27c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68d947962bc2d0f8862caaf3e8b304"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#afa68d947962bc2d0f8862caaf3e8b304">setSolverIterationCounts</a> (<a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> minPositionIters, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> minVelocityIters=1)=0</td></tr>
<tr class="memdesc:afa68d947962bc2d0f8862caaf3e8b304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the solver iteration counts for the body.  <a href="#afa68d947962bc2d0f8862caaf3e8b304">More...</a><br /></td></tr>
<tr class="separator:afa68d947962bc2d0f8862caaf3e8b304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcdafcbc0dd5a691d502b2f7b03a7d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a2fcdafcbc0dd5a691d502b2f7b03a7d7">getSolverIterationCounts</a> (<a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;minPositionIters, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;minVelocityIters) const =0</td></tr>
<tr class="memdesc:a2fcdafcbc0dd5a691d502b2f7b03a7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the solver iteration counts.  <a href="#a2fcdafcbc0dd5a691d502b2f7b03a7d7">More...</a><br /></td></tr>
<tr class="separator:a2fcdafcbc0dd5a691d502b2f7b03a7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc91baffa652090e523df5e6627686ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#acc91baffa652090e523df5e6627686ed">getContactReportThreshold</a> () const =0</td></tr>
<tr class="memdesc:acc91baffa652090e523df5e6627686ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the force threshold for contact reports.  <a href="#acc91baffa652090e523df5e6627686ed">More...</a><br /></td></tr>
<tr class="separator:acc91baffa652090e523df5e6627686ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd510964f2287e81fe76a1a9e1725b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#abfd510964f2287e81fe76a1a9e1725b5">setContactReportThreshold</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> threshold)=0</td></tr>
<tr class="memdesc:abfd510964f2287e81fe76a1a9e1725b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the force threshold for contact reports.  <a href="#abfd510964f2287e81fe76a1a9e1725b5">More...</a><br /></td></tr>
<tr class="separator:abfd510964f2287e81fe76a1a9e1725b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43150714d9e16cd056149bad325f0527"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a43150714d9e16cd056149bad325f0527">getConcreteTypeName</a> () const</td></tr>
<tr class="memdesc:a43150714d9e16cd056149bad325f0527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <a href="#a43150714d9e16cd056149bad325f0527">More...</a><br /></td></tr>
<tr class="separator:a43150714d9e16cd056149bad325f0527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21ed0e4e1be20fc975fcd3ceeb4e064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#ab21ed0e4e1be20fc975fcd3ceeb4e064">PxRigidDynamic</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ab21ed0e4e1be20fc975fcd3ceeb4e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e63c1ec6872048e16f7d6b744ec3eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a9e63c1ec6872048e16f7d6b744ec3eef">PxRigidDynamic</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a9e63c1ec6872048e16f7d6b744ec3eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9380b2f317161026b39c6a296ba9e273"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a9380b2f317161026b39c6a296ba9e273">~PxRigidDynamic</a> ()</td></tr>
<tr class="separator:a9380b2f317161026b39c6a296ba9e273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1d23ebdce36455824949be867128d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a2e1d23ebdce36455824949be867128d1">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a2e1d23ebdce36455824949be867128d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="#a2e1d23ebdce36455824949be867128d1">More...</a><br /></td></tr>
<tr class="separator:a2e1d23ebdce36455824949be867128d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classPxActor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ace426ce4cca4de88806beee01eb4b87e">userData</a></td></tr>
<tr class="memdesc:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="classPxActor.html#ace426ce4cca4de88806beee01eb4b87e">More...</a><br /></td></tr>
<tr class="separator:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxRigidBody"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxRigidBody')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxRigidBody.html">PxRigidBody</a></td></tr>
<tr class="memitem:adf18dc769f8d1d3da7760097fa699acb inherit pro_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#adf18dc769f8d1d3da7760097fa699acb">PxRigidBody</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:adf18dc769f8d1d3da7760097fa699acb inherit pro_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d4e7068063768f6029a975ff5d41e4 inherit pro_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a14d4e7068063768f6029a975ff5d41e4">PxRigidBody</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a14d4e7068063768f6029a975ff5d41e4 inherit pro_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ff64730b95c9c36b653ffee707e8a inherit pro_methods_classPxRigidBody"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a229ff64730b95c9c36b653ffee707e8a">~PxRigidBody</a> ()</td></tr>
<tr class="separator:a229ff64730b95c9c36b653ffee707e8a inherit pro_methods_classPxRigidBody"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxRigidActor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxRigidActor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxRigidActor.html">PxRigidActor</a></td></tr>
<tr class="memitem:aea61d8192d25e64cefbbdc5f6d68a39b inherit pro_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#aea61d8192d25e64cefbbdc5f6d68a39b">PxRigidActor</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:aea61d8192d25e64cefbbdc5f6d68a39b inherit pro_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3690608611b90d1efd033e804fd774 inherit pro_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#abc3690608611b90d1efd033e804fd774">PxRigidActor</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:abc3690608611b90d1efd033e804fd774 inherit pro_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa01a5b7ff077d01da077a5c8163609f inherit pro_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#aaa01a5b7ff077d01da077a5c8163609f">~PxRigidActor</a> ()</td></tr>
<tr class="separator:aaa01a5b7ff077d01da077a5c8163609f inherit pro_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxActor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:a05d86747e2fc14c89497fa06c8f0f252 inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a05d86747e2fc14c89497fa06c8f0f252">PxActor</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a05d86747e2fc14c89497fa06c8f0f252 inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1780362a59125a7d22619937b2d7a511 inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a1780362a59125a7d22619937b2d7a511">PxActor</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a1780362a59125a7d22619937b2d7a511 inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c683780b093e7c9348b9e0fd8836d inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ad20c683780b093e7c9348b9e0fd8836d">~PxActor</a> ()</td></tr>
<tr class="separator:ad20c683780b093e7c9348b9e0fd8836d inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a263f1ef821c74058ce9335e06cb842a4">PxBase</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor setting concrete type and base flags.  <a href="classPxBase.html#a263f1ef821c74058ce9335e06cb842a4">More...</a><br /></td></tr>
<tr class="separator:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a58b979202e7382701f74977fe3dd5c6f">PxBase</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor setting base flags.  <a href="classPxBase.html#a58b979202e7382701f74977fe3dd5c6f">More...</a><br /></td></tr>
<tr class="separator:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#adfbf62dc32775b068db1c74c7fd3d982">~PxBase</a> ()</td></tr>
<tr class="memdesc:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classPxBase.html#adfbf62dc32775b068db1c74c7fd3d982">More...</a><br /></td></tr>
<tr class="separator:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a3782ca64c8f12c41443f604e300fc207">typeMatch</a> () const</td></tr>
<tr class="separator:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classPxBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a1abe9d19726e1f8f8e56abeb2269b5d4 inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a1abe9d19726e1f8f8e56abeb2269b5d4">mConcreteType</a></td></tr>
<tr class="separator:a1abe9d19726e1f8f8e56abeb2269b5d4 inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7105f65905ecb9f6f7993ba28b712d inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#aff7105f65905ecb9f6f7993ba28b712d">mBaseFlags</a></td></tr>
<tr class="separator:aff7105f65905ecb9f6f7993ba28b712d inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c4aea9ecffd5106ef27ee9e86a2bb9 inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a75c4aea9ecffd5106ef27ee9e86a2bb9">mBuiltInRefCount</a></td></tr>
<tr class="separator:a75c4aea9ecffd5106ef27ee9e86a2bb9 inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK. ">PxRigidDynamic</a> represents a dynamic rigid simulation object in the physics SDK. </p>
<h3>Creation</h3>
<p>Instances of this class are created by calling <a class="el" href="classPxPhysics.html#a58d338d214918182945c8fcb99325e20" title="Creates a dynamic rigid actor with the specified pose and all other fields initialized to their defau...">PxPhysics::createRigidDynamic()</a> and deleted with <a class="el" href="classPxRigidActor.html#a1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object. ">release()</a>.</p>
<h3>Visualizations</h3>
<ul>
<li><a class="el" href="structPxVisualizationParameter.html#adce8e8a77c144356b0968d2b9f79eb10a71d96779e81c1ac240f4cdd8188c55ec" title="Visualize actor axes. ">PxVisualizationParameter::eACTOR_AXES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#adce8e8a77c144356b0968d2b9f79eb10a3e5a40d8a90d56caa62e6c483e00c9cb" title="Visualize a bodies axes. ">PxVisualizationParameter::eBODY_AXES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#adce8e8a77c144356b0968d2b9f79eb10a8e73c99660d921ad7dc81069ff0b2a3c" title="Visualize a body&#39;s mass axes. ">PxVisualizationParameter::eBODY_MASS_AXES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#adce8e8a77c144356b0968d2b9f79eb10a9e57301b7b1ed3722334f04b9bb6f4bc" title="Visualize the bodies linear velocity. ">PxVisualizationParameter::eBODY_LIN_VELOCITY</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#adce8e8a77c144356b0968d2b9f79eb10a0d326f5ea2be6379999dd3b0e80a0552" title="Visualize the bodies angular velocity. ">PxVisualizationParameter::eBODY_ANG_VELOCITY</a></li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> <a class="el" href="classPxPhysics.html#a58d338d214918182945c8fcb99325e20" title="Creates a dynamic rigid actor with the specified pose and all other fields initialized to their defau...">PxPhysics.createRigidDynamic()</a> <a class="el" href="classPxRigidActor.html#a1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object. ">release()</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab21ed0e4e1be20fc975fcd3ceeb4e064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21ed0e4e1be20fc975fcd3ceeb4e064">&#9670;&nbsp;</a></span>PxRigidDynamic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> PxRigidDynamic::PxRigidDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td>
          <td class="paramname"><em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td>
          <td class="paramname"><em>baseFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e63c1ec6872048e16f7d6b744ec3eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e63c1ec6872048e16f7d6b744ec3eef">&#9670;&nbsp;</a></span>PxRigidDynamic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> PxRigidDynamic::PxRigidDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td>
          <td class="paramname"><em>baseFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9380b2f317161026b39c6a296ba9e273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9380b2f317161026b39c6a296ba9e273">&#9670;&nbsp;</a></span>~PxRigidDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxRigidDynamic::~PxRigidDynamic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a62983a76e973c06882cd51e1950dc5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62983a76e973c06882cd51e1950dc5f5">&#9670;&nbsp;</a></span>getAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> PxRigidDynamic::getAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the angular velocity of the actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classPxScene.html#a698947ec5653ac7a2c466122f393e477" title="Performs collision detection for the scene over elapsedTime. ">PxScene::collide()</a>, in <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints. ">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The angular velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#ac79b0429d8abcba2c39dbbe4bcaef204" title="Sets the angular velocity of the actor. ">PxRigidDynamic.setAngularVelocity()</a> <a class="el" href="classPxRigidDynamic.html#abf3d6c8cbc844329b9c62990db6ff993" title="Retrieves the linear velocity of an actor. ">getLinearVelocity()</a> </dd></dl>

<p>Implements <a class="el" href="classPxRigidBody.html#af91b92d6fcf47103b148337749aa93e0">PxRigidBody</a>.</p>

</div>
</div>
<a id="a43150714d9e16cd056149bad325f0527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43150714d9e16cd056149bad325f0527">&#9670;&nbsp;</a></span>getConcreteTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxRigidDynamic::getConcreteTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string name of dynamic type. </p>
<dl class="section return"><dt>Returns</dt><dd>Class name of most derived type of this object. </dd></dl>

<p>Implements <a class="el" href="classPxBase.html#a67fe206d8897ddce896c371ac8d789a9">PxBase</a>.</p>

</div>
</div>
<a id="acc91baffa652090e523df5e6627686ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc91baffa652090e523df5e6627686ed">&#9670;&nbsp;</a></span>getContactReportThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxRigidDynamic::getContactReportThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the force threshold for contact reports. </p>
<p>The contact report threshold is a force threshold. If the force between two actors exceeds this threshold for either of the two actors, a contact report will be generated according to the contact report threshold flags provided by the filter shader/callback. See <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair. ">PxPairFlag</a>.</p>
<p>The threshold used for a collision between a dynamic actor and the static environment is the threshold of the dynamic actor, and all contacts with static actors are summed to find the total normal force.</p>
<p><b>Default:</b> PX_MAX_F32</p>
<dl class="section return"><dt>Returns</dt><dd>Force threshold for contact reports.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#abfd510964f2287e81fe76a1a9e1725b5" title="Sets the force threshold for contact reports. ">setContactReportThreshold</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair. ">PxPairFlag</a> <a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs. ">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div>
<a id="a3b6ed86370cfd04958ca7e1c637e310b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6ed86370cfd04958ca7e1c637e310b">&#9670;&nbsp;</a></span>getKinematicTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidDynamic::getKinematicTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get target pose of a kinematically controlled dynamic actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>Transform to write the target pose to. Only valid if the method returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the actor is a kinematically controlled dynamic and the target has been set, else False.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a4464d188e7a1e94582c9cf35da9bbc93" title="Moves kinematically controlled dynamic actors through the game world. ">setKinematicTarget()</a> <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#a9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag. ">setRigidBodyFlag()</a> </dd></dl>

</div>
</div>
<a id="abf3d6c8cbc844329b9c62990db6ff993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3d6c8cbc844329b9c62990db6ff993">&#9670;&nbsp;</a></span>getLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> PxRigidDynamic::getLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the linear velocity of an actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classPxScene.html#a698947ec5653ac7a2c466122f393e477" title="Performs collision detection for the scene over elapsedTime. ">PxScene::collide()</a>, in <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints. ">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The linear velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a16cabe9e277eefd1b8fc28b3d786414a" title="Sets the linear velocity of the actor. ">PxRigidDynamic.setLinearVelocity()</a> <a class="el" href="classPxRigidDynamic.html#a62983a76e973c06882cd51e1950dc5f5" title="Retrieves the angular velocity of the actor. ">getAngularVelocity()</a> </dd></dl>

<p>Implements <a class="el" href="classPxRigidBody.html#a04bab22deecb716e2cdd7a64b5cfaee7">PxRigidBody</a>.</p>

</div>
</div>
<a id="aa88e055440d6c1cc846e32dbed017345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88e055440d6c1cc846e32dbed017345">&#9670;&nbsp;</a></span>getRigidDynamicLockFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__physics.html#ga5ff75d3f2ba94c58e7f8f928b11ebb8d">PxRigidDynamicLockFlags</a> PxRigidDynamic::getRigidDynamicLockFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK. ">PxRigidDynamic</a> lock flags. </p>
<p>See the list of flags <a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific axis. ">PxRigidDynamicLockFlag</a></p>
<dl class="section return"><dt>Returns</dt><dd>The values of the PxRigidDynamicLock flags.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific axis. ">PxRigidDynamicLockFlag</a> <a class="el" href="classPxRigidDynamic.html#a7cf3e84117da3ec5b499262a3a9f5521" title="Raises or clears a particular rigid dynamic lock flag. ">setRigidDynamicLockFlag()</a> </dd></dl>

</div>
</div>
<a id="a1a0232d5a392e204e6b133fd2ab0879e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0232d5a392e204e6b133fd2ab0879e">&#9670;&nbsp;</a></span>getSleepThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxRigidDynamic::getSleepThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mass-normalized kinetic energy below which an actor may go to sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>The energy threshold for sleeping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping. ">wakeUp()</a> <a class="el" href="classPxRigidDynamic.html#aae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep. ">putToSleep()</a> <a class="el" href="classPxRigidDynamic.html#ac087213f7360a202eaccfab26e97e644" title="Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep. ">setSleepThreshold()</a> </dd></dl>

</div>
</div>
<a id="a2fcdafcbc0dd5a691d502b2f7b03a7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcdafcbc0dd5a691d502b2f7b03a7d7">&#9670;&nbsp;</a></span>getSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::getSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&#160;</td>
          <td class="paramname"><em>minVelocityIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the solver iteration counts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#afa68d947962bc2d0f8862caaf3e8b304" title="Sets the solver iteration counts for the body. ">setSolverIterationCounts()</a> </dd></dl>

</div>
</div>
<a id="a5f9d98c9bd3b9ab0be7ce1b3ec4a4574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9d98c9bd3b9ab0be7ce1b3ec4a4574">&#9670;&nbsp;</a></span>getStabilizationThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxRigidDynamic::getStabilizationThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mass-normalized kinetic energy below which an actor may participate in stabilization. </p>
<p>Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.</p>
<dl class="section return"><dt>Returns</dt><dd>The energy threshold for participating in stabilization.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a59fb22d9402497cffe1b5e54d9ecd62f" title="Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilizati...">setStabilizationThreshold()</a> <a class="el" href="structPxSceneFlag.html#ab4c347372b4433d34d983da780916c53a909e1cb63ea9c0394e2c2b3a526f47fe" title="Enables additional stabilization pass in solver. ">PxSceneFlag::eENABLE_STABILIZATION</a> </dd></dl>

</div>
</div>
<a id="a88dc31fa470c5f37e3e9683534ad83aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dc31fa470c5f37e3e9683534ad83aa">&#9670;&nbsp;</a></span>getWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxRigidDynamic::getWakeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wake counter of the actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The wake counter of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#a0f7de8c56c76461555219b2b98d5147a" title="Sets the wake counter for the actor. ">setWakeCounter()</a> </dd></dl>

</div>
</div>
<a id="a2e1d23ebdce36455824949be867128d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1d23ebdce36455824949be867128d1">&#9670;&nbsp;</a></span>isKindOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidDynamic::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>superClass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a given type name matches with the type of this instance. </p>

<p>Reimplemented from <a class="el" href="classPxRigidBody.html#a126446a6de640cdc08d339911f826270">PxRigidBody</a>.</p>

<p class="reference">References <a class="el" href="classPxRigidBody.html#a126446a6de640cdc08d339911f826270">PxRigidBody::isKindOf()</a>.</p>

</div>
</div>
<a id="aaf537a84cd9b119ed5f77888c600f2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf537a84cd9b119ed5f77888c600f2ae">&#9670;&nbsp;</a></span>isSleeping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidDynamic::isSleeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this body is sleeping. </p>
<p>When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.</p>
<p>In general, a dynamic rigid actor is guaranteed to be awake if at least one of the following holds:</p>
<ul>
<li>The wake counter is positive (see <a class="el" href="classPxRigidDynamic.html#a0f7de8c56c76461555219b2b98d5147a" title="Sets the wake counter for the actor. ">setWakeCounter()</a>). </li>
<li>The linear or angular velocity is non-zero. </li>
<li>A non-zero force or torque has been applied.</li>
</ul>
<p>If a dynamic rigid actor is sleeping, the following state is guaranteed:</p>
<ul>
<li>The wake counter is zero. </li>
<li>The linear and angular velocity is zero. </li>
<li>There is no force update pending.</li>
</ul>
<p>When an actor gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.</p>
<p>If an actor is asleep after the call to <a class="el" href="classPxScene.html#ab34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> returns, it is guaranteed that the pose of the actor was not changed. You can use this information to avoid updating the transforms of associated objects.</p>
<dl class="section note"><dt>Note</dt><dd>A kinematic actor is asleep unless a target pose has been set (in which case it will stay awake until two consecutive simulation steps without a target pose being set have passed). The wake counter will get set to zero or to the reset value <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a> in the case where a target pose has been set to be consistent with the definitions above.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already.</dd>
<dd>
It is not allowed to use this method while the simulation is running.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the actor is sleeping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping. ">wakeUp()</a> <a class="el" href="classPxRigidDynamic.html#aae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep. ">putToSleep()</a> <a class="el" href="classPxRigidDynamic.html#a1a0232d5a392e204e6b133fd2ab0879e" title="Returns the mass-normalized kinetic energy below which an actor may go to sleep. ">getSleepThreshold()</a> </dd></dl>

</div>
</div>
<a id="aae00aa2067a2fe268b999aad04f27c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae00aa2067a2fe268b999aad04f27c28">&#9670;&nbsp;</a></span>putToSleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::putToSleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the actor to sleep. </p>
<p>The actor will stay asleep during the next simulation step if not touched by another non-sleeping actor.</p>
<dl class="section note"><dt>Note</dt><dd>Any applied force will be cleared and the velocity and the wake counter of the actor will be set to 0.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping. ">wakeUp()</a> </dd></dl>

</div>
</div>
<a id="ac79b0429d8abcba2c39dbbe4bcaef204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79b0429d8abcba2c39dbbe4bcaef204">&#9670;&nbsp;</a></span>setAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>angVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the angular velocity of the actor. </p>
<p>Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.</p>
<p><b>Default:</b> (0.0, 0.0, 0.0)</p>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angVel</td><td>New angular velocity of actor. <b>Range:</b> angular velocity vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Whether to wake the object up if it is asleep. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a62983a76e973c06882cd51e1950dc5f5" title="Retrieves the angular velocity of the actor. ">getAngularVelocity()</a> <a class="el" href="classPxRigidDynamic.html#a16cabe9e277eefd1b8fc28b3d786414a" title="Sets the linear velocity of the actor. ">setLinearVelocity()</a> </dd></dl>

</div>
</div>
<a id="abfd510964f2287e81fe76a1a9e1725b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd510964f2287e81fe76a1a9e1725b5">&#9670;&nbsp;</a></span>setContactReportThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setContactReportThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the force threshold for contact reports. </p>
<p>See <a class="el" href="classPxRigidDynamic.html#acc91baffa652090e523df5e6627686ed" title="Retrieves the force threshold for contact reports. ">getContactReportThreshold()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Force threshold for contact reports. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#acc91baffa652090e523df5e6627686ed" title="Retrieves the force threshold for contact reports. ">getContactReportThreshold</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair. ">PxPairFlag</a> </dd></dl>

</div>
</div>
<a id="a4464d188e7a1e94582c9cf35da9bbc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4464d188e7a1e94582c9cf35da9bbc93">&#9670;&nbsp;</a></span>setKinematicTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setKinematicTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves kinematically controlled dynamic actors through the game world. </p>
<p>You set a dynamic actor to be kinematic using the <a class="el" href="structPxRigidBodyFlag.html#a5fd4878ae66a98c030a9d976e8ba8596abd76e6985e9db78efb7a66148ea4c212" title="Enables kinematic mode for the actor. ">PxRigidBodyFlag::eKINEMATIC</a> flag with <a class="el" href="classPxRigidBody.html#a9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag. ">setRigidBodyFlag()</a>.</p>
<p>The move command will result in a velocity that will move the body into the desired pose. After the move is carried out during a single time step, the velocity is returned to zero. Thus, you must continuously call this in every time step for kinematic actors so that they move along a path.</p>
<p>This function simply stores the move destination until the next simulation step is processed, so consecutive calls will simply overwrite the stored target variable.</p>
<p>The motion is always fully carried out.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping and will set the wake counter to <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>The desired pose for the kinematic actor, in the global frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a3b6ed86370cfd04958ca7e1c637e310b" title="Get target pose of a kinematically controlled dynamic actor. ">getKinematicTarget()</a> <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#a9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag. ">setRigidBodyFlag()</a> </dd></dl>

</div>
</div>
<a id="a16cabe9e277eefd1b8fc28b3d786414a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cabe9e277eefd1b8fc28b3d786414a">&#9670;&nbsp;</a></span>setLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setLinearVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>linVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the linear velocity of the actor. </p>
<p>Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.</p>
<p><b>Default:</b> (0.0, 0.0, 0.0)</p>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linVel</td><td>New linear velocity of actor. <b>Range:</b> velocity vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Whether to wake the object up if it is asleep. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#abf3d6c8cbc844329b9c62990db6ff993" title="Retrieves the linear velocity of an actor. ">getLinearVelocity()</a> <a class="el" href="classPxRigidDynamic.html#ac79b0429d8abcba2c39dbbe4bcaef204" title="Sets the angular velocity of the actor. ">setAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="a7cf3e84117da3ec5b499262a3a9f5521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf3e84117da3ec5b499262a3a9f5521">&#9670;&nbsp;</a></span>setRigidDynamicLockFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setRigidDynamicLockFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxRigidDynamicLockFlag.html#ae2e527a7cf32504d4b5c8c6d147280e1">PxRigidDynamicLockFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raises or clears a particular rigid dynamic lock flag. </p>
<p>See the list of flags <a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific axis. ">PxRigidDynamicLockFlag</a></p>
<p><b>Default:</b> no flags are set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The PxRigidDynamicLockBody flag to raise(set) or clear. See <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new boolean value for the flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific axis. ">PxRigidDynamicLockFlag</a> <a class="el" href="classPxRigidDynamic.html#aa88e055440d6c1cc846e32dbed017345" title="Reads the PxRigidDynamic lock flags. ">getRigidDynamicLockFlags()</a> </dd></dl>

</div>
</div>
<a id="a16f9f0dfeae6e7877bcebca80df42c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f9f0dfeae6e7877bcebca80df42c92">&#9670;&nbsp;</a></span>setRigidDynamicLockFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setRigidDynamicLockFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#ga5ff75d3f2ba94c58e7f8f928b11ebb8d">PxRigidDynamicLockFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac087213f7360a202eaccfab26e97e644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac087213f7360a202eaccfab26e97e644">&#9670;&nbsp;</a></span>setSleepThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setSleepThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep. </p>
<p>Actors whose kinetic energy divided by their mass is below this threshold will be candidates for sleeping.</p>
<p><b>Default:</b> 5e-5f * <a class="el" href="classPxTolerancesScale.html#a629358a15988697feaa85759d5c57e33" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a> * <a class="el" href="classPxTolerancesScale.html#a629358a15988697feaa85759d5c57e33" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Energy below which an actor may go to sleep. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#a1a0232d5a392e204e6b133fd2ab0879e" title="Returns the mass-normalized kinetic energy below which an actor may go to sleep. ">getSleepThreshold()</a> <a class="el" href="classPxRigidDynamic.html#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping. ">wakeUp()</a> <a class="el" href="classPxRigidDynamic.html#aae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep. ">putToSleep()</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are calculated in term...">PxTolerancesScale</a> </dd></dl>

</div>
</div>
<a id="afa68d947962bc2d0f8862caaf3e8b304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa68d947962bc2d0f8862caaf3e8b304">&#9670;&nbsp;</a></span>setSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>minVelocityIters</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the solver iteration counts for the body. </p>
<p>The solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher position iteration count may improve their stability.</p>
<p>If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution.</p>
<p><b>Default:</b> 4 position iterations, 1 velocity iteration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minPositionIters</td><td>Number of position iterations the solver should perform for this body. <b>Range:</b> [1,255] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minVelocityIters</td><td>Number of velocity iterations the solver should perform for this body. <b>Range:</b> [0,255]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a2fcdafcbc0dd5a691d502b2f7b03a7d7" title="Retrieves the solver iteration counts. ">getSolverIterationCounts()</a> </dd></dl>

</div>
</div>
<a id="a59fb22d9402497cffe1b5e54d9ecd62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fb22d9402497cffe1b5e54d9ecd62f">&#9670;&nbsp;</a></span>setStabilizationThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setStabilizationThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization. </p>
<p>Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.</p>
<p>This value has no effect if <a class="el" href="structPxSceneFlag.html#ab4c347372b4433d34d983da780916c53a909e1cb63ea9c0394e2c2b3a526f47fe" title="Enables additional stabilization pass in solver. ">PxSceneFlag::eENABLE_STABILIZATION</a> was not enabled on the <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene. ">PxSceneDesc</a>.</p>
<p><b>Default:</b> 1e-5f * <a class="el" href="classPxTolerancesScale.html#a629358a15988697feaa85759d5c57e33" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a> * <a class="el" href="classPxTolerancesScale.html#a629358a15988697feaa85759d5c57e33" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Energy below which an actor may participate in stabilization. <b>Range:</b> [0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a5f9d98c9bd3b9ab0be7ce1b3ec4a4574" title="Returns the mass-normalized kinetic energy below which an actor may participate in stabilization...">getStabilizationThreshold()</a> <a class="el" href="structPxSceneFlag.html#ab4c347372b4433d34d983da780916c53a909e1cb63ea9c0394e2c2b3a526f47fe" title="Enables additional stabilization pass in solver. ">PxSceneFlag::eENABLE_STABILIZATION</a> </dd></dl>

</div>
</div>
<a id="a0f7de8c56c76461555219b2b98d5147a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7de8c56c76461555219b2b98d5147a">&#9670;&nbsp;</a></span>setWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setWakeCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td>
          <td class="paramname"><em>wakeCounterValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wake counter for the actor. </p>
<p>The wake counter value determines the minimum amount of time until the body can be put to sleep. Please note that a body will not be put to sleep if the energy is above the specified threshold (see <a class="el" href="classPxRigidDynamic.html#ac087213f7360a202eaccfab26e97e644" title="Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep. ">setSleepThreshold()</a>) or if other awake bodies are touching it.</p>
<dl class="section note"><dt>Note</dt><dd>Passing in a positive value will wake the actor up automatically.</dd>
<dd>
It is invalid to use this method for kinematic actors since the wake counter for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a>).</dd>
<dd>
It is invalid to use this method if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<p><b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeCounterValue</td><td>Wake counter value. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#a88dc31fa470c5f37e3e9683534ad83aa" title="Returns the wake counter of the actor. ">getWakeCounter()</a> </dd></dl>

</div>
</div>
<a id="a4f1b9e9f437d8b8f27a6e9c2d9ea22fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd">&#9670;&nbsp;</a></span>wakeUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::wakeUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wakes up the actor if it is sleeping. </p>
<p>The actor will get woken up and might cause other touching actors to wake up as well during the next simulation step.</p>
<dl class="section note"><dt>Note</dt><dd>This will set the wake counter of the actor to the value specified in <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a>.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#aaf537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping. ">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#aae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep. ">putToSleep()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidDynamic_8h_source.html">PxRigidDynamic.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a></li>
    <li class="footer">Copyright &copy; 2008-2022 NVIDIA Corporation, 2788 San Tomas Expressway, Santa Clara, CA 95051 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a></li>
  </ul>
</div>
</body>
</html>
