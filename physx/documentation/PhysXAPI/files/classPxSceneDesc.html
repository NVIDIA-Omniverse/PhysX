<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PxSceneDesc Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PhysXLogoBlack.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classPxSceneDesc.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classPxSceneDesc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxSceneDesc Class Reference<div class="ingroups"><a class="el" href="group__physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Descriptor class for scenes. See <a class="el" href="classPxScene.html" title="A scene is a collection of bodies and constraints which can interact. ">PxScene</a>.  
 <a href="classPxSceneDesc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxSceneDesc_8h_source.html">PxSceneDesc.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PxSceneDesc:</div>
<div class="dyncontent">
<div class="center"><img src="classPxSceneDesc__inherit__graph.png" border="0" usemap="#PxSceneDesc_inherit__map" alt="Inheritance graph"/></div>
<map name="PxSceneDesc_inherit__map" id="PxSceneDesc_inherit__map">
<area shape="rect" id="node2" href="classPxSceneQueryDesc.html" title="Descriptor class for scene query system. See PxSceneQuerySystem. " alt="" coords="5,5,145,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for PxSceneDesc:</div>
<div class="dyncontent">
<div class="center"><img src="classPxSceneDesc__coll__graph.png" border="0" usemap="#PxSceneDesc_coll__map" alt="Collaboration graph"/></div>
<map name="PxSceneDesc_coll__map" id="PxSceneDesc_coll__map">
<area shape="rect" id="node2" href="classPxSceneQueryDesc.html" title="Descriptor class for scene query system. See PxSceneQuerySystem. " alt="" coords="325,15,465,42"/>
<area shape="rect" id="node3" href="classPxCCDContactModifyCallback.html" title="An interface class that the user can implement in order to modify CCD contact constraints. " alt="" coords="296,66,495,93"/>
<area shape="rect" id="node4" href="classPxSceneQuerySystem.html" title="Scene&#45;queries external sub&#45;system for PxScene&#45;based objects. " alt="" coords="318,117,473,143"/>
<area shape="rect" id="node5" href="classPxSceneQuerySystemBase.html" title="Base class for the scene&#45;query system. " alt="" coords="5,117,191,143"/>
<area shape="rect" id="node6" href="structPxgDynamicsMemoryConfig.html" title="Sizes of pre&#45;allocated buffers use for GPU dynamics. " alt="" coords="302,167,489,194"/>
<area shape="rect" id="node7" href="classPxSceneLimits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits are used as a hi..." alt="" coords="340,218,451,245"/>
<area shape="rect" id="node8" href="classPxBounds3.html" title="Class representing 3D range or axis aligned bounding box. " alt="" coords="351,331,440,358"/>
<area shape="rect" id="node9" href="classPxVec3T.html" title="PxVec3T\&lt; float \&gt;" alt="" coords="37,297,159,323"/>
<area shape="rect" id="node10" href="classPxFlags.html" title="Container for bitfield flag variables associated with a specific enum type. " alt="" coords="324,383,467,424"/>
<area shape="rect" id="node12" href="classPxCpuDispatcher.html" title="A CpuDispatcher is responsible for scheduling the execution of tasks passed to it by the SDK..." alt="" coords="334,449,457,475"/>
<area shape="rect" id="node13" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints. " alt="" coords="310,499,481,526"/>
<area shape="rect" id="node14" href="classPxFlags.html" title="PxFlags\&lt; PxSceneFlag\l::Enum, PxU32 \&gt;" alt="" coords="315,551,475,592"/>
<area shape="rect" id="node15" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events. " alt="" coords="305,617,486,643"/>
<area shape="rect" id="node16" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs. " alt="" coords="306,667,485,694"/>
<area shape="rect" id="node17" href="classPxBroadPhaseCallback.html" title="Broad&#45;phase callback to receive broad&#45;phase related events. " alt="" coords="316,718,475,745"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga8c083fd86a8c52ff269aa4dd3407127b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga8c083fd86a8c52ff269aa4dd3407127b">PxSceneDesc</a> (const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;scale)</td></tr>
<tr class="memdesc:ga8c083fd86a8c52ff269aa4dd3407127b"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor sets to default.  <a href="group__physics.html#ga8c083fd86a8c52ff269aa4dd3407127b">More...</a><br /></td></tr>
<tr class="separator:ga8c083fd86a8c52ff269aa4dd3407127b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7375184ba494172fa7677dae44bd9a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gaa7375184ba494172fa7677dae44bd9a8">setToDefault</a> (const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;scale)</td></tr>
<tr class="memdesc:gaa7375184ba494172fa7677dae44bd9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(re)sets the structure to the default.  <a href="group__physics.html#gaa7375184ba494172fa7677dae44bd9a8">More...</a><br /></td></tr>
<tr class="separator:gaa7375184ba494172fa7677dae44bd9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7faafa414d3b4a468091cdaf785a931e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid</a> () const</td></tr>
<tr class="memdesc:ga7faafa414d3b4a468091cdaf785a931e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the descriptor is valid.  <a href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">More...</a><br /></td></tr>
<tr class="separator:ga7faafa414d3b4a468091cdaf785a931e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxSceneQueryDesc"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxSceneQueryDesc')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxSceneQueryDesc.html">PxSceneQueryDesc</a></td></tr>
<tr class="memitem:ga3e333166668ec81d4ef9685f7ae4441e inherit pub_methods_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga3e333166668ec81d4ef9685f7ae4441e">PxSceneQueryDesc</a> ()</td></tr>
<tr class="memdesc:ga3e333166668ec81d4ef9685f7ae4441e inherit pub_methods_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor sets to default.  <a href="group__physics.html#ga3e333166668ec81d4ef9685f7ae4441e">More...</a><br /></td></tr>
<tr class="separator:ga3e333166668ec81d4ef9685f7ae4441e inherit pub_methods_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366fc0b9f67dacef9efae093c8106d1f inherit pub_methods_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga366fc0b9f67dacef9efae093c8106d1f">setToDefault</a> ()</td></tr>
<tr class="memdesc:ga366fc0b9f67dacef9efae093c8106d1f inherit pub_methods_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(re)sets the structure to the default.  <a href="group__physics.html#ga366fc0b9f67dacef9efae093c8106d1f">More...</a><br /></td></tr>
<tr class="separator:ga366fc0b9f67dacef9efae093c8106d1f inherit pub_methods_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa18d940817c60f1b8f4ab8daca515a7 inherit pub_methods_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gafa18d940817c60f1b8f4ab8daca515a7">isValid</a> () const</td></tr>
<tr class="memdesc:gafa18d940817c60f1b8f4ab8daca515a7 inherit pub_methods_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the descriptor is valid.  <a href="group__physics.html#gafa18d940817c60f1b8f4ab8daca515a7">More...</a><br /></td></tr>
<tr class="separator:gafa18d940817c60f1b8f4ab8daca515a7 inherit pub_methods_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9b0de35c38c43b8aeff6e6f29bf0db20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a9b0de35c38c43b8aeff6e6f29bf0db20">gravity</a></td></tr>
<tr class="memdesc:a9b0de35c38c43b8aeff6e6f29bf0db20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gravity vector.  <a href="#a9b0de35c38c43b8aeff6e6f29bf0db20">More...</a><br /></td></tr>
<tr class="separator:a9b0de35c38c43b8aeff6e6f29bf0db20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a00536a56d40fe031de2ced1834941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941">simulationEventCallback</a></td></tr>
<tr class="memdesc:a71a00536a56d40fe031de2ced1834941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible notification callback.  <a href="#a71a00536a56d40fe031de2ced1834941">More...</a><br /></td></tr>
<tr class="separator:a71a00536a56d40fe031de2ced1834941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2000ccfa6287d160b88967769de34b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a2000ccfa6287d160b88967769de34b90">contactModifyCallback</a></td></tr>
<tr class="memdesc:a2000ccfa6287d160b88967769de34b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible asynchronous callback for contact modification.  <a href="#a2000ccfa6287d160b88967769de34b90">More...</a><br /></td></tr>
<tr class="separator:a2000ccfa6287d160b88967769de34b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae577616d3e898347924de90e16188bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#aae577616d3e898347924de90e16188bb">ccdContactModifyCallback</a></td></tr>
<tr class="memdesc:aae577616d3e898347924de90e16188bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible asynchronous callback for contact modification.  <a href="#aae577616d3e898347924de90e16188bb">More...</a><br /></td></tr>
<tr class="separator:aae577616d3e898347924de90e16188bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ceb142127cc259aa2f5d322a1494e2"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ad9ceb142127cc259aa2f5d322a1494e2">filterShaderData</a></td></tr>
<tr class="memdesc:ad9ceb142127cc259aa2f5d322a1494e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared global filter data which will get passed into the filter shader.  <a href="#ad9ceb142127cc259aa2f5d322a1494e2">More...</a><br /></td></tr>
<tr class="separator:ad9ceb142127cc259aa2f5d322a1494e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c03915bbaaa9bdf23925d535c3883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a710c03915bbaaa9bdf23925d535c3883">filterShaderDataSize</a></td></tr>
<tr class="memdesc:a710c03915bbaaa9bdf23925d535c3883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size (in bytes) of the shared global filter data <a class="el" href="classPxSceneDesc.html#ad9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader. ">filterShaderData</a>.  <a href="#a710c03915bbaaa9bdf23925d535c3883">More...</a><br /></td></tr>
<tr class="separator:a710c03915bbaaa9bdf23925d535c3883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9410287c6ea926dad9e2b2374541ad38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33">PxSimulationFilterShader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a9410287c6ea926dad9e2b2374541ad38">filterShader</a></td></tr>
<tr class="memdesc:a9410287c6ea926dad9e2b2374541ad38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The custom filter shader to use for collision filtering.  <a href="#a9410287c6ea926dad9e2b2374541ad38">More...</a><br /></td></tr>
<tr class="separator:a9410287c6ea926dad9e2b2374541ad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b94475075eb9b43ca32650cd169cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#af7b94475075eb9b43ca32650cd169cc1">filterCallback</a></td></tr>
<tr class="memdesc:af7b94475075eb9b43ca32650cd169cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom collision filter callback which can be used to implement more complex filtering operations which need access to the simulation state, for example.  <a href="#af7b94475075eb9b43ca32650cd169cc1">More...</a><br /></td></tr>
<tr class="separator:af7b94475075eb9b43ca32650cd169cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e220df7cb1f25852d4cc62cecd8869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxPairFilteringMode.html#aeaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a90e220df7cb1f25852d4cc62cecd8869">kineKineFilteringMode</a></td></tr>
<tr class="memdesc:a90e220df7cb1f25852d4cc62cecd8869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtering mode for kinematic-kinematic pairs in the broadphase.  <a href="#a90e220df7cb1f25852d4cc62cecd8869">More...</a><br /></td></tr>
<tr class="separator:a90e220df7cb1f25852d4cc62cecd8869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff29795e987f8f9b347545468915de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxPairFilteringMode.html#aeaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a1ff29795e987f8f9b347545468915de2">staticKineFilteringMode</a></td></tr>
<tr class="memdesc:a1ff29795e987f8f9b347545468915de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtering mode for static-kinematic pairs in the broadphase.  <a href="#a1ff29795e987f8f9b347545468915de2">More...</a><br /></td></tr>
<tr class="separator:a1ff29795e987f8f9b347545468915de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c27c85987bc2be98578f0130f455157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxBroadPhaseType.html#ac7422f895533bff02d0043d35a2b7dda">PxBroadPhaseType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a3c27c85987bc2be98578f0130f455157">broadPhaseType</a></td></tr>
<tr class="memdesc:a3c27c85987bc2be98578f0130f455157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the broad-phase algorithm to use.  <a href="#a3c27c85987bc2be98578f0130f455157">More...</a><br /></td></tr>
<tr class="separator:a3c27c85987bc2be98578f0130f455157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee15ebe1d7155c19866972ecf5cbdd91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#aee15ebe1d7155c19866972ecf5cbdd91">broadPhaseCallback</a></td></tr>
<tr class="memdesc:aee15ebe1d7155c19866972ecf5cbdd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broad-phase callback.  <a href="#aee15ebe1d7155c19866972ecf5cbdd91">More...</a><br /></td></tr>
<tr class="separator:aee15ebe1d7155c19866972ecf5cbdd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab996312333ef4fdf5f77fcc16b84923e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxSceneLimits.html">PxSceneLimits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ab996312333ef4fdf5f77fcc16b84923e">limits</a></td></tr>
<tr class="memdesc:ab996312333ef4fdf5f77fcc16b84923e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected scene limits.  <a href="#ab996312333ef4fdf5f77fcc16b84923e">More...</a><br /></td></tr>
<tr class="separator:ab996312333ef4fdf5f77fcc16b84923e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f18b0666adb645d92fc2f53373b1e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxFrictionType.html#a603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ab1f18b0666adb645d92fc2f53373b1e9">frictionType</a></td></tr>
<tr class="memdesc:ab1f18b0666adb645d92fc2f53373b1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the friction algorithm to use for simulation.  <a href="#ab1f18b0666adb645d92fc2f53373b1e9">More...</a><br /></td></tr>
<tr class="separator:ab1f18b0666adb645d92fc2f53373b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166d622a6ea49c6e58be0b1d123f03ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxSolverType.html#a96adc2f8785c6b18805a18b03289dbe6">PxSolverType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a166d622a6ea49c6e58be0b1d123f03ab">solverType</a></td></tr>
<tr class="memdesc:a166d622a6ea49c6e58be0b1d123f03ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the solver algorithm to use.  <a href="#a166d622a6ea49c6e58be0b1d123f03ab">More...</a><br /></td></tr>
<tr class="separator:a166d622a6ea49c6e58be0b1d123f03ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7769532392c8e47ec4580677145e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#abc7769532392c8e47ec4580677145e34">bounceThresholdVelocity</a></td></tr>
<tr class="memdesc:abc7769532392c8e47ec4580677145e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contact with a relative velocity below this will not bounce. A typical value for simulation. stability is about 0.2 * gravity.  <a href="#abc7769532392c8e47ec4580677145e34">More...</a><br /></td></tr>
<tr class="separator:abc7769532392c8e47ec4580677145e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af707e0c97624aaf6fa9ab2e82aadbecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#af707e0c97624aaf6fa9ab2e82aadbecf">frictionOffsetThreshold</a></td></tr>
<tr class="memdesc:af707e0c97624aaf6fa9ab2e82aadbecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A threshold of contact separation distance used to decide if a contact point will experience friction forces.  <a href="#af707e0c97624aaf6fa9ab2e82aadbecf">More...</a><br /></td></tr>
<tr class="separator:af707e0c97624aaf6fa9ab2e82aadbecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6124268a3ad7077baff423165f050bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#aa6124268a3ad7077baff423165f050bf">frictionCorrelationDistance</a></td></tr>
<tr class="memdesc:aa6124268a3ad7077baff423165f050bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not.  <a href="#aa6124268a3ad7077baff423165f050bf">More...</a><br /></td></tr>
<tr class="separator:aa6124268a3ad7077baff423165f050bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9510b1233fb0ab03e9c1d5be44ff5a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__physics.html#ga54a626a9a6d80543048bffc654814704">PxSceneFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a9510b1233fb0ab03e9c1d5be44ff5a38">flags</a></td></tr>
<tr class="memdesc:a9510b1233fb0ab03e9c1d5be44ff5a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags used to select scene options.  <a href="#a9510b1233fb0ab03e9c1d5be44ff5a38">More...</a><br /></td></tr>
<tr class="separator:a9510b1233fb0ab03e9c1d5be44ff5a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74f5f6c12d72b873716f82c2225b725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxCpuDispatcher.html">PxCpuDispatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ac74f5f6c12d72b873716f82c2225b725">cpuDispatcher</a></td></tr>
<tr class="memdesc:ac74f5f6c12d72b873716f82c2225b725"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CPU task dispatcher for the scene.  <a href="#ac74f5f6c12d72b873716f82c2225b725">More...</a><br /></td></tr>
<tr class="separator:ac74f5f6c12d72b873716f82c2225b725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55a6e9d290779839659bb2763db2e2a"><td class="memItemLeft" align="right" valign="top">PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ad55a6e9d290779839659bb2763db2e2a">cudaContextManager</a></td></tr>
<tr class="memdesc:ad55a6e9d290779839659bb2763db2e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CUDA context manager for the scene.  <a href="#ad55a6e9d290779839659bb2763db2e2a">More...</a><br /></td></tr>
<tr class="separator:ad55a6e9d290779839659bb2763db2e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d40516cfbbe7d167d89e6fe55e3834"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a63d40516cfbbe7d167d89e6fe55e3834">userData</a></td></tr>
<tr class="memdesc:a63d40516cfbbe7d167d89e6fe55e3834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will be copied to <a class="el" href="classPxScene.html#a64fbe5f25cef90d47fcb1c6428efe15a" title="user can assign this to whatever, usually to create a 1:1 relationship with a user object...">PxScene::userData</a>.  <a href="#a63d40516cfbbe7d167d89e6fe55e3834">More...</a><br /></td></tr>
<tr class="separator:a63d40516cfbbe7d167d89e6fe55e3834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b321b928708c10a047b38ec9127797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a26b321b928708c10a047b38ec9127797">solverBatchSize</a></td></tr>
<tr class="memdesc:a26b321b928708c10a047b38ec9127797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the number of actors required to spawn a separate rigid body solver island task chain.  <a href="#a26b321b928708c10a047b38ec9127797">More...</a><br /></td></tr>
<tr class="separator:a26b321b928708c10a047b38ec9127797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fd72417c89bd73fc398678ae153c52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a57fd72417c89bd73fc398678ae153c52">solverArticulationBatchSize</a></td></tr>
<tr class="memdesc:a57fd72417c89bd73fc398678ae153c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the number of articulations required to spawn a separate rigid body solver island task chain.  <a href="#a57fd72417c89bd73fc398678ae153c52">More...</a><br /></td></tr>
<tr class="separator:a57fd72417c89bd73fc398678ae153c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625cdbae7d2149a9df472fb4f9c06f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a625cdbae7d2149a9df472fb4f9c06f83">nbContactDataBlocks</a></td></tr>
<tr class="memdesc:a625cdbae7d2149a9df472fb4f9c06f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting to define the number of 16K blocks that will be initially reserved to store contact, friction, and contact cache data. This is the number of 16K memory blocks that will be automatically allocated from the user allocator when the scene is instantiated. Further 16k memory blocks may be allocated during the simulation up to maxNbContactDataBlocks.  <a href="#a625cdbae7d2149a9df472fb4f9c06f83">More...</a><br /></td></tr>
<tr class="separator:a625cdbae7d2149a9df472fb4f9c06f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8791132cbe8cce32f051e5eaab774d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a8791132cbe8cce32f051e5eaab774d35">maxNbContactDataBlocks</a></td></tr>
<tr class="memdesc:a8791132cbe8cce32f051e5eaab774d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting to define the maximum number of 16K blocks that can be allocated to store contact, friction, and contact cache data. As the complexity of a scene increases, the SDK may require to allocate new 16k blocks in addition to the blocks it has already allocated. This variable controls the maximum number of blocks that the SDK can allocate.  <a href="#a8791132cbe8cce32f051e5eaab774d35">More...</a><br /></td></tr>
<tr class="separator:a8791132cbe8cce32f051e5eaab774d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bbe399965691dec83ba3fe1a5082ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a65bbe399965691dec83ba3fe1a5082ec">maxBiasCoefficient</a></td></tr>
<tr class="memdesc:a65bbe399965691dec83ba3fe1a5082ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum bias coefficient used in the constraint solver.  <a href="#a65bbe399965691dec83ba3fe1a5082ec">More...</a><br /></td></tr>
<tr class="separator:a65bbe399965691dec83ba3fe1a5082ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d696140e9828477c8aa493a048f48a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a02d696140e9828477c8aa493a048f48a">contactReportStreamBufferSize</a></td></tr>
<tr class="memdesc:a02d696140e9828477c8aa493a048f48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the contact report stream (in bytes).  <a href="#a02d696140e9828477c8aa493a048f48a">More...</a><br /></td></tr>
<tr class="separator:a02d696140e9828477c8aa493a048f48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aa4ceefbbd6aebd75ea879d7c385f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a65aa4ceefbbd6aebd75ea879d7c385f9">ccdMaxPasses</a></td></tr>
<tr class="memdesc:a65aa4ceefbbd6aebd75ea879d7c385f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of CCD passes.  <a href="#a65aa4ceefbbd6aebd75ea879d7c385f9">More...</a><br /></td></tr>
<tr class="separator:a65aa4ceefbbd6aebd75ea879d7c385f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8bb05a5b151da44d30986e729172c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a5b8bb05a5b151da44d30986e729172c7">ccdThreshold</a></td></tr>
<tr class="memdesc:a5b8bb05a5b151da44d30986e729172c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCD threshold.  <a href="#a5b8bb05a5b151da44d30986e729172c7">More...</a><br /></td></tr>
<tr class="separator:a5b8bb05a5b151da44d30986e729172c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dc6e8ebde591ca823a3ea4807fca33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a74dc6e8ebde591ca823a3ea4807fca33">ccdMaxSeparation</a></td></tr>
<tr class="memdesc:a74dc6e8ebde591ca823a3ea4807fca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the two are used to resolve the contacts.  <a href="#a74dc6e8ebde591ca823a3ea4807fca33">More...</a><br /></td></tr>
<tr class="separator:a74dc6e8ebde591ca823a3ea4807fca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e2c9c06f711272a48d7f07451117b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7">wakeCounterResetValue</a></td></tr>
<tr class="memdesc:a79e2c9c06f711272a48d7f07451117b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wake counter reset value.  <a href="#a79e2c9c06f711272a48d7f07451117b7">More...</a><br /></td></tr>
<tr class="separator:a79e2c9c06f711272a48d7f07451117b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6ba51fe74a6c5ea4a46709abb89168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxBounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a8d6ba51fe74a6c5ea4a46709abb89168">sanityBounds</a></td></tr>
<tr class="memdesc:a8d6ba51fe74a6c5ea4a46709abb89168"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bounds used to sanity check user-set positions of actors and articulation links.  <a href="#a8d6ba51fe74a6c5ea4a46709abb89168">More...</a><br /></td></tr>
<tr class="separator:a8d6ba51fe74a6c5ea4a46709abb89168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90ebca71afa21639bd99693df30e197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxgDynamicsMemoryConfig.html">PxgDynamicsMemoryConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ab90ebca71afa21639bd99693df30e197">gpuDynamicsConfig</a></td></tr>
<tr class="memdesc:ab90ebca71afa21639bd99693df30e197"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pre-allocations performed in the GPU dynamics pipeline.  <a href="#ab90ebca71afa21639bd99693df30e197">More...</a><br /></td></tr>
<tr class="separator:ab90ebca71afa21639bd99693df30e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673610cdfbcb84103e2c3840754ecac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a3673610cdfbcb84103e2c3840754ecac">gpuMaxNumPartitions</a></td></tr>
<tr class="memdesc:a3673610cdfbcb84103e2c3840754ecac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limitation for the partitions in the GPU dynamics pipeline. This variable must be power of 2. A value greater than 32 is currently not supported. <b>Range:</b> (1, 32)<br />
  <a href="#a3673610cdfbcb84103e2c3840754ecac">More...</a><br /></td></tr>
<tr class="separator:a3673610cdfbcb84103e2c3840754ecac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4195ca22f2985e7742824813345c1411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a4195ca22f2985e7742824813345c1411">gpuMaxNumStaticPartitions</a></td></tr>
<tr class="memdesc:a4195ca22f2985e7742824813345c1411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limitation for the number of static rigid body partitions in the GPU dynamics pipeline. <b>Range:</b> (1, 255)<br />
 <b>Default:</b> 16.  <a href="#a4195ca22f2985e7742824813345c1411">More...</a><br /></td></tr>
<tr class="separator:a4195ca22f2985e7742824813345c1411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02177181688e06f18f504e3ba6327a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ac02177181688e06f18f504e3ba6327a7">gpuComputeVersion</a></td></tr>
<tr class="memdesc:ac02177181688e06f18f504e3ba6327a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines which compute version the GPU dynamics should target. DO NOT MODIFY.  <a href="#ac02177181688e06f18f504e3ba6327a7">More...</a><br /></td></tr>
<tr class="separator:ac02177181688e06f18f504e3ba6327a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6006613a08cb8725d381462f09f9ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a7c6006613a08cb8725d381462f09f9ee">contactPairSlabSize</a></td></tr>
<tr class="memdesc:a7c6006613a08cb8725d381462f09f9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of a contact pool slab. Contact pairs and associated data are allocated using a pool allocator. Increasing the slab size can trade off some performance spikes when a large number of new contacts are found for an increase in overall memory usage.  <a href="#a7c6006613a08cb8725d381462f09f9ee">More...</a><br /></td></tr>
<tr class="separator:a7c6006613a08cb8725d381462f09f9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ff6aa4df83d50aef208baa427a7e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPxSceneQuerySystem.html">PxSceneQuerySystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#a92ff6aa4df83d50aef208baa427a7e3d">sceneQuerySystem</a></td></tr>
<tr class="memdesc:a92ff6aa4df83d50aef208baa427a7e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scene query sub-system for the scene.  <a href="#a92ff6aa4df83d50aef208baa427a7e3d">More...</a><br /></td></tr>
<tr class="separator:a92ff6aa4df83d50aef208baa427a7e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classPxSceneQueryDesc"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classPxSceneQueryDesc')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classPxSceneQueryDesc.html">PxSceneQueryDesc</a></td></tr>
<tr class="memitem:ab5e8ad3a8e664c5ea663bea6b82c5aab inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxPruningStructureType.html#a058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#ab5e8ad3a8e664c5ea663bea6b82c5aab">staticStructure</a></td></tr>
<tr class="memdesc:ab5e8ad3a8e664c5ea663bea6b82c5aab inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the structure used to store static objects (<a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK. ">PxRigidStatic</a> actors).  <a href="classPxSceneQueryDesc.html#ab5e8ad3a8e664c5ea663bea6b82c5aab">More...</a><br /></td></tr>
<tr class="separator:ab5e8ad3a8e664c5ea663bea6b82c5aab inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6e01e32b6bc62a6516839208bed66d inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxPruningStructureType.html#a058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#acb6e01e32b6bc62a6516839208bed66d">dynamicStructure</a></td></tr>
<tr class="memdesc:acb6e01e32b6bc62a6516839208bed66d inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the structure used to store dynamic objects (non-PxRigidStatic actors).  <a href="classPxSceneQueryDesc.html#acb6e01e32b6bc62a6516839208bed66d">More...</a><br /></td></tr>
<tr class="separator:acb6e01e32b6bc62a6516839208bed66d inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c02042de286d160dec2cc4374fa109 inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#ad3c02042de286d160dec2cc4374fa109">dynamicTreeRebuildRateHint</a></td></tr>
<tr class="memdesc:ad3c02042de286d160dec2cc4374fa109 inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hint for how much work should be done per simulation frame to rebuild the pruning structures.  <a href="classPxSceneQueryDesc.html#ad3c02042de286d160dec2cc4374fa109">More...</a><br /></td></tr>
<tr class="separator:ad3c02042de286d160dec2cc4374fa109 inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4cce055a1dfcef121e5cbfa32c994a inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxDynamicTreeSecondaryPruner.html#a59044cb326526cadb6aee4f6f43651b9">PxDynamicTreeSecondaryPruner::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#a3a4cce055a1dfcef121e5cbfa32c994a">dynamicTreeSecondaryPruner</a></td></tr>
<tr class="memdesc:a3a4cce055a1dfcef121e5cbfa32c994a inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secondary pruner for dynamic tree.  <a href="classPxSceneQueryDesc.html#a3a4cce055a1dfcef121e5cbfa32c994a">More...</a><br /></td></tr>
<tr class="separator:a3a4cce055a1dfcef121e5cbfa32c994a inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1db6725ecbfa670a2e2ae4c962094c inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxBVHBuildStrategy.html#a76258a5d936088c608f7fa8604c1f257">PxBVHBuildStrategy::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#aad1db6725ecbfa670a2e2ae4c962094c">staticBVHBuildStrategy</a></td></tr>
<tr class="memdesc:aad1db6725ecbfa670a2e2ae4c962094c inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build strategy for <a class="el" href="classPxSceneQueryDesc.html#ab5e8ad3a8e664c5ea663bea6b82c5aab" title="Defines the structure used to store static objects (PxRigidStatic actors). ">PxSceneQueryDesc::staticStructure</a>.  <a href="classPxSceneQueryDesc.html#aad1db6725ecbfa670a2e2ae4c962094c">More...</a><br /></td></tr>
<tr class="separator:aad1db6725ecbfa670a2e2ae4c962094c inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8839b0985dacf362b578c4fb56a04e9 inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxBVHBuildStrategy.html#a76258a5d936088c608f7fa8604c1f257">PxBVHBuildStrategy::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#ab8839b0985dacf362b578c4fb56a04e9">dynamicBVHBuildStrategy</a></td></tr>
<tr class="memdesc:ab8839b0985dacf362b578c4fb56a04e9 inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build strategy for <a class="el" href="classPxSceneQueryDesc.html#acb6e01e32b6bc62a6516839208bed66d" title="Defines the structure used to store dynamic objects (non-PxRigidStatic actors). ">PxSceneQueryDesc::dynamicStructure</a>.  <a href="classPxSceneQueryDesc.html#ab8839b0985dacf362b578c4fb56a04e9">More...</a><br /></td></tr>
<tr class="separator:ab8839b0985dacf362b578c4fb56a04e9 inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f5bd70b61785be6e5d5f3925810a92 inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#a36f5bd70b61785be6e5d5f3925810a92">staticNbObjectsPerNode</a></td></tr>
<tr class="memdesc:a36f5bd70b61785be6e5d5f3925810a92 inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of objects per node for <a class="el" href="classPxSceneQueryDesc.html#ab5e8ad3a8e664c5ea663bea6b82c5aab" title="Defines the structure used to store static objects (PxRigidStatic actors). ">PxSceneQueryDesc::staticStructure</a>.  <a href="classPxSceneQueryDesc.html#a36f5bd70b61785be6e5d5f3925810a92">More...</a><br /></td></tr>
<tr class="separator:a36f5bd70b61785be6e5d5f3925810a92 inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d87ef7a15face2d81bd7706c501db4d inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#a0d87ef7a15face2d81bd7706c501db4d">dynamicNbObjectsPerNode</a></td></tr>
<tr class="memdesc:a0d87ef7a15face2d81bd7706c501db4d inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of objects per node for <a class="el" href="classPxSceneQueryDesc.html#acb6e01e32b6bc62a6516839208bed66d" title="Defines the structure used to store dynamic objects (non-PxRigidStatic actors). ">PxSceneQueryDesc::dynamicStructure</a>.  <a href="classPxSceneQueryDesc.html#a0d87ef7a15face2d81bd7706c501db4d">More...</a><br /></td></tr>
<tr class="separator:a0d87ef7a15face2d81bd7706c501db4d inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b9676f564ae717785955e88a60ebd2 inherit pub_attribs_classPxSceneQueryDesc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPxSceneQueryUpdateMode.html#a04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryDesc.html#a54b9676f564ae717785955e88a60ebd2">sceneQueryUpdateMode</a></td></tr>
<tr class="memdesc:a54b9676f564ae717785955e88a60ebd2 inherit pub_attribs_classPxSceneQueryDesc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the scene query update mode.  <a href="classPxSceneQueryDesc.html#a54b9676f564ae717785955e88a60ebd2">More...</a><br /></td></tr>
<tr class="separator:a54b9676f564ae717785955e88a60ebd2 inherit pub_attribs_classPxSceneQueryDesc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Descriptor class for scenes. See <a class="el" href="classPxScene.html" title="A scene is a collection of bodies and constraints which can interact. ">PxScene</a>. </p>
<p>This struct must be initialized with the same <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are calculated in term...">PxTolerancesScale</a> values used to initialize <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK. ">PxPhysics</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies and constraints which can interact. ">PxScene</a> <a class="el" href="classPxPhysics.html#a6dcded7be00c17004432a04a78569db1" title="Creates a scene. ">PxPhysics.createScene</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are calculated in term...">PxTolerancesScale</a> </dd></dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="abc7769532392c8e47ec4580677145e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7769532392c8e47ec4580677145e34">&#9670;&nbsp;</a></span>bounceThresholdVelocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSceneDesc::bounceThresholdVelocity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A contact with a relative velocity below this will not bounce. A typical value for simulation. stability is about 0.2 * gravity. </p>
<p><b>Range:</b> (0, PX_MAX_F32)<br />
 <b>Default:</b> 0.2 * <a class="el" href="classPxTolerancesScale.html#a629358a15988697feaa85759d5c57e33" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties. ">PxMaterial</a> <a class="el" href="classPxScene.html#a1e102ec1b29dea3b588b7507561e656e" title="Set the bounce threshold velocity. Collision speeds below this threshold will not cause a bounce...">PxScene.setBounceThresholdVelocity()</a> <a class="el" href="classPxScene.html#a36f1319b6695b33823529924f389ca3e" title="Return the bounce threshold velocity. ">PxScene.getBounceThresholdVelocity()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="aee15ebe1d7155c19866972ecf5cbdd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee15ebe1d7155c19866972ecf5cbdd91">&#9670;&nbsp;</a></span>broadPhaseCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a>* PxSceneDesc::broadPhaseCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broad-phase callback. </p>
<p><b>Default:</b> NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events. ">PxBroadPhaseCallback</a> <a class="el" href="classPxScene.html#a4c3269f14110636d8e2beee333bfdd71" title="Retrieves the PxBroadPhaseCallback pointer set with setBroadPhaseCallback(). ">PxScene.getBroadPhaseCallback()</a> <a class="el" href="classPxScene.html#a353da44d631c07cacd2f8d85f08cbc09" title="Sets a broad-phase user callback object. ">PxScene.setBroadPhaseCallback()</a> </dd></dl>

</div>
</div>
<a id="a3c27c85987bc2be98578f0130f455157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c27c85987bc2be98578f0130f455157">&#9670;&nbsp;</a></span>broadPhaseType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxBroadPhaseType.html#ac7422f895533bff02d0043d35a2b7dda">PxBroadPhaseType::Enum</a> PxSceneDesc::broadPhaseType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the broad-phase algorithm to use. </p>
<p><b>Default:</b> <a class="el" href="structPxBroadPhaseType.html#ac7422f895533bff02d0043d35a2b7ddaa3eb5f473bac1b86e0169d73ffbcb7cc0" title="Automatic box pruning. ">PxBroadPhaseType::eABP</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxBroadPhaseType.html" title="Broad phase algorithm used in the simulation. ">PxBroadPhaseType</a> <a class="el" href="classPxScene.html#a5ac224256bfbe7380ea3dad4dc6dac06" title="Returns broad-phase type. ">PxScene.getBroadPhaseType()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="aae577616d3e898347924de90e16188bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae577616d3e898347924de90e16188bb">&#9670;&nbsp;</a></span>ccdContactModifyCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a>* PxSceneDesc::ccdContactModifyCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible asynchronous callback for contact modification. </p>
<p><b>Default:</b> NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints. ">PxContactModifyCallback</a> <a class="el" href="classPxScene.html#aeec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors...">PxScene.setContactModifyCallback()</a> <a class="el" href="classPxScene.html#a1978693b355df49712d7e59c10c4115d" title="Retrieves the PxContactModifyCallback pointer set with setContactModifyCallback(). ">PxScene.getContactModifyCallback()</a> </dd></dl>

</div>
</div>
<a id="a65aa4ceefbbd6aebd75ea879d7c385f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65aa4ceefbbd6aebd75ea879d7c385f9">&#9670;&nbsp;</a></span>ccdMaxPasses</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::ccdMaxPasses</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of CCD passes. </p>
<p>The CCD performs multiple passes, where each pass every object advances to its time of first impact. This value defines how many passes the CCD system should perform.</p>
<dl class="section note"><dt>Note</dt><dd>The CCD system is a multi-pass best-effort conservative advancement approach. After the defined number of passes has been completed, any remaining time is dropped. </dd>
<dd>
This defines the maximum number of passes the CCD can perform. It may perform fewer if additional passes are not necessary.</dd></dl>
<p><b>Default:</b> 1 <b>Range:</b> [1, PX_MAX_U32]<br />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#aed46505d6eac63a508c7a2d7e39cd5fb" title="Sets the maximum number of CCD passes. ">PxScene.setCCDMaxPasses()</a> <a class="el" href="classPxScene.html#ab0033036e31f91c68d520185ef6c1703" title="Gets the maximum number of CCD passes. ">PxScene.getCCDMaxPasses()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a74dc6e8ebde591ca823a3ea4807fca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74dc6e8ebde591ca823a3ea4807fca33">&#9670;&nbsp;</a></span>ccdMaxSeparation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSceneDesc::ccdMaxSeparation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the two are used to resolve the contacts. </p>
<dl class="section note"><dt>Note</dt><dd>This only has any effect on contacting pairs where one of the bodies has <a class="el" href="structPxRigidBodyFlag.html#a5fd4878ae66a98c030a9d976e8ba8596af13d6aa80b364fe2cef81a0039e37d45" title="Register a rigid body to dynamically adjust contact offset based on velocity. This can be used to ach...">PxRigidBodyFlag::eENABLE_SPECULATIVE_CCD</a> raised.</dd></dl>
<p><b>Range:</b> [0, PX_MAX_F32)<br />
 <b>Default:</b> 0.04 * <a class="el" href="classPxTolerancesScale.html#a7d93bf20de0e5b54783eda5bb64effeb" title="The approximate size of objects in the simulation. ">PxTolerancesScale::length</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a5c351b4babd520464a9ee5f79d63b252" title="Set the maximum CCD separation. ">PxScene.setCCDMaxSeparation()</a> <a class="el" href="classPxScene.html#af4ac23232be477a54cce65fa5f22c0d7" title="Gets the maximum CCD separation. ">PxScene.getCCDMaxSeparation()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a5b8bb05a5b151da44d30986e729172c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8bb05a5b151da44d30986e729172c7">&#9670;&nbsp;</a></span>ccdThreshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSceneDesc::ccdThreshold</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CCD threshold. </p>
<p>CCD performs sweeps against shapes if and only if the relative motion of the shapes is fast-enough that a collision would be missed by the discrete contact generation. However, in some circumstances, e.g. when the environment is constructed from large convex shapes, this approach may produce undesired simulation artefacts. This parameter defines the minimum relative motion that would be required to force CCD between shapes. The smaller of this value and the sum of the thresholds calculated for the shapes involved will be used.</p>
<dl class="section note"><dt>Note</dt><dd>It is not advisable to set this to a very small value as this may lead to CCD "jamming" and detrimentally effect performance. This value should be at least larger than the translation caused by a single frame's gravitational effect</dd></dl>
<p><b>Default:</b> PX_MAX_F32 <b>Range:</b> [Eps, PX_MAX_F32]<br />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a4cb0da095037f01823eb5e277e186bb8" title="Set the CCD threshold. ">PxScene.setCCDThreshold()</a> <a class="el" href="classPxScene.html#abb0c98a86c570467521cff66174f129d" title="Gets the CCD threshold. ">PxScene.getCCDThreshold()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a2000ccfa6287d160b88967769de34b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2000ccfa6287d160b88967769de34b90">&#9670;&nbsp;</a></span>contactModifyCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a>* PxSceneDesc::contactModifyCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible asynchronous callback for contact modification. </p>
<p><b>Default:</b> NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints. ">PxContactModifyCallback</a> <a class="el" href="classPxScene.html#aeec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors...">PxScene.setContactModifyCallback()</a> <a class="el" href="classPxScene.html#a1978693b355df49712d7e59c10c4115d" title="Retrieves the PxContactModifyCallback pointer set with setContactModifyCallback(). ">PxScene.getContactModifyCallback()</a> </dd></dl>

</div>
</div>
<a id="a7c6006613a08cb8725d381462f09f9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6006613a08cb8725d381462f09f9ee">&#9670;&nbsp;</a></span>contactPairSlabSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::contactPairSlabSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the size of a contact pool slab. Contact pairs and associated data are allocated using a pool allocator. Increasing the slab size can trade off some performance spikes when a large number of new contacts are found for an increase in overall memory usage. </p>
<p><b>Range:</b>(1, PX_MAX_U32)<br />
 <b>Default:</b> 256 </p>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a02d696140e9828477c8aa493a048f48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d696140e9828477c8aa493a048f48a">&#9670;&nbsp;</a></span>contactReportStreamBufferSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::contactReportStreamBufferSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the contact report stream (in bytes). </p>
<p>The contact report stream buffer is used during the simulation to store all the contact reports. If the size is not sufficient, the buffer will grow by a factor of two. It is possible to disable the buffer growth by setting the flag <a class="el" href="structPxSceneFlag.html#ab4c347372b4433d34d983da780916c53a8644817a9a2916453433702614672565" title="Disable contact report buffer resize. Once the contact buffer is full, the rest of the contact report...">PxSceneFlag::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE</a>. In that case the buffer will not grow but contact reports not stored in the buffer will not get sent in the contact report callbacks.</p>
<p><b>Default:</b> 8192</p>
<p><b>Range:</b> (0, PX_MAX_U32]<br />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#ac7b1dccad5d20304653f21c91b09258a" title="Return the value of PxSceneDesc::contactReportStreamBufferSize that was set when creating the scene w...">PxScene.getContactReportStreamBufferSize()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="ac74f5f6c12d72b873716f82c2225b725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74f5f6c12d72b873716f82c2225b725">&#9670;&nbsp;</a></span>cpuDispatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxCpuDispatcher.html">PxCpuDispatcher</a>* PxSceneDesc::cpuDispatcher</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CPU task dispatcher for the scene. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxCpuDispatcher.html" title="A CpuDispatcher is responsible for scheduling the execution of tasks passed to it by the SDK...">PxCpuDispatcher</a>, <a class="el" href="classPxScene.html#a6329c94cc092aff2193c1307e033f6bf" title="Return the cpu dispatcher that was set in PxSceneDesc::cpuDispatcher when creating the scene with PxP...">PxScene::getCpuDispatcher</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="ad55a6e9d290779839659bb2763db2e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55a6e9d290779839659bb2763db2e2a">&#9670;&nbsp;</a></span>cudaContextManager</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxCudaContextManager* PxSceneDesc::cudaContextManager</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CUDA context manager for the scene. </p>
<p><b>Platform specific:</b> Applies to PC GPU only.</p>
<dl class="section see"><dt>See also</dt><dd>PxCudaContextManager, <a class="el" href="classPxScene.html#ac74778bafc058fbd4e8abd8006c323e8" title="Return the CUDA context manager that was set in PxSceneDesc::cudaContextManager when creating the sce...">PxScene::getCudaContextManager</a> </dd></dl>

</div>
</div>
<a id="af7b94475075eb9b43ca32650cd169cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b94475075eb9b43ca32650cd169cc1">&#9670;&nbsp;</a></span>filterCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a>* PxSceneDesc::filterCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A custom collision filter callback which can be used to implement more complex filtering operations which need access to the simulation state, for example. </p>
<p><b>Default:</b> NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs. ">PxSimulationFilterCallback</a> <a class="el" href="classPxScene.html#a2b4c17b1a16df239e5d6a2e0e6f8b633" title="Gets the custom collision filter callback in use for this scene. ">PxScene.getFilterCallback()</a> </dd></dl>

</div>
</div>
<a id="a9410287c6ea926dad9e2b2374541ad38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9410287c6ea926dad9e2b2374541ad38">&#9670;&nbsp;</a></span>filterShader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33">PxSimulationFilterShader</a> PxSceneDesc::filterShader</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The custom filter shader to use for collision filtering. </p>
<dl class="section note"><dt>Note</dt><dd>This parameter is compulsory. If you don't want to define your own filter shader you can use the default shader <a class="el" href="group__extensions.html#ga587ba12f90f77543c3e4452abeb0f22f" title="Implementation of a simple filter shader that emulates PhysX 2.8.x filtering. ">PxDefaultSimulationFilterShader</a> which can be found in the PhysX extensions library.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a> <a class="el" href="classPxScene.html#aa3f57314433de21448966c1d9004d71a" title="Gets the custom collision filter shader in use for this scene. ">PxScene.getFilterShader()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="ad9ceb142127cc259aa2f5d322a1494e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ceb142127cc259aa2f5d322a1494e2">&#9670;&nbsp;</a></span>filterShaderData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* PxSceneDesc::filterShaderData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared global filter data which will get passed into the filter shader. </p>
<dl class="section note"><dt>Note</dt><dd>The provided data will get copied to internal buffers and this copy will be used for filtering calls.</dd></dl>
<p><b>Default:</b> NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a> <a class="el" href="classPxScene.html#a5ab05d2a2c908d98aed4ca642c5f394d" title="Sets the shared global filter data which will get passed into the filter shader. ">PxScene.setFilterShaderData()</a> <a class="el" href="classPxScene.html#a5d004fdc88ed31447aa57ee4f98c14ea" title="Gets the shared global filter data in use for this scene. ">PxScene.getFilterShaderData()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a710c03915bbaaa9bdf23925d535c3883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710c03915bbaaa9bdf23925d535c3883">&#9670;&nbsp;</a></span>filterShaderDataSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::filterShaderDataSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size (in bytes) of the shared global filter data <a class="el" href="classPxSceneDesc.html#ad9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader. ">filterShaderData</a>. </p>
<p><b>Default:</b> 0</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a> <a class="el" href="classPxSceneDesc.html#ad9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader. ">filterShaderData</a> <a class="el" href="classPxScene.html#ace291f68b365a4f1aaa291ba940eff9a" title="Gets the size of the shared global filter data (PxSceneDesc.filterShaderData) ">PxScene.getFilterShaderDataSize()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a9510b1233fb0ab03e9c1d5be44ff5a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9510b1233fb0ab03e9c1d5be44ff5a38">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__physics.html#ga54a626a9a6d80543048bffc654814704">PxSceneFlags</a> PxSceneDesc::flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags used to select scene options. </p>
<p><b>Default:</b> <a class="el" href="structPxSceneFlag.html#ab4c347372b4433d34d983da780916c53a29717fa631812cc31261d73055762e03" title="Enable GJK-based distance collision detection system. ">PxSceneFlag::eENABLE_PCM</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene ">PxSceneFlag</a> <a class="el" href="group__physics.html#ga54a626a9a6d80543048bffc654814704" title="collection of set bits defined in PxSceneFlag. ">PxSceneFlags</a> <a class="el" href="classPxScene.html#a0acbc97457d54775b6402f3790c3513b" title="Get the scene flags. ">PxScene.getFlags()</a> <a class="el" href="classPxScene.html#a6610c08a5a92c894dcac9d658e48b7de" title="Sets a scene flag. You can only set one flag at a time. ">PxScene.setFlag()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="aa6124268a3ad7077baff423165f050bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6124268a3ad7077baff423165f050bf">&#9670;&nbsp;</a></span>frictionCorrelationDistance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSceneDesc::frictionCorrelationDistance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not. </p>
<dl class="section note"><dt>Note</dt><dd>If the correlation distance is larger than the distance between contact points generated between a pair of shapes, some of the contacts may not experience frictional forces.</dd>
<dd>
This parameter can be used to tune the correlation distance used in the solver. Contact points can be merged into a single friction anchor if the distance between the contacts is smaller than correlation distance.</dd></dl>
<p><b>Range:</b> [0, PX_MAX_F32)<br />
 <b>Default:</b> 0.025f * <a class="el" href="classPxTolerancesScale.html#a7d93bf20de0e5b54783eda5bb64effeb" title="The approximate size of objects in the simulation. ">PxTolerancesScale::length</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a095ecb05d6deba9234389298b9cd3bd1" title="Set the friction correlation distance. ">PxScene.setFrictionCorrelationDistance()</a> <a class="el" href="classPxScene.html#af9dc23e5316b363b6340aae29cdb853d" title="Gets the friction correlation distance. ">PxScene.getFrictionCorrelationDistance()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="af707e0c97624aaf6fa9ab2e82aadbecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af707e0c97624aaf6fa9ab2e82aadbecf">&#9670;&nbsp;</a></span>frictionOffsetThreshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSceneDesc::frictionOffsetThreshold</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A threshold of contact separation distance used to decide if a contact point will experience friction forces. </p>
<dl class="section note"><dt>Note</dt><dd>If the separation distance of a contact point is greater than the threshold then the contact point will not experience friction forces.</dd>
<dd>
If the aggregated contact offset of a pair of shapes is large it might be desirable to neglect friction for contact points whose separation distance is sufficiently large that the shape surfaces are clearly separated.</dd>
<dd>
This parameter can be used to tune the separation distance of contact points at which friction starts to have an effect.</dd></dl>
<p><b>Range:</b> [0, PX_MAX_F32)<br />
 <b>Default:</b> 0.04 * <a class="el" href="classPxTolerancesScale.html#a7d93bf20de0e5b54783eda5bb64effeb" title="The approximate size of objects in the simulation. ">PxTolerancesScale::length</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#afaf16dccb544d2a9282a970cb5caecf3" title="Set the friction offset threshold. ">PxScene.setFrictionOffsetThreshold()</a> <a class="el" href="classPxScene.html#ac02554e87f89db490aca6803056db522" title="Gets the friction offset threshold. ">PxScene.getFrictionOffsetThreshold()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="ab1f18b0666adb645d92fc2f53373b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f18b0666adb645d92fc2f53373b1e9">&#9670;&nbsp;</a></span>frictionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxFrictionType.html#a603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a> PxSceneDesc::frictionType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the friction algorithm to use for simulation. </p>
<dl class="section note"><dt>Note</dt><dd>frictionType cannot be modified after the first call to any of <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate</a>, PxScene::solve and <a class="el" href="classPxScene.html#a698947ec5653ac7a2c466122f393e477" title="Performs collision detection for the scene over elapsedTime. ">PxScene::collide</a></dd></dl>
<p><b>Default:</b> <a class="el" href="structPxFrictionType.html#a603c53fd85805e2528a338252496a96bacf891c8b96deb40e1e475237fe4f4047" title="Select default patch-friction model. ">PxFrictionType::ePATCH</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxFrictionType.html" title="Enum for selecting the friction algorithm used for simulation. ">PxFrictionType</a> PxScene.setFrictionType(), <a class="el" href="classPxScene.html#aaca4a2838bc3bf7ffece380c8c7f0f4e" title="Return the friction model. ">PxScene.getFrictionType()</a> </dd></dl>

</div>
</div>
<a id="ac02177181688e06f18f504e3ba6327a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02177181688e06f18f504e3ba6327a7">&#9670;&nbsp;</a></span>gpuComputeVersion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::gpuComputeVersion</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines which compute version the GPU dynamics should target. DO NOT MODIFY. </p>

</div>
</div>
<a id="ab90ebca71afa21639bd99693df30e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90ebca71afa21639bd99693df30e197">&#9670;&nbsp;</a></span>gpuDynamicsConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxgDynamicsMemoryConfig.html">PxgDynamicsMemoryConfig</a> PxSceneDesc::gpuDynamicsConfig</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pre-allocations performed in the GPU dynamics pipeline. </p>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a3673610cdfbcb84103e2c3840754ecac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3673610cdfbcb84103e2c3840754ecac">&#9670;&nbsp;</a></span>gpuMaxNumPartitions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::gpuMaxNumPartitions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limitation for the partitions in the GPU dynamics pipeline. This variable must be power of 2. A value greater than 32 is currently not supported. <b>Range:</b> (1, 32)<br />
 </p>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a4195ca22f2985e7742824813345c1411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4195ca22f2985e7742824813345c1411">&#9670;&nbsp;</a></span>gpuMaxNumStaticPartitions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::gpuMaxNumStaticPartitions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limitation for the number of static rigid body partitions in the GPU dynamics pipeline. <b>Range:</b> (1, 255)<br />
 <b>Default:</b> 16. </p>

</div>
</div>
<a id="a9b0de35c38c43b8aeff6e6f29bf0db20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0de35c38c43b8aeff6e6f29bf0db20">&#9670;&nbsp;</a></span>gravity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> PxSceneDesc::gravity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gravity vector. </p>
<p><b>Range:</b> force vector<br />
 <b>Default:</b> Zero</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a575ed34c73adbd61892d728a688479f3" title="Sets a constant gravity for the entire scene. ">PxScene.setGravity()</a> <a class="el" href="classPxScene.html#a6fe48dbf9144be415d63f1d2f3ce0b16" title="Retrieves the current gravity setting. ">PxScene.getGravity()</a></dd></dl>
<p>When setting gravity, you should probably also set bounce threshold. </p>

</div>
</div>
<a id="a90e220df7cb1f25852d4cc62cecd8869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e220df7cb1f25852d4cc62cecd8869">&#9670;&nbsp;</a></span>kineKineFilteringMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxPairFilteringMode.html#aeaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a> PxSceneDesc::kineKineFilteringMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filtering mode for kinematic-kinematic pairs in the broadphase. </p>
<p><b>Default:</b> <a class="el" href="structPxPairFilteringMode.html#aeaa62ad327b874e4b199022401bf7615a464ca27835cd3bfe25854b99b6940c71" title="Default is eSUPPRESS for compatibility with previous PhysX versions. ">PxPairFilteringMode::eDEFAULT</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxPairFilteringMode.html">PxPairFilteringMode</a> <a class="el" href="classPxScene.html#ad33763d5f9ee70bf79608d07594ead11" title="Gets the pair filtering mode for kinematic-kinematic pairs. ">PxScene.getKinematicKinematicFilteringMode()</a> </dd></dl>

</div>
</div>
<a id="ab996312333ef4fdf5f77fcc16b84923e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab996312333ef4fdf5f77fcc16b84923e">&#9670;&nbsp;</a></span>limits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSceneLimits.html">PxSceneLimits</a> PxSceneDesc::limits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expected scene limits. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSceneLimits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits are used as a hi...">PxSceneLimits</a> <a class="el" href="classPxScene.html#a76d9b31b013e4d666e3b5fdea3448887" title="Get current scene limits. ">PxScene.getLimits()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a65bbe399965691dec83ba3fe1a5082ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bbe399965691dec83ba3fe1a5082ec">&#9670;&nbsp;</a></span>maxBiasCoefficient</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSceneDesc::maxBiasCoefficient</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum bias coefficient used in the constraint solver. </p>
<p>When geometric errors are found in the constraint solver, either as a result of shapes penetrating or joints becoming separated or violating limits, a bias is introduced in the solver position iterations to correct these errors. This bias is proportional to 1/dt, meaning that the bias becomes increasingly strong as the time-step passed to <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate</a>(...) becomes smaller. This coefficient allows the application to restrict how large the bias coefficient is, to reduce how violent error corrections are. This can improve simulation quality in cases where either variable time-steps or extremely small time-steps are used.</p>
<p><b>Default:</b> PX_MAX_F32</p>
<p><b> Range</b> [0, PX_MAX_F32] <br />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#ad39d664710b2b611b9d837b5573907c1" title="Set the max bias coefficient. ">PxScene.setMaxBiasCoefficient()</a> <a class="el" href="classPxScene.html#a7ddd344a1f1ab1447998d14765769a2a" title="Gets the max bias coefficient. ">PxScene.getMaxBiasCoefficient()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a8791132cbe8cce32f051e5eaab774d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8791132cbe8cce32f051e5eaab774d35">&#9670;&nbsp;</a></span>maxNbContactDataBlocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::maxNbContactDataBlocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting to define the maximum number of 16K blocks that can be allocated to store contact, friction, and contact cache data. As the complexity of a scene increases, the SDK may require to allocate new 16k blocks in addition to the blocks it has already allocated. This variable controls the maximum number of blocks that the SDK can allocate. </p>
<p>In the case that the scene is sufficiently complex that all the permitted 16K blocks are used, contacts will be dropped and a warning passed to the error stream.</p>
<p>If a warning is reported to the error stream to indicate the number of 16K blocks is insufficient for the scene complexity then the choices are either (i) re-tune the number of 16K data blocks until a number is found that is sufficient for the scene complexity, (ii) to simplify the scene or (iii) to opt to not increase the memory requirements of physx and accept some dropped contacts.</p>
<p><b>Default:</b> 65536</p>
<p><b>Range:</b> [0, PX_MAX_U32]<br />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSceneDesc.html#a625cdbae7d2149a9df472fb4f9c06f83" title="Setting to define the number of 16K blocks that will be initially reserved to store contact...">nbContactDataBlocks</a> <a class="el" href="classPxScene.html#a148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate(). ">PxScene.setNbContactDataBlocks()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a625cdbae7d2149a9df472fb4f9c06f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625cdbae7d2149a9df472fb4f9c06f83">&#9670;&nbsp;</a></span>nbContactDataBlocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::nbContactDataBlocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting to define the number of 16K blocks that will be initially reserved to store contact, friction, and contact cache data. This is the number of 16K memory blocks that will be automatically allocated from the user allocator when the scene is instantiated. Further 16k memory blocks may be allocated during the simulation up to maxNbContactDataBlocks. </p>
<dl class="section note"><dt>Note</dt><dd>This value cannot be larger than maxNbContactDataBlocks because that defines the maximum number of 16k blocks that can be allocated by the SDK.</dd></dl>
<p><b>Default:</b> 0</p>
<p><b>Range:</b> [0, PX_MAX_U32]<br />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxPhysics.html#a6dcded7be00c17004432a04a78569db1" title="Creates a scene. ">PxPhysics::createScene</a> <a class="el" href="classPxScene.html#a148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate(). ">PxScene::setNbContactDataBlocks</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a8d6ba51fe74a6c5ea4a46709abb89168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6ba51fe74a6c5ea4a46709abb89168">&#9670;&nbsp;</a></span>sanityBounds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxBounds3.html">PxBounds3</a> PxSceneDesc::sanityBounds</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bounds used to sanity check user-set positions of actors and articulation links. </p>
<p>These bounds are used to check the position values of rigid actors inserted into the scene, and positions set for rigid actors already within the scene.</p>
<p><b>Range:</b> any valid <a class="el" href="classPxBounds3.html" title="Class representing 3D range or axis aligned bounding box. ">PxBounds3</a> <br />
 <b>Default:</b> (-PX_MAX_BOUNDS_EXTENTS, PX_MAX_BOUNDS_EXTENTS) on each axis </p>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<a id="a92ff6aa4df83d50aef208baa427a7e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ff6aa4df83d50aef208baa427a7e3d">&#9670;&nbsp;</a></span>sceneQuerySystem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSceneQuerySystem.html">PxSceneQuerySystem</a>* PxSceneDesc::sceneQuerySystem</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scene query sub-system for the scene. </p>
<p>If left to NULL, <a class="el" href="classPxScene.html" title="A scene is a collection of bodies and constraints which can interact. ">PxScene</a> will use its usual internal sub-system. If non-NULL, all SQ-related calls will be re-routed to the user-provided implementation. An external SQ implementation is available in the Extensions library (see PxCreateExternalSceneQuerySystem). This can also be fully re-implemented by users if needed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSceneQuerySystem.html" title="Scene-queries external sub-system for PxScene-based objects. ">PxSceneQuerySystem</a> </dd></dl>

</div>
</div>
<a id="a71a00536a56d40fe031de2ced1834941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a00536a56d40fe031de2ced1834941">&#9670;&nbsp;</a></span>simulationEventCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a>* PxSceneDesc::simulationEventCallback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible notification callback. </p>
<p><b>Default:</b> NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events. ">PxSimulationEventCallback</a> <a class="el" href="classPxScene.html#a0cfa2d3835ea936ecd6ff94fbcefd689" title="Sets a user notify object which receives special simulation events when they occur. ">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxScene.html#a8951e43f8e23c320c1c90dd552135171" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback(). ">PxScene.getSimulationEventCallback()</a> </dd></dl>

</div>
</div>
<a id="a57fd72417c89bd73fc398678ae153c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fd72417c89bd73fc398678ae153c52">&#9670;&nbsp;</a></span>solverArticulationBatchSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::solverArticulationBatchSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the number of articulations required to spawn a separate rigid body solver island task chain. </p>
<p>This parameter defines the minimum number of articulations required to spawn a separate rigid body solver task chain. Setting a low value will potentially cause more task chains to be generated. This may result in the overhead of spawning tasks can become a limiting performance factor. Setting a high value will potentially cause fewer islands to be generated. This may reduce thread scaling (fewer task chains spawned) and may detrimentally affect performance if some bodies in the scene have large solver iteration counts because all constraints in a given island are solved by the maximum number of solver iterations requested by any body in the island.</p>
<p>Note that a rigid body solver task chain is spawned as soon as either a sufficient number of rigid bodies or articulations are batched together.</p>
<p><b>Default:</b> 16</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a0db918a532ef4d36474bf3f46cfad5a8" title="Sets the number of articulations required to spawn a separate rigid body solver thread. ">PxScene.setSolverArticulationBatchSize()</a> <a class="el" href="classPxScene.html#af11e6f5eedaa53bb4a1e3420e1c2c531" title="Retrieves the number of articulations required to spawn a separate rigid body solver thread...">PxScene.getSolverArticulationBatchSize()</a> </dd></dl>

</div>
</div>
<a id="a26b321b928708c10a047b38ec9127797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b321b928708c10a047b38ec9127797">&#9670;&nbsp;</a></span>solverBatchSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSceneDesc::solverBatchSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the number of actors required to spawn a separate rigid body solver island task chain. </p>
<p>This parameter defines the minimum number of actors required to spawn a separate rigid body solver task chain. Setting a low value will potentially cause more task chains to be generated. This may result in the overhead of spawning tasks can become a limiting performance factor. Setting a high value will potentially cause fewer islands to be generated. This may reduce thread scaling (fewer task chains spawned) and may detrimentally affect performance if some bodies in the scene have large solver iteration counts because all constraints in a given island are solved by the maximum number of solver iterations requested by any body in the island.</p>
<p>Note that a rigid body solver task chain is spawned as soon as either a sufficient number of rigid bodies or articulations are batched together.</p>
<p><b>Default:</b> 128</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#aad9cc8bf329f4de4b407436f5cd38c98" title="Sets the number of actors required to spawn a separate rigid body solver thread. ">PxScene.setSolverBatchSize()</a> <a class="el" href="classPxScene.html#add966317a1feb083e273fd8c12f454b5" title="Retrieves the number of actors required to spawn a separate rigid body solver thread. ">PxScene.getSolverBatchSize()</a> </dd></dl>

</div>
</div>
<a id="a166d622a6ea49c6e58be0b1d123f03ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166d622a6ea49c6e58be0b1d123f03ab">&#9670;&nbsp;</a></span>solverType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxSolverType.html#a96adc2f8785c6b18805a18b03289dbe6">PxSolverType::Enum</a> PxSceneDesc::solverType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the solver algorithm to use. </p>
<p><b>Default:</b> <a class="el" href="structPxSolverType.html#a96adc2f8785c6b18805a18b03289dbe6ae450cc99d8cedb7faff78689f1bc84f5" title="Default Projected Gauss-Seidel iterative solver. ">PxSolverType::ePGS</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxSolverType.html" title="Enum for selecting the type of solver used for the simulation. ">PxSolverType</a> <a class="el" href="classPxScene.html#a3bdf9385ce8be6ca3a4bf2e3f2a0ffec" title="Return the solver model. ">PxScene.getSolverType()</a> </dd></dl>

</div>
</div>
<a id="a1ff29795e987f8f9b347545468915de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff29795e987f8f9b347545468915de2">&#9670;&nbsp;</a></span>staticKineFilteringMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxPairFilteringMode.html#aeaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a> PxSceneDesc::staticKineFilteringMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filtering mode for static-kinematic pairs in the broadphase. </p>
<p><b>Default:</b> <a class="el" href="structPxPairFilteringMode.html#aeaa62ad327b874e4b199022401bf7615a464ca27835cd3bfe25854b99b6940c71" title="Default is eSUPPRESS for compatibility with previous PhysX versions. ">PxPairFilteringMode::eDEFAULT</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxPairFilteringMode.html">PxPairFilteringMode</a> <a class="el" href="classPxScene.html#a9fd01bd95bb91adf32f2020a51230cb6" title="Gets the pair filtering mode for static-kinematic pairs. ">PxScene.getStaticKinematicFilteringMode()</a> </dd></dl>

</div>
</div>
<a id="a63d40516cfbbe7d167d89e6fe55e3834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d40516cfbbe7d167d89e6fe55e3834">&#9670;&nbsp;</a></span>userData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* PxSceneDesc::userData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will be copied to <a class="el" href="classPxScene.html#a64fbe5f25cef90d47fcb1c6428efe15a" title="user can assign this to whatever, usually to create a 1:1 relationship with a user object...">PxScene::userData</a>. </p>
<p><b>Default:</b> NULL </p>

</div>
</div>
<a id="a79e2c9c06f711272a48d7f07451117b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e2c9c06f711272a48d7f07451117b7">&#9670;&nbsp;</a></span>wakeCounterResetValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSceneDesc::wakeCounterResetValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The wake counter reset value. </p>
<p>Calling wakeUp() on objects which support sleeping will set their wake counter value to the specified reset value.</p>
<p><b>Range:</b> (0, PX_MAX_F32)<br />
 <b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidDynamic.html#a4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping. ">PxRigidDynamic::wakeUp()</a> <a class="el" href="classPxArticulationReducedCoordinate.html#a48f00a3365ed0140df7fc58b6a09a170" title="Wakes up the articulation if it is sleeping. ">PxArticulationReducedCoordinate::wakeUp()</a> <a class="el" href="classPxScene.html#a287734b244b7ff6e40496e65d166ae95" title="Returns the wake counter reset value. ">PxScene.getWakeCounterResetValue()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__physics.html#ga7faafa414d3b4a468091cdaf785a931e">isValid()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxSceneDesc_8h_source.html">PxSceneDesc.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPxSceneDesc.html">PxSceneDesc</a></li>
    <li class="footer">Copyright &copy; 2008-2022 NVIDIA Corporation, 2788 San Tomas Expressway, Santa Clara, CA 95051 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a></li>
  </ul>
</div>
</body>
</html>
