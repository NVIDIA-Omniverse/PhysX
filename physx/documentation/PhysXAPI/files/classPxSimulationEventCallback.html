<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PxSimulationEventCallback Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PhysXLogoBlack.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classPxSimulationEventCallback.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classPxSimulationEventCallback-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxSimulationEventCallback Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An interface class that the user can implement in order to receive simulation events.  
 <a href="classPxSimulationEventCallback.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxSimulationEventCallback_8h_source.html">PxSimulationEventCallback.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67c6553ee9090481ece8b041502eb948"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a67c6553ee9090481ece8b041502eb948">onConstraintBreak</a> (<a class="el" href="structPxConstraintInfo.html">PxConstraintInfo</a> *constraints, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a67c6553ee9090481ece8b041502eb948"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when a breakable constraint breaks.  <a href="#a67c6553ee9090481ece8b041502eb948">More...</a><br /></td></tr>
<tr class="separator:a67c6553ee9090481ece8b041502eb948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e6f45b530cfb8536bc2ff14f38e2fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a37e6f45b530cfb8536bc2ff14f38e2fe">onWake</a> (<a class="el" href="classPxActor.html">PxActor</a> **actors, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a37e6f45b530cfb8536bc2ff14f38e2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called with the actors which have just been woken up.  <a href="#a37e6f45b530cfb8536bc2ff14f38e2fe">More...</a><br /></td></tr>
<tr class="separator:a37e6f45b530cfb8536bc2ff14f38e2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614256e6c2570e24cf45e974d6087d38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a614256e6c2570e24cf45e974d6087d38">onSleep</a> (<a class="el" href="classPxActor.html">PxActor</a> **actors, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a614256e6c2570e24cf45e974d6087d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called with the actors which have just been put to sleep.  <a href="#a614256e6c2570e24cf45e974d6087d38">More...</a><br /></td></tr>
<tr class="separator:a614256e6c2570e24cf45e974d6087d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc1da28643ccf9f77c8432b5eb2fd32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a4dc1da28643ccf9f77c8432b5eb2fd32">onContact</a> (const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> &amp;pairHeader, const <a class="el" href="structPxContactPair.html">PxContactPair</a> *pairs, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> nbPairs)=0</td></tr>
<tr class="memdesc:a4dc1da28643ccf9f77c8432b5eb2fd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when certain contact events occur.  <a href="#a4dc1da28643ccf9f77c8432b5eb2fd32">More...</a><br /></td></tr>
<tr class="separator:a4dc1da28643ccf9f77c8432b5eb2fd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768b2ee9fe28736da3fcdc6a0eae9733"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a768b2ee9fe28736da3fcdc6a0eae9733">onTrigger</a> (<a class="el" href="structPxTriggerPair.html">PxTriggerPair</a> *pairs, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a768b2ee9fe28736da3fcdc6a0eae9733"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called with the current trigger pair events.  <a href="#a768b2ee9fe28736da3fcdc6a0eae9733">More...</a><br /></td></tr>
<tr class="separator:a768b2ee9fe28736da3fcdc6a0eae9733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cd9bd80e504054d075fda24498756b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a86cd9bd80e504054d075fda24498756b">onAdvance</a> (const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> *const *bodyBuffer, const <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> *poseBuffer, const <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a86cd9bd80e504054d075fda24498756b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides early access to the new pose of moving rigid bodies.  <a href="#a86cd9bd80e504054d075fda24498756b">More...</a><br /></td></tr>
<tr class="separator:a86cd9bd80e504054d075fda24498756b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97f7e6f3dbccaeef1e3fa1578862e88"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#ae97f7e6f3dbccaeef1e3fa1578862e88">~PxSimulationEventCallback</a> ()</td></tr>
<tr class="separator:ae97f7e6f3dbccaeef1e3fa1578862e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An interface class that the user can implement in order to receive simulation events. </p>
<p>With the exception of <a class="el" href="classPxSimulationEventCallback.html#a86cd9bd80e504054d075fda24498756b" title="Provides early access to the new pose of moving rigid bodies. ">onAdvance()</a>, the events get sent during the call to either <a class="el" href="classPxScene.html#ab34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> or <a class="el" href="classPxScene.html#ab557fc677e9549c71d36979dfd3ec8c5" title="Clear internal buffers and free memory. ">PxScene::flushSimulation()</a> with sendPendingReports=true. <a class="el" href="classPxSimulationEventCallback.html#a86cd9bd80e504054d075fda24498756b" title="Provides early access to the new pose of moving rigid bodies. ">onAdvance()</a> gets called while the simulation is running (that is between <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate()</a> or <a class="el" href="classPxScene.html#a3a077c45dc9508f908373bb0f1a9df54" title="Performs dynamics phase of the simulation pipeline. ">PxScene::advance()</a> and <a class="el" href="classPxScene.html#ab34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>SDK state should not be modified from within the callbacks. In particular objects should not be created or destroyed. If state modification is needed then the changes should be stored to a buffer and performed after the simulation step.</dd></dl>
<p><b>Threading:</b> With the exception of <a class="el" href="classPxSimulationEventCallback.html#a86cd9bd80e504054d075fda24498756b" title="Provides early access to the new pose of moving rigid bodies. ">onAdvance()</a>, it is not necessary to make these callbacks thread safe as they will only be called in the context of the user thread.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a0cfa2d3835ea936ecd6ff94fbcefd689" title="Sets a user notify object which receives special simulation events when they occur. ">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxScene.html#a8951e43f8e23c320c1c90dd552135171" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback(). ">PxScene.getSimulationEventCallback()</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae97f7e6f3dbccaeef1e3fa1578862e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97f7e6f3dbccaeef1e3fa1578862e88">&#9670;&nbsp;</a></span>~PxSimulationEventCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxSimulationEventCallback::~PxSimulationEventCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a86cd9bd80e504054d075fda24498756b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cd9bd80e504054d075fda24498756b">&#9670;&nbsp;</a></span>onAdvance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onAdvance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> *const *&#160;</td>
          <td class="paramname"><em>bodyBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#ga8ddcfa21262bb645cbe896368cf1e7aa">PxTransform</a> *&#160;</td>
          <td class="paramname"><em>poseBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides early access to the new pose of moving rigid bodies. </p>
<p>When this call occurs, rigid bodies having the <a class="el" href="structPxRigidBodyFlag.html#a5fd4878ae66a98c030a9d976e8ba8596ac89b33b0290d667f6f2ae69298631d01" title="Register a rigid body for reporting pose changes by the simulation at an early stage. ">PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW</a> flag set, were moved by the simulation and their new poses can be accessed through the provided buffers.</p>
<dl class="section note"><dt>Note</dt><dd>The provided buffers are valid and can be read until the next call to <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate()</a> or <a class="el" href="classPxScene.html#a698947ec5653ac7a2c466122f393e477" title="Performs collision detection for the scene over elapsedTime. ">PxScene::collide()</a>.</dd>
<dd>
This callback gets triggered while the simulation is running. If the provided rigid body references are used to read properties of the object, then the callback has to guarantee no other thread is writing to the same body at the same time.</dd>
<dd>
The code in this callback should be lightweight as it can block the simulation, that is, the <a class="el" href="classPxScene.html#ab34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bodyBuffer</td><td>The rigid bodies that moved and requested early pose reporting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poseBuffer</td><td>The integrated rigid body poses of the bodies listed in bodyBuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of entries in the provided buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a0cfa2d3835ea936ecd6ff94fbcefd689" title="Sets a user notify object which receives special simulation events when they occur. ">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback. ">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxRigidBodyFlag.html#a5fd4878ae66a98c030a9d976e8ba8596ac89b33b0290d667f6f2ae69298631d01" title="Register a rigid body for reporting pose changes by the simulation at an early stage. ">PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW</a> </dd></dl>

</div>
</div>
<a id="a67c6553ee9090481ece8b041502eb948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c6553ee9090481ece8b041502eb948">&#9670;&nbsp;</a></span>onConstraintBreak()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onConstraintBreak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxConstraintInfo.html">PxConstraintInfo</a> *&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called when a breakable constraint breaks. </p>
<dl class="section note"><dt>Note</dt><dd>The user should not release the constraint shader inside this call!</dd>
<dd>
No event will get reported if the constraint breaks but gets deleted while the time step is still being simulated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>- The constraints which have been broken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of constraints</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints. ">PxConstraint</a> PxConstraintDesc.linearBreakForce PxConstraintDesc.angularBreakForce </dd></dl>

</div>
</div>
<a id="a4dc1da28643ccf9f77c8432b5eb2fd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc1da28643ccf9f77c8432b5eb2fd32">&#9670;&nbsp;</a></span>onContact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onContact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>pairHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxContactPair.html">PxContactPair</a> *&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>nbPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called when certain contact events occur. </p>
<p>The method will be called for a pair of actors if one of the colliding shape pairs requested contact notification. You request which events are reported using the filter shader/callback mechanism (see <a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a>, <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs. ">PxSimulationFilterCallback</a>, <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair. ">PxPairFlag</a>).</p>
<p>Do not keep references to the passed objects, as they will be invalid after this function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pairHeader</td><td>Information on the two actors whose shapes triggered a contact report. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>The contact pairs of two actors for which contact reports have been requested. See <a class="el" href="structPxContactPair.html" title="Contact report pair information. ">PxContactPair</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbPairs</td><td>The number of provided contact pairs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a0cfa2d3835ea936ecd6ff94fbcefd689" title="Sets a user notify object which receives special simulation events when they occur. ">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback. ">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxContactPair.html" title="Contact report pair information. ">PxContactPair</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair. ">PxPairFlag</a> <a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs. ">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div>
<a id="a614256e6c2570e24cf45e974d6087d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614256e6c2570e24cf45e974d6087d38">&#9670;&nbsp;</a></span>onSleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&#160;</td>
          <td class="paramname"><em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called with the actors which have just been put to sleep. </p>
<dl class="section note"><dt>Note</dt><dd>Only supported by rigid bodies yet. </dd>
<dd>
Only called on actors for which the <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor. ">PxActorFlag</a> eSEND_SLEEP_NOTIFIES has been set. </dd>
<dd>
Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is asleep, then A-&gt;wakeUp() gets called, then later A-&gt;putToSleep() gets called. At the next simulate/fetchResults() step only an <a class="el" href="classPxSimulationEventCallback.html#a614256e6c2570e24cf45e974d6087d38" title="This is called with the actors which have just been put to sleep. ">onSleep()</a> event will get triggered because that was the last transition (assuming the simulation does not wake the actor up). </dd>
<dd>
If an actor gets newly added to a scene with properties such that it is asleep and the sleep state does not get changed by the user or simulation, then an <a class="el" href="classPxSimulationEventCallback.html#a614256e6c2570e24cf45e974d6087d38" title="This is called with the actors which have just been put to sleep. ">onSleep()</a> event will get sent at the next simulate/fetchResults() step.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actors</td><td>- The actors which have just been put to sleep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of actors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a0cfa2d3835ea936ecd6ff94fbcefd689" title="Sets a user notify object which receives special simulation events when they occur. ">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback. ">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor. ">PxActorFlag</a> <a class="el" href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f" title="Raises or clears a particular actor flag. ">PxActor.setActorFlag()</a> </dd></dl>

</div>
</div>
<a id="a768b2ee9fe28736da3fcdc6a0eae9733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768b2ee9fe28736da3fcdc6a0eae9733">&#9670;&nbsp;</a></span>onTrigger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxTriggerPair.html">PxTriggerPair</a> *&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called with the current trigger pair events. </p>
<p>Shapes which have been marked as triggers using <a class="el" href="structPxShapeFlag.html#a6edb481aaa3a998c5d6dd3fc4ad87f1aaef2b90024dc86be72b68bbaf94a5821d" title="The shape is a trigger which can send reports whenever other shapes enter/leave its volume...">PxShapeFlag::eTRIGGER_SHAPE</a> will send events according to the pair flag specification in the filter shader (see <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair. ">PxPairFlag</a>, <a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Trigger shapes will no longer send notification events for interactions with other trigger shapes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>- The trigger pair events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of trigger pair events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a0cfa2d3835ea936ecd6ff94fbcefd689" title="Sets a user notify object which receives special simulation events when they occur. ">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback. ">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair. ">PxPairFlag</a> <a class="el" href="group__physics.html#ga235380b2a5b3cc89a4cd89d089d72b33" title="Filter method to specify how a pair of potentially colliding objects should be processed. ">PxSimulationFilterShader</a> <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes. ">PxShapeFlag</a> <a class="el" href="classPxShape.html#a3c879df184ef40514589c5aa3d1f2a33" title="Sets shape flags. ">PxShape.setFlag()</a> </dd></dl>

</div>
</div>
<a id="a37e6f45b530cfb8536bc2ff14f38e2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e6f45b530cfb8536bc2ff14f38e2fe">&#9670;&nbsp;</a></span>onWake()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onWake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&#160;</td>
          <td class="paramname"><em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called with the actors which have just been woken up. </p>
<dl class="section note"><dt>Note</dt><dd>Only supported by rigid bodies yet. </dd>
<dd>
Only called on actors for which the <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor. ">PxActorFlag</a> eSEND_SLEEP_NOTIFIES has been set. </dd>
<dd>
Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is awake, then A-&gt;putToSleep() gets called, then later A-&gt;wakeUp() gets called. At the next simulate/fetchResults() step only an <a class="el" href="classPxSimulationEventCallback.html#a37e6f45b530cfb8536bc2ff14f38e2fe" title="This is called with the actors which have just been woken up. ">onWake()</a> event will get triggered because that was the last transition. </dd>
<dd>
If an actor gets newly added to a scene with properties such that it is awake and the sleep state does not get changed by the user or simulation, then an <a class="el" href="classPxSimulationEventCallback.html#a37e6f45b530cfb8536bc2ff14f38e2fe" title="This is called with the actors which have just been woken up. ">onWake()</a> event will get sent at the next simulate/fetchResults() step.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actors</td><td>- The actors which just woke up. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of actors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxScene.html#a0cfa2d3835ea936ecd6ff94fbcefd689" title="Sets a user notify object which receives special simulation events when they occur. ">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback. ">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor. ">PxActorFlag</a> <a class="el" href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f" title="Raises or clears a particular actor flag. ">PxActor.setActorFlag()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxSimulationEventCallback_8h_source.html">PxSimulationEventCallback.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a></li>
    <li class="footer">Copyright &copy; 2008-2022 NVIDIA Corporation, 2788 San Tomas Expressway, Santa Clara, CA 95051 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a></li>
  </ul>
</div>
</body>
</html>
