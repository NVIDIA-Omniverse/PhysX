<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PxSoftBody Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PhysXLogoBlack.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classPxSoftBody.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classPxSoftBody-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxSoftBody Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a FEM softbody including everything to calculate its definition like geometry and material properties.  
 <a href="classPxSoftBody.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxSoftBody_8h_source.html">PxSoftBody.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PxSoftBody:</div>
<div class="dyncontent">
<div class="center"><img src="classPxSoftBody__inherit__graph.png" border="0" usemap="#PxSoftBody_inherit__map" alt="Inheritance graph"/></div>
<map name="PxSoftBody_inherit__map" id="PxSoftBody_inherit__map">
<area shape="rect" id="node2" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. " alt="" coords="16,80,85,107"/>
<area shape="rect" id="node3" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection. " alt="" coords="17,5,85,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for PxSoftBody:</div>
<div class="dyncontent">
<div class="center"><img src="classPxSoftBody__coll__graph.png" border="0" usemap="#PxSoftBody_coll__map" alt="Collaboration graph"/></div>
<map name="PxSoftBody_coll__map" id="PxSoftBody_coll__map">
<area shape="rect" id="node2" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. " alt="" coords="47,185,117,212"/>
<area shape="rect" id="node3" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection. " alt="" coords="48,109,116,136"/>
<area shape="rect" id="node4" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag\l::Enum, PxU16 \&gt;" alt="" coords="5,5,159,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a58604fd5ee8a1faa33f26f3d65274ab4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a58604fd5ee8a1faa33f26f3d65274ab4">~PxSoftBody</a> ()</td></tr>
<tr class="separator:a58604fd5ee8a1faa33f26f3d65274ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbf9e415c813765251014de0e54ea87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a6dbf9e415c813765251014de0e54ea87">setSoftBodyFlag</a> (<a class="el" href="structPxSoftBodyFlag.html#a4f389e612dabaf1fcee1a93365c28a2d">PxSoftBodyFlag::Enum</a> flag, bool val)=0</td></tr>
<tr class="memdesc:a6dbf9e415c813765251014de0e54ea87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single softbody flag.  <a href="#a6dbf9e415c813765251014de0e54ea87">More...</a><br /></td></tr>
<tr class="separator:a6dbf9e415c813765251014de0e54ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a29ca5485bb36b0abe449d73f594f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a97a29ca5485bb36b0abe449d73f594f6">setSoftBodyFlags</a> (<a class="el" href="group__physics.html#ga4bbe198b0dac953e8f058975b5aba958">PxSoftBodyFlags</a> flags)=0</td></tr>
<tr class="memdesc:a97a29ca5485bb36b0abe449d73f594f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the softbody flags.  <a href="#a97a29ca5485bb36b0abe449d73f594f6">More...</a><br /></td></tr>
<tr class="separator:a97a29ca5485bb36b0abe449d73f594f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c2614951180a80f70b0bbfbc752b34"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#ga4bbe198b0dac953e8f058975b5aba958">PxSoftBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#af2c2614951180a80f70b0bbfbc752b34">getSoftBodyFlag</a> () const =0</td></tr>
<tr class="memdesc:af2c2614951180a80f70b0bbfbc752b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the softbody flags.  <a href="#af2c2614951180a80f70b0bbfbc752b34">More...</a><br /></td></tr>
<tr class="separator:af2c2614951180a80f70b0bbfbc752b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8609ff71ad7b93ec7fde8cce60941eda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a8609ff71ad7b93ec7fde8cce60941eda">setParameter</a> (const <a class="el" href="structPxFEMParameters.html">PxFEMParameters</a> parameters)=0</td></tr>
<tr class="memdesc:a8609ff71ad7b93ec7fde8cce60941eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameter for FEM internal solve.  <a href="#a8609ff71ad7b93ec7fde8cce60941eda">More...</a><br /></td></tr>
<tr class="separator:a8609ff71ad7b93ec7fde8cce60941eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e538d47ae7a1a418959083b058ccdba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structPxFEMParameters.html">PxFEMParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a1e538d47ae7a1a418959083b058ccdba">getParameter</a> () const =0</td></tr>
<tr class="memdesc:a1e538d47ae7a1a418959083b058ccdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parameter for FEM internal solve.  <a href="#a1e538d47ae7a1a418959083b058ccdba">More...</a><br /></td></tr>
<tr class="separator:a1e538d47ae7a1a418959083b058ccdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad653456c5a98273efdd1a1c2a6a83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a43ad653456c5a98273efdd1a1c2a6a83">readData</a> (<a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a> flags, <a class="el" href="classPxBuffer.html">PxBuffer</a> &amp;buffer, bool flush=false)=0</td></tr>
<tr class="memdesc:a43ad653456c5a98273efdd1a1c2a6a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <a href="#a43ad653456c5a98273efdd1a1c2a6a83">More...</a><br /></td></tr>
<tr class="separator:a43ad653456c5a98273efdd1a1c2a6a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cf419e841151d0ce25ae99b08761d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a08cf419e841151d0ce25ae99b08761d7">readData</a> (<a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a> flags, bool flush=false)=0</td></tr>
<tr class="memdesc:a08cf419e841151d0ce25ae99b08761d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <a href="#a08cf419e841151d0ce25ae99b08761d7">More...</a><br /></td></tr>
<tr class="separator:a08cf419e841151d0ce25ae99b08761d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fd08c0cb5bd219a19986b784228fd7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a78fd08c0cb5bd219a19986b784228fd7">writeData</a> (<a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a> flags, <a class="el" href="classPxBuffer.html">PxBuffer</a> &amp;buffer, bool flush=false)=0</td></tr>
<tr class="memdesc:a78fd08c0cb5bd219a19986b784228fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <a href="#a78fd08c0cb5bd219a19986b784228fd7">More...</a><br /></td></tr>
<tr class="separator:a78fd08c0cb5bd219a19986b784228fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7a70ca890f63491a78f1dd39b4333f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a9d7a70ca890f63491a78f1dd39b4333f">writeData</a> (<a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a> flags, bool flush=false)=0</td></tr>
<tr class="memdesc:a9d7a70ca890f63491a78f1dd39b4333f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <a href="#a9d7a70ca890f63491a78f1dd39b4333f">More...</a><br /></td></tr>
<tr class="separator:a9d7a70ca890f63491a78f1dd39b4333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9361a4c7b06f713cec36a52a968c91"><td class="memItemLeft" align="right" valign="top">virtual PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#aad9361a4c7b06f713cec36a52a968c91">getCudaContextManager</a> () const =0</td></tr>
<tr class="memdesc:aad9361a4c7b06f713cec36a52a968c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cuda context manager.  <a href="#aad9361a4c7b06f713cec36a52a968c91">More...</a><br /></td></tr>
<tr class="separator:aad9361a4c7b06f713cec36a52a968c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a3a3a2ba5855b5a76d0940f91dbcc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a05a3a3a2ba5855b5a76d0940f91dbcc9">setWakeCounter</a> (<a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> wakeCounterValue)=0</td></tr>
<tr class="memdesc:a05a3a3a2ba5855b5a76d0940f91dbcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wake counter for the soft body.  <a href="#a05a3a3a2ba5855b5a76d0940f91dbcc9">More...</a><br /></td></tr>
<tr class="separator:a05a3a3a2ba5855b5a76d0940f91dbcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7292efe10a77c1f39d34e3844ed4d8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a5d7292efe10a77c1f39d34e3844ed4d8">getWakeCounter</a> () const =0</td></tr>
<tr class="memdesc:a5d7292efe10a77c1f39d34e3844ed4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wake counter of the articulation.  <a href="#a5d7292efe10a77c1f39d34e3844ed4d8">More...</a><br /></td></tr>
<tr class="separator:a5d7292efe10a77c1f39d34e3844ed4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4979a4c10cc3c8aaafb1794ca41235b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#aa4979a4c10cc3c8aaafb1794ca41235b">isSleeping</a> () const =0</td></tr>
<tr class="memdesc:aa4979a4c10cc3c8aaafb1794ca41235b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this soft body is sleeping.  <a href="#aa4979a4c10cc3c8aaafb1794ca41235b">More...</a><br /></td></tr>
<tr class="separator:aa4979a4c10cc3c8aaafb1794ca41235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3803fd72be58615bd9f124f39150076d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a3803fd72be58615bd9f124f39150076d">setSolverIterationCounts</a> (<a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> minPositionIters, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> minVelocityIters=1)=0</td></tr>
<tr class="memdesc:a3803fd72be58615bd9f124f39150076d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the solver iteration counts for the body.  <a href="#a3803fd72be58615bd9f124f39150076d">More...</a><br /></td></tr>
<tr class="separator:a3803fd72be58615bd9f124f39150076d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3fdb3bcf74fcb0bcd8908174642279"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#aaf3fdb3bcf74fcb0bcd8908174642279">getSolverIterationCounts</a> (<a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;minPositionIters, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;minVelocityIters) const =0</td></tr>
<tr class="memdesc:aaf3fdb3bcf74fcb0bcd8908174642279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the solver iteration counts.  <a href="#aaf3fdb3bcf74fcb0bcd8908174642279">More...</a><br /></td></tr>
<tr class="separator:aaf3fdb3bcf74fcb0bcd8908174642279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab86b3fa50a49c608f5b290645ba016"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxShape.html">PxShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a7ab86b3fa50a49c608f5b290645ba016">getShape</a> ()=0</td></tr>
<tr class="memdesc:a7ab86b3fa50a49c608f5b290645ba016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shape pointer belonging to the actor.  <a href="#a7ab86b3fa50a49c608f5b290645ba016">More...</a><br /></td></tr>
<tr class="separator:a7ab86b3fa50a49c608f5b290645ba016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d48558c411c289d5f02b7f4d0dc0617"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a8d48558c411c289d5f02b7f4d0dc0617">getCollisionMesh</a> ()=0</td></tr>
<tr class="memdesc:a8d48558c411c289d5f02b7f4d0dc0617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the collision mesh pointer.  <a href="#a8d48558c411c289d5f02b7f4d0dc0617">More...</a><br /></td></tr>
<tr class="separator:a8d48558c411c289d5f02b7f4d0dc0617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e6ded5d0d9cb5ac26e3bdcbd66225b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ae1e6ded5d0d9cb5ac26e3bdcbd66225b">getSimulationMesh</a> ()=0</td></tr>
<tr class="memdesc:ae1e6ded5d0d9cb5ac26e3bdcbd66225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation mesh pointer.  <a href="#ae1e6ded5d0d9cb5ac26e3bdcbd66225b">More...</a><br /></td></tr>
<tr class="separator:ae1e6ded5d0d9cb5ac26e3bdcbd66225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1372d2d0c5b2d470d0d787442f3c13d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxSoftBodyAuxData.html">PxSoftBodyAuxData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ad1372d2d0c5b2d470d0d787442f3c13d">getSoftBodyAuxData</a> ()=0</td></tr>
<tr class="memdesc:ad1372d2d0c5b2d470d0d787442f3c13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation state pointer.  <a href="#ad1372d2d0c5b2d470d0d787442f3c13d">More...</a><br /></td></tr>
<tr class="separator:ad1372d2d0c5b2d470d0d787442f3c13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b6b62cb0ea879436018a4fb28ac97d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ae4b6b62cb0ea879436018a4fb28ac97d">attachShape</a> (<a class="el" href="classPxShape.html">PxShape</a> &amp;shape)=0</td></tr>
<tr class="memdesc:ae4b6b62cb0ea879436018a4fb28ac97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a shape.  <a href="#ae4b6b62cb0ea879436018a4fb28ac97d">More...</a><br /></td></tr>
<tr class="separator:ae4b6b62cb0ea879436018a4fb28ac97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ba02212be6f6ff4e9e6c2c369f4470"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a86ba02212be6f6ff4e9e6c2c369f4470">attachSimulationMesh</a> (<a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a> &amp;simulationMesh, <a class="el" href="classPxSoftBodyAuxData.html">PxSoftBodyAuxData</a> &amp;softBodyAuxData)=0</td></tr>
<tr class="memdesc:a86ba02212be6f6ff4e9e6c2c369f4470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a simulation mesh.  <a href="#a86ba02212be6f6ff4e9e6c2c369f4470">More...</a><br /></td></tr>
<tr class="separator:a86ba02212be6f6ff4e9e6c2c369f4470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa4022a2769e32bb0e6c52e3fbff99a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a3fa4022a2769e32bb0e6c52e3fbff99a">detachShape</a> ()=0</td></tr>
<tr class="memdesc:a3fa4022a2769e32bb0e6c52e3fbff99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the shape.  <a href="#a3fa4022a2769e32bb0e6c52e3fbff99a">More...</a><br /></td></tr>
<tr class="separator:a3fa4022a2769e32bb0e6c52e3fbff99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab447b79b25f59aeea4e38be03e4802cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ab447b79b25f59aeea4e38be03e4802cf">detachSimulationMesh</a> ()=0</td></tr>
<tr class="memdesc:ab447b79b25f59aeea4e38be03e4802cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the simulation mesh.  <a href="#ab447b79b25f59aeea4e38be03e4802cf">More...</a><br /></td></tr>
<tr class="separator:ab447b79b25f59aeea4e38be03e4802cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f125fff89033d1f57c4fc62eb341257"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a9f125fff89033d1f57c4fc62eb341257">release</a> ()=0</td></tr>
<tr class="memdesc:a9f125fff89033d1f57c4fc62eb341257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the softbody.  <a href="#a9f125fff89033d1f57c4fc62eb341257">More...</a><br /></td></tr>
<tr class="separator:a9f125fff89033d1f57c4fc62eb341257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dc27b112525604e1834e24289408a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ad9dc27b112525604e1834e24289408a2">addParticleFilter</a> (<a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classPxParticleBuffer.html">PxParticleBuffer</a> *buffer, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> particleId, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetId)=0</td></tr>
<tr class="memdesc:ad9dc27b112525604e1834e24289408a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <a href="#ad9dc27b112525604e1834e24289408a2">More...</a><br /></td></tr>
<tr class="separator:ad9dc27b112525604e1834e24289408a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4513c65348d23ac90b5c8f4876887d1f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a4513c65348d23ac90b5c8f4876887d1f">removeParticleFilter</a> (<a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classPxParticleBuffer.html">PxParticleBuffer</a> *buffer, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> particleId, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetId)=0</td></tr>
<tr class="memdesc:a4513c65348d23ac90b5c8f4876887d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <a href="#a4513c65348d23ac90b5c8f4876887d1f">More...</a><br /></td></tr>
<tr class="separator:a4513c65348d23ac90b5c8f4876887d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6642f021a6183f1a186507ea121c099d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a6642f021a6183f1a186507ea121c099d">addParticleAttachment</a> (<a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classPxParticleBuffer.html">PxParticleBuffer</a> *buffer, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> particleId, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetId, const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;barycentric)=0</td></tr>
<tr class="memdesc:a6642f021a6183f1a186507ea121c099d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <a href="#a6642f021a6183f1a186507ea121c099d">More...</a><br /></td></tr>
<tr class="separator:a6642f021a6183f1a186507ea121c099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae362061ccf427420adad2670cddecfa0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ae362061ccf427420adad2670cddecfa0">removeParticleAttachment</a> (<a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *particlesystem, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> handle)=0</td></tr>
<tr class="memdesc:ae362061ccf427420adad2670cddecfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <a href="#ae362061ccf427420adad2670cddecfa0">More...</a><br /></td></tr>
<tr class="separator:ae362061ccf427420adad2670cddecfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095cdd9f23631f1cd40aeb1863096e27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a095cdd9f23631f1cd40aeb1863096e27">addRigidFilter</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> vertId)=0</td></tr>
<tr class="memdesc:a095cdd9f23631f1cd40aeb1863096e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a vertex in a soft body and a rigid body.  <a href="#a095cdd9f23631f1cd40aeb1863096e27">More...</a><br /></td></tr>
<tr class="separator:a095cdd9f23631f1cd40aeb1863096e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d084b9be28d36e2b60ed31c6ff7a01"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a83d084b9be28d36e2b60ed31c6ff7a01">removeRigidFilter</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> vertId)=0</td></tr>
<tr class="memdesc:a83d084b9be28d36e2b60ed31c6ff7a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a vertex in a soft body and a rigid body.  <a href="#a83d084b9be28d36e2b60ed31c6ff7a01">More...</a><br /></td></tr>
<tr class="separator:a83d084b9be28d36e2b60ed31c6ff7a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2c784d3079a0f2316141c55c2ddd35"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a5f2c784d3079a0f2316141c55c2ddd35">addRigidAttachment</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> vertId, const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structPxConeLimitedConstraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:a5f2c784d3079a0f2316141c55c2ddd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <a href="#a5f2c784d3079a0f2316141c55c2ddd35">More...</a><br /></td></tr>
<tr class="separator:a5f2c784d3079a0f2316141c55c2ddd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc6f89028db451c6318317362bd8357"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a7dc6f89028db451c6318317362bd8357">removeRigidAttachment</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> handle)=0</td></tr>
<tr class="memdesc:a7dc6f89028db451c6318317362bd8357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <a href="#a7dc6f89028db451c6318317362bd8357">More...</a><br /></td></tr>
<tr class="separator:a7dc6f89028db451c6318317362bd8357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812a36699e95047f9aa0ee8b2d5dfa05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a812a36699e95047f9aa0ee8b2d5dfa05">addTetRigidFilter</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIdx)=0</td></tr>
<tr class="memdesc:a812a36699e95047f9aa0ee8b2d5dfa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a rigid body.  <a href="#a812a36699e95047f9aa0ee8b2d5dfa05">More...</a><br /></td></tr>
<tr class="separator:a812a36699e95047f9aa0ee8b2d5dfa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee868b0dd33b427ab4bc4d9d36cb782b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#aee868b0dd33b427ab4bc4d9d36cb782b">removeTetRigidFilter</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIdx)=0</td></tr>
<tr class="memdesc:aee868b0dd33b427ab4bc4d9d36cb782b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a rigid body.  <a href="#aee868b0dd33b427ab4bc4d9d36cb782b">More...</a><br /></td></tr>
<tr class="separator:aee868b0dd33b427ab4bc4d9d36cb782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a232fd92961f42e1878c517376cb63a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a7a232fd92961f42e1878c517376cb63a">addTetRigidAttachment</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIdx, const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;barycentric, const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structPxConeLimitedConstraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:a7a232fd92961f42e1878c517376cb63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <a href="#a7a232fd92961f42e1878c517376cb63a">More...</a><br /></td></tr>
<tr class="separator:a7a232fd92961f42e1878c517376cb63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9648fc400f4f4e9cc708495ac93d10d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#af9648fc400f4f4e9cc708495ac93d10d">addSoftBodyFilter</a> (<a class="el" href="classPxSoftBody.html">PxSoftBody</a> *otherSoftBody, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> otherTetIdx, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIdx1)=0</td></tr>
<tr class="memdesc:af9648fc400f4f4e9cc708495ac93d10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a tetrahedron in another soft body.  <a href="#af9648fc400f4f4e9cc708495ac93d10d">More...</a><br /></td></tr>
<tr class="separator:af9648fc400f4f4e9cc708495ac93d10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa883fef5ece820ce66d20419d240a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a3fa883fef5ece820ce66d20419d240a1">removeSoftBodyFilter</a> (<a class="el" href="classPxSoftBody.html">PxSoftBody</a> *otherSoftBody, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> otherTetIdx, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIdx1)=0</td></tr>
<tr class="memdesc:a3fa883fef5ece820ce66d20419d240a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a tetrahedron in other soft body.  <a href="#a3fa883fef5ece820ce66d20419d240a1">More...</a><br /></td></tr>
<tr class="separator:a3fa883fef5ece820ce66d20419d240a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af30e552398a41ecca0e0de0e6d21be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a7af30e552398a41ecca0e0de0e6d21be">addSoftBodyFilters</a> (<a class="el" href="classPxSoftBody.html">PxSoftBody</a> *otherSoftBody, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *otherTetIndices, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *tetIndices, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIndicesSize)=0</td></tr>
<tr class="memdesc:a7af30e552398a41ecca0e0de0e6d21be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filters between a tetrahedron in a soft body with another soft body.  <a href="#a7af30e552398a41ecca0e0de0e6d21be">More...</a><br /></td></tr>
<tr class="separator:a7af30e552398a41ecca0e0de0e6d21be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2acd0c6e03093a0f5898b0759302d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a6c2acd0c6e03093a0f5898b0759302d3">removeSoftBodyFilters</a> (<a class="el" href="classPxSoftBody.html">PxSoftBody</a> *otherSoftBody, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *otherTetIndices, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *tetIndices, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIndicesSize)=0</td></tr>
<tr class="memdesc:a6c2acd0c6e03093a0f5898b0759302d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filters between a tetrahedron in a soft body with another soft body.  <a href="#a6c2acd0c6e03093a0f5898b0759302d3">More...</a><br /></td></tr>
<tr class="separator:a6c2acd0c6e03093a0f5898b0759302d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9823e81b8a0bdff3fe9518abeca0f55e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a9823e81b8a0bdff3fe9518abeca0f55e">addSoftBodyAttachment</a> (<a class="el" href="classPxSoftBody.html">PxSoftBody</a> *softbody0, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIdx0, const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;tetBarycentric0, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> tetIdx1, const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;tetBarycentric1, <a class="el" href="structPxConeLimitedConstraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:a9823e81b8a0bdff3fe9518abeca0f55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between two soft bodies.  <a href="#a9823e81b8a0bdff3fe9518abeca0f55e">More...</a><br /></td></tr>
<tr class="separator:a9823e81b8a0bdff3fe9518abeca0f55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbad2a586d0f0e89a665f12f0f443bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#aecbad2a586d0f0e89a665f12f0f443bd">removeSoftBodyAttachment</a> (<a class="el" href="classPxSoftBody.html">PxSoftBody</a> *softbody0, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> handle)=0</td></tr>
<tr class="memdesc:aecbad2a586d0f0e89a665f12f0f443bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attachment between a soft body and the other soft body. Be aware that destroying the soft body before destroying the attachment is illegal and may cause a crash.  <a href="#aecbad2a586d0f0e89a665f12f0f443bd">More...</a><br /></td></tr>
<tr class="separator:aecbad2a586d0f0e89a665f12f0f443bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca1ca10f4d7fdc8f791ccb566e05688"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a3ca1ca10f4d7fdc8f791ccb566e05688">getSimPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:a3ca1ca10f4d7fdc8f791ccb566e05688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <a href="#a3ca1ca10f4d7fdc8f791ccb566e05688">More...</a><br /></td></tr>
<tr class="separator:a3ca1ca10f4d7fdc8f791ccb566e05688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08902c6d1b81c7ca1f9709cee7b1c05b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a08902c6d1b81c7ca1f9709cee7b1c05b">getKinematicTargetCPU</a> ()=0</td></tr>
<tr class="memdesc:a08902c6d1b81c7ca1f9709cee7b1c05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <a href="#a08902c6d1b81c7ca1f9709cee7b1c05b">More...</a><br /></td></tr>
<tr class="separator:a08902c6d1b81c7ca1f9709cee7b1c05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a26d4abd7f35146b84040deb9d28497"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a3a26d4abd7f35146b84040deb9d28497">getSimVelocityInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:a3a26d4abd7f35146b84040deb9d28497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the velocities of the simulation mesh on the host.  <a href="#a3a26d4abd7f35146b84040deb9d28497">More...</a><br /></td></tr>
<tr class="separator:a3a26d4abd7f35146b84040deb9d28497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2959c16d25c9b1902b14d41c826fa9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ada2959c16d25c9b1902b14d41c826fa9">getPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:ada2959c16d25c9b1902b14d41c826fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the collision mesh on the host.  <a href="#ada2959c16d25c9b1902b14d41c826fa9">More...</a><br /></td></tr>
<tr class="separator:ada2959c16d25c9b1902b14d41c826fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88d95a01e350b4e408a0ca05a074d7b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#af88d95a01e350b4e408a0ca05a074d7b">getRestPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:af88d95a01e350b4e408a0ca05a074d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the rest vertices of the collision mesh on the host.  <a href="#af88d95a01e350b4e408a0ca05a074d7b">More...</a><br /></td></tr>
<tr class="separator:af88d95a01e350b4e408a0ca05a074d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e4d4d333dfc6206a9fd87b0057d6a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a09e4d4d333dfc6206a9fd87b0057d6a7">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:a09e4d4d333dfc6206a9fd87b0057d6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the soft body.  <a href="#a09e4d4d333dfc6206a9fd87b0057d6a7">More...</a><br /></td></tr>
<tr class="separator:a09e4d4d333dfc6206a9fd87b0057d6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b98f73e862481847f938266f3effd0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#af9b98f73e862481847f938266f3effd0">getGpuSoftBodyIndex</a> ()=0</td></tr>
<tr class="memdesc:af9b98f73e862481847f938266f3effd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU soft body index.  <a href="#af9b98f73e862481847f938266f3effd0">More...</a><br /></td></tr>
<tr class="separator:af9b98f73e862481847f938266f3effd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxActor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structPxActorType.html#a25c5a270f1f5c1955a00d7554f7688d7">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a76a3489218f85ce9fe3ffb883ba8ce63">getType</a> () const =0</td></tr>
<tr class="memdesc:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <a href="classPxActor.html#a76a3489218f85ce9fe3ffb883ba8ce63">More...</a><br /></td></tr>
<tr class="separator:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxScene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a2bf2e48b1960ef8e4fc1a437473bd7a3">getScene</a> () const =0</td></tr>
<tr class="memdesc:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <a href="classPxActor.html#a2bf2e48b1960ef8e4fc1a437473bd7a3">More...</a><br /></td></tr>
<tr class="separator:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e" title="Retrieves the name string set with setName(). ">getName()</a>.  <a href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758">More...</a><br /></td></tr>
<tr class="separator:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e">getName</a> () const =0</td></tr>
<tr class="memdesc:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758" title="Sets a name string for the object that can be retrieved with getName(). ">setName()</a>.  <a href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e">More...</a><br /></td></tr>
<tr class="separator:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f">setActorFlag</a> (<a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1d">PxActorFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular actor flag.  <a href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f">More...</a><br /></td></tr>
<tr class="separator:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#af60720e190324e8ff36281a2360c6043">setActorFlags</a> (<a class="el" href="group__physics.html#ga468ad85db838378f0c58cfd02a96949b">PxActorFlags</a> inFlags)=0</td></tr>
<tr class="memdesc:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor flags.  <a href="classPxActor.html#af60720e190324e8ff36281a2360c6043">More...</a><br /></td></tr>
<tr class="separator:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#ga468ad85db838378f0c58cfd02a96949b">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#afb92fb228de76bbcd42210d060b558d1">getActorFlags</a> () const =0</td></tr>
<tr class="memdesc:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. ">PxActor</a> flags.  <a href="classPxActor.html#afb92fb228de76bbcd42210d060b558d1">More...</a><br /></td></tr>
<tr class="separator:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a614c46687cf76eb219ce47927fc90824">setDominanceGroup</a> (<a class="el" href="group__physics.html#gaf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> dominanceGroup)=0</td></tr>
<tr class="memdesc:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <a href="classPxActor.html#a614c46687cf76eb219ce47927fc90824">More...</a><br /></td></tr>
<tr class="separator:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#gaf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a24602fee489b3e797ff0f82613eef755">getDominanceGroup</a> () const =0</td></tr>
<tr class="memdesc:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classPxActor.html#a614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier. ">setDominanceGroup()</a>.  <a href="classPxActor.html#a24602fee489b3e797ff0f82613eef755">More...</a><br /></td></tr>
<tr class="separator:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a9bb8613863cf1d73e4d0c0227f25bc6e">setOwnerClient</a> (<a class="el" href="PxClient_8h.html#acb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> inClient)=0</td></tr>
<tr class="memdesc:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner client of an actor.  <a href="classPxActor.html#a9bb8613863cf1d73e4d0c0227f25bc6e">More...</a><br /></td></tr>
<tr class="separator:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="PxClient_8h.html#acb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a660828fb83c91f0ada2ca43e06aa2b35">getOwnerClient</a> () const =0</td></tr>
<tr class="memdesc:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner client that was specified at creation time.  <a href="classPxActor.html#a660828fb83c91f0ada2ca43e06aa2b35">More...</a><br /></td></tr>
<tr class="separator:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#aaedfdd3e9acc77afc2fc0ba51d968876">getAggregate</a> () const =0</td></tr>
<tr class="memdesc:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the aggregate the actor might be a part of.  <a href="classPxActor.html#aaedfdd3e9acc77afc2fc0ba51d968876">More...</a><br /></td></tr>
<tr class="separator:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a67fe206d8897ddce896c371ac8d789a9 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a67fe206d8897ddce896c371ac8d789a9">getConcreteTypeName</a> () const =0</td></tr>
<tr class="memdesc:a67fe206d8897ddce896c371ac8d789a9 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <a href="classPxBase.html#a67fe206d8897ddce896c371ac8d789a9">More...</a><br /></td></tr>
<tr class="separator:a67fe206d8897ddce896c371ac8d789a9 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a4bc720adef86ea68bfb5845f0e104d23">is</a> ()</td></tr>
<tr class="separator:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a85aa50ac0e5670a2be64411fea62b5e3">is</a> () const</td></tr>
<tr class="separator:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#ab4e0691a08e49631dc60014d49c7585f">getConcreteType</a> () const</td></tr>
<tr class="memdesc:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns concrete type of object.  <a href="classPxBase.html#ab4e0691a08e49631dc60014d49c7585f">More...</a><br /></td></tr>
<tr class="separator:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a1dd20bb574075df904e1878f2e771ef9">setBaseFlag</a> (<a class="el" href="structPxBaseFlag.html#ac258de0c7adaa37f81b6ab1b0c86a6ee">PxBaseFlag::Enum</a> flag, bool value)</td></tr>
<tr class="memdesc:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="structPxBaseFlag.html" title="Flags for PxBase. ">PxBaseFlag</a>.  <a href="classPxBase.html#a1dd20bb574075df904e1878f2e771ef9">More...</a><br /></td></tr>
<tr class="separator:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#afb391b692c561df0a54c413785e4ebd0">setBaseFlags</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> inFlags)</td></tr>
<tr class="memdesc:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PxBaseFlags.  <a href="classPxBase.html#afb391b692c561df0a54c413785e4ebd0">More...</a><br /></td></tr>
<tr class="separator:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#ad9b10efae7733ff9c8b8d3b7d90a9a5f">getBaseFlags</a> () const</td></tr>
<tr class="memdesc:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns PxBaseFlags.  <a href="classPxBase.html#ad9b10efae7733ff9c8b8d3b7d90a9a5f">More...</a><br /></td></tr>
<tr class="separator:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a38952fcb80e99f1f5dbf774a75ac2c3d">isReleasable</a> () const</td></tr>
<tr class="memdesc:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the object is subordinate.  <a href="classPxBase.html#a38952fcb80e99f1f5dbf774a75ac2c3d">More...</a><br /></td></tr>
<tr class="separator:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae647450793991c7dbd8eecc25c44ef0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#ae647450793991c7dbd8eecc25c44ef0f">PxSoftBody</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ae647450793991c7dbd8eecc25c44ef0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7132e0100a6a246ed1a490d54455511f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSoftBody.html#a7132e0100a6a246ed1a490d54455511f">PxSoftBody</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a7132e0100a6a246ed1a490d54455511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxActor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:a05d86747e2fc14c89497fa06c8f0f252 inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a05d86747e2fc14c89497fa06c8f0f252">PxActor</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a05d86747e2fc14c89497fa06c8f0f252 inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1780362a59125a7d22619937b2d7a511 inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a1780362a59125a7d22619937b2d7a511">PxActor</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a1780362a59125a7d22619937b2d7a511 inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c683780b093e7c9348b9e0fd8836d inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ad20c683780b093e7c9348b9e0fd8836d">~PxActor</a> ()</td></tr>
<tr class="separator:ad20c683780b093e7c9348b9e0fd8836d inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05f7f0b43be28414e77402097ec659d inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ac05f7f0b43be28414e77402097ec659d">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:ac05f7f0b43be28414e77402097ec659d inherit pro_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="classPxActor.html#ac05f7f0b43be28414e77402097ec659d">More...</a><br /></td></tr>
<tr class="separator:ac05f7f0b43be28414e77402097ec659d inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a263f1ef821c74058ce9335e06cb842a4">PxBase</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor setting concrete type and base flags.  <a href="classPxBase.html#a263f1ef821c74058ce9335e06cb842a4">More...</a><br /></td></tr>
<tr class="separator:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a58b979202e7382701f74977fe3dd5c6f">PxBase</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor setting base flags.  <a href="classPxBase.html#a58b979202e7382701f74977fe3dd5c6f">More...</a><br /></td></tr>
<tr class="separator:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#adfbf62dc32775b068db1c74c7fd3d982">~PxBase</a> ()</td></tr>
<tr class="memdesc:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classPxBase.html#adfbf62dc32775b068db1c74c7fd3d982">More...</a><br /></td></tr>
<tr class="separator:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a3782ca64c8f12c41443f604e300fc207">typeMatch</a> () const</td></tr>
<tr class="separator:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classPxActor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ace426ce4cca4de88806beee01eb4b87e">userData</a></td></tr>
<tr class="memdesc:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="classPxActor.html#ace426ce4cca4de88806beee01eb4b87e">More...</a><br /></td></tr>
<tr class="separator:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classPxBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a1abe9d19726e1f8f8e56abeb2269b5d4 inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a1abe9d19726e1f8f8e56abeb2269b5d4">mConcreteType</a></td></tr>
<tr class="separator:a1abe9d19726e1f8f8e56abeb2269b5d4 inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7105f65905ecb9f6f7993ba28b712d inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#aff7105f65905ecb9f6f7993ba28b712d">mBaseFlags</a></td></tr>
<tr class="separator:aff7105f65905ecb9f6f7993ba28b712d inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c4aea9ecffd5106ef27ee9e86a2bb9 inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a75c4aea9ecffd5106ef27ee9e86a2bb9">mBuiltInRefCount</a></td></tr>
<tr class="separator:a75c4aea9ecffd5106ef27ee9e86a2bb9 inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a FEM softbody including everything to calculate its definition like geometry and material properties. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a58604fd5ee8a1faa33f26f3d65274ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58604fd5ee8a1faa33f26f3d65274ab4">&#9670;&nbsp;</a></span>~PxSoftBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxSoftBody::~PxSoftBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae647450793991c7dbd8eecc25c44ef0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae647450793991c7dbd8eecc25c44ef0f">&#9670;&nbsp;</a></span>PxSoftBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> PxSoftBody::PxSoftBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td>
          <td class="paramname"><em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td>
          <td class="paramname"><em>baseFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7132e0100a6a246ed1a490d54455511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7132e0100a6a246ed1a490d54455511f">&#9670;&nbsp;</a></span>PxSoftBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> PxSoftBody::PxSoftBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td>
          <td class="paramname"><em>baseFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6642f021a6183f1a186507ea121c099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6642f021a6183f1a186507ea121c099d">&#9670;&nbsp;</a></span>addParticleAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSoftBody::addParticleAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxParticleBuffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>barycentric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classPxParticleBuffer.html" title="The shared base class for all particle buffers, can be instantiated directly to specify granular and ...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle that is attached to a tetrahedron in the soft body's collision mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetrahedron in the soft body's collision mesh to attach the particle to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barycentric</td><td>The barycentric coordinates of the particle attachment position with respect to the tetrahedron specified with tetId. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

</div>
</div>
<a id="ad9dc27b112525604e1834e24289408a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dc27b112525604e1834e24289408a2">&#9670;&nbsp;</a></span>addParticleFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::addParticleFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxParticleBuffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a collision filter between a particle and a tetrahedron in the soft body's collision mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classPxParticleBuffer.html" title="The shared base class for all particle buffers, can be instantiated directly to specify granular and ...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle whose collisions with the tetrahedron in the soft body are filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetradedron in the soft body that is filtered. If tetId is PX_MAX_TETID, this particle will filter against all tetrahedra in this soft body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f2c784d3079a0f2316141c55c2ddd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2c784d3079a0f2316141c55c2ddd35">&#9670;&nbsp;</a></span>addRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSoftBody::addRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>vertId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>actorSpacePose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConeLimitedConstraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method attaches a vertex on the soft body collision mesh to the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh that gets attached to the rigid body. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actorSpacePose</td><td>The location of the attachment point expressed in the rigid body's coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a vertex in the soft body and rigid body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to relese the attachment later </dd></dl>

</div>
</div>
<a id="a095cdd9f23631f1cd40aeb1863096e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095cdd9f23631f1cd40aeb1863096e27">&#9670;&nbsp;</a></span>addRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::addRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>vertId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a collision filter between a vertex in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh whose collisions with the rigid body are filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9823e81b8a0bdff3fe9518abeca0f55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9823e81b8a0bdff3fe9518abeca0f55e">&#9670;&nbsp;</a></span>addSoftBodyAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSoftBody::addSoftBodyAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSoftBody.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>softbody0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIdx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIdx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConeLimitedConstraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between two soft bodies. </p>
<p>This method attaches a point inside a tetrahedron of the collision mesh to a point in another soft body's tetrahedron collision mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">softbody0</td><td>The soft body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx0</td><td>The index of a tetrahedron in the other soft body that contains the point to be attached to the soft body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric0</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the softbody0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric1</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between tets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

</div>
</div>
<a id="af9648fc400f4f4e9cc708495ac93d10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9648fc400f4f4e9cc708495ac93d10d">&#9670;&nbsp;</a></span>addSoftBodyFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::addSoftBodyFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSoftBody.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>otherTetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIdx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a tetrahedron in another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIdx</td><td>The index of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of the tetrahedron in the softbody's collision mesh to be filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7af30e552398a41ecca0e0de0e6d21be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af30e552398a41ecca0e0de0e6d21be">&#9670;&nbsp;</a></span>addSoftBodyFilters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::addSoftBodyFilters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSoftBody.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *&#160;</td>
          <td class="paramname"><em>otherTetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *&#160;</td>
          <td class="paramname"><em>tetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIndicesSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filters between a tetrahedron in a soft body with another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIndices</td><td>The indices of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndices</td><td>The indices of the tetrahedron of the softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndicesSize</td><td>The size of tetIndices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a232fd92961f42e1878c517376cb63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a232fd92961f42e1878c517376cb63a">&#9670;&nbsp;</a></span>addTetRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSoftBody::addTetRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#ga7346068a75502045a7c8f65e7dcee471">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>barycentric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gae91c92d849735e5ef8906ccfd6fc1f20">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>actorSpacePose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConeLimitedConstraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method attaches a point inside a tetrahedron of the collision to the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the rigid body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barycentric</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actorSpacePose</td><td>The location of the attachment point expressed in the rigid body's coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a tet and rigid body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

</div>
</div>
<a id="a812a36699e95047f9aa0ee8b2d5dfa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812a36699e95047f9aa0ee8b2d5dfa05">&#9670;&nbsp;</a></span>addTetRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::addTetRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh whose collisions with the rigid body is filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4b6b62cb0ea879436018a4fb28ac97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b6b62cb0ea879436018a4fb28ac97d">&#9670;&nbsp;</a></span>attachShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxSoftBody::attachShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a shape. </p>
<p>Attaches the shape to use for collision detection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The shape to use for collisions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful </dd></dl>

</div>
</div>
<a id="a86ba02212be6f6ff4e9e6c2c369f4470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ba02212be6f6ff4e9e6c2c369f4470">&#9670;&nbsp;</a></span>attachSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxSoftBody::attachSimulationMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSoftBodyAuxData.html">PxSoftBodyAuxData</a> &amp;&#160;</td>
          <td class="paramname"><em>softBodyAuxData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a simulation mesh. </p>
<p>Attaches the simulation mesh (geometry) and a state containing inverse mass, rest pose etc. required to compute the softbody deformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>The tetrahedral mesh used to compute the softbody's deformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softBodyAuxData</td><td>A state that contain a mapping from simulation to collision mesh, volume information etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful </dd></dl>

</div>
</div>
<a id="a3fa4022a2769e32bb0e6c52e3fbff99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa4022a2769e32bb0e6c52e3fbff99a">&#9670;&nbsp;</a></span>detachShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::detachShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the shape. </p>
<p>Detaches the shape used for collision detection.</p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classPxSoftBody.html#ab447b79b25f59aeea4e38be03e4802cf" title="Detaches the simulation mesh. ">detachSimulationMesh()</a> </dd></dl>

</div>
</div>
<a id="ab447b79b25f59aeea4e38be03e4802cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab447b79b25f59aeea4e38be03e4802cf">&#9670;&nbsp;</a></span>detachSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::detachSimulationMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the simulation mesh. </p>
<p>Detaches the simulation mesh and simulation state used to compute the softbody deformation.</p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classPxSoftBody.html#a3fa4022a2769e32bb0e6c52e3fbff99a" title="Detaches the shape. ">detachShape()</a> </dd></dl>

</div>
</div>
<a id="a8d48558c411c289d5f02b7f4d0dc0617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d48558c411c289d5f02b7f4d0dc0617">&#9670;&nbsp;</a></span>getCollisionMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a>* PxSoftBody::getCollisionMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the collision mesh pointer. </p>
<p>Allows to access the geometry of the tetrahedral mesh used to perform collision detection</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the collision mesh </dd></dl>

</div>
</div>
<a id="aad9361a4c7b06f713cec36a52a968c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9361a4c7b06f713cec36a52a968c91">&#9670;&nbsp;</a></span>getCudaContextManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCudaContextManager* PxSoftBody::getCudaContextManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cuda context manager. </p>
<dl class="section return"><dt>Returns</dt><dd>The cuda context manager </dd></dl>

</div>
</div>
<a id="af9b98f73e862481847f938266f3effd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b98f73e862481847f938266f3effd0">&#9670;&nbsp;</a></span>getGpuSoftBodyIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxSoftBody::getGpuSoftBodyIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GPU soft body index. </p>
<dl class="section return"><dt>Returns</dt><dd>The GPU index, or 0xFFFFFFFF if the soft body is not in a scene. </dd></dl>

</div>
</div>
<a id="a08902c6d1b81c7ca1f9709cee7b1c05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08902c6d1b81c7ca1f9709cee7b1c05b">&#9670;&nbsp;</a></span>getKinematicTargetCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a>* PxSoftBody::getKinematicTargetCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simVelocityCPU buffer at the same index. A copy of this value is stored in the simVelocityCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

</div>
</div>
<a id="a1e538d47ae7a1a418959083b058ccdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e538d47ae7a1a418959083b058ccdba">&#9670;&nbsp;</a></span>getParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxFEMParameters.html">PxFEMParameters</a> PxSoftBody::getParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get parameter for FEM internal solve. </p>
<dl class="section return"><dt>Returns</dt><dd>The FEM parameters </dd></dl>

</div>
</div>
<a id="ada2959c16d25c9b1902b14d41c826fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2959c16d25c9b1902b14d41c826fa9">&#9670;&nbsp;</a></span>getPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a>* PxSoftBody::getPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the collision mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass on the collision mesh has no effect, it can be set to an arbitrary value.</p>
<p>Allows to access the CPU buffer of the collision mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the collision mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

</div>
</div>
<a id="af88d95a01e350b4e408a0ca05a074d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88d95a01e350b4e408a0ca05a074d7b">&#9670;&nbsp;</a></span>getRestPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a>* PxSoftBody::getRestPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the rest vertices of the collision mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass on the collision mesh has no effect, it can be set to an arbitrary value.</p>
<p>Allows to access the CPU buffer of the collision mesh's rest vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the collision mesh's rest vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

</div>
</div>
<a id="a7ab86b3fa50a49c608f5b290645ba016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab86b3fa50a49c608f5b290645ba016">&#9670;&nbsp;</a></span>getShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxShape.html">PxShape</a>* PxSoftBody::getShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the shape pointer belonging to the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the collision mesh's shape </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes. ">PxShape</a> getNbShapes() <a class="el" href="classPxShape.html#a165dc6eaf5c58997b90b06176220be37" title="Decrements the reference count of a shape and releases it if the new reference count is zero...">PxShape::release()</a> </dd></dl>

</div>
</div>
<a id="a3ca1ca10f4d7fdc8f791ccb566e05688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca1ca10f4d7fdc8f791ccb566e05688">&#9670;&nbsp;</a></span>getSimPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a>* PxSoftBody::getSimPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simVelocityCPU buffer at the same index. A copy of this value is stored in the simVelocityCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

</div>
</div>
<a id="ae1e6ded5d0d9cb5ac26e3bdcbd66225b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e6ded5d0d9cb5ac26e3bdcbd66225b">&#9670;&nbsp;</a></span>getSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTetrahedronMesh.html">PxTetrahedronMesh</a>* PxSoftBody::getSimulationMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the simulation mesh pointer. </p>
<p>Allows to access the geometry of the tetrahedral mesh used to compute the object's deformation</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the simulation mesh </dd></dl>

</div>
</div>
<a id="a3a26d4abd7f35146b84040deb9d28497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a26d4abd7f35146b84040deb9d28497">&#9670;&nbsp;</a></span>getSimVelocityInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBuffer.html">PxBuffer</a>* PxSoftBody::getSimVelocityInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the velocities of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing velocity and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simPositionInvMassCPU buffer at the same index. A copy of this value is stored in the simPositionInvMassCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's velocities (x, y, z) and the inverse mass as 4th component </dd></dl>

</div>
</div>
<a id="ad1372d2d0c5b2d470d0d787442f3c13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1372d2d0c5b2d470d0d787442f3c13d">&#9670;&nbsp;</a></span>getSoftBodyAuxData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSoftBodyAuxData.html">PxSoftBodyAuxData</a>* PxSoftBody::getSoftBodyAuxData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the simulation state pointer. </p>
<p>Allows to access the additional data of the simulation mesh (inverse mass, rest state etc.). The geometry part of the data is stored in the simulation mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the simulation state </dd></dl>

</div>
</div>
<a id="af2c2614951180a80f70b0bbfbc752b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c2614951180a80f70b0bbfbc752b34">&#9670;&nbsp;</a></span>getSoftBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__physics.html#ga4bbe198b0dac953e8f058975b5aba958">PxSoftBodyFlags</a> PxSoftBody::getSoftBodyFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the softbody flags. </p>
<dl class="section return"><dt>Returns</dt><dd>The softbody flags </dd></dl>

</div>
</div>
<a id="aaf3fdb3bcf74fcb0bcd8908174642279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3fdb3bcf74fcb0bcd8908174642279">&#9670;&nbsp;</a></span>getSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::getSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&#160;</td>
          <td class="paramname"><em>minVelocityIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the solver iteration counts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#a3803fd72be58615bd9f124f39150076d" title="Sets the solver iteration counts for the body. ">setSolverIterationCounts()</a> </dd></dl>

</div>
</div>
<a id="a5d7292efe10a77c1f39d34e3844ed4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7292efe10a77c1f39d34e3844ed4d8">&#9670;&nbsp;</a></span>getWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a> PxSoftBody::getWakeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wake counter of the articulation. </p>
<dl class="section return"><dt>Returns</dt><dd>The wake counter of the articulation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#aa4979a4c10cc3c8aaafb1794ca41235b" title="Returns true if this soft body is sleeping. ">isSleeping()</a> <a class="el" href="classPxSoftBody.html#a05a3a3a2ba5855b5a76d0940f91dbcc9" title="Sets the wake counter for the soft body. ">setWakeCounter()</a> </dd></dl>

</div>
</div>
<a id="a09e4d4d333dfc6206a9fd87b0057d6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e4d4d333dfc6206a9fd87b0057d6a7">&#9670;&nbsp;</a></span>getWorldBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a> PxSoftBody::getWorldBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inflation</em> = <code>1.01f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the axis aligned bounding box enclosing the soft body. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classPxScene.html#a698947ec5653ac7a2c466122f393e477" title="Performs collision detection for the scene over elapsedTime. ">PxScene::collide()</a>, in <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints. ">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inflation</td><td>Scale factor for computed world bounds. Box extents are multiplied by this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The soft body's bounding box.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxBounds3.html" title="Class representing 3D range or axis aligned bounding box. ">PxBounds3</a> </dd></dl>

<p>Implements <a class="el" href="classPxActor.html#acab89ce3ee6d27b580063d131a417721">PxActor</a>.</p>

</div>
</div>
<a id="aa4979a4c10cc3c8aaafb1794ca41235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4979a4c10cc3c8aaafb1794ca41235b">&#9670;&nbsp;</a></span>isSleeping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxSoftBody::isSleeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this soft body is sleeping. </p>
<p>When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or a sleep-affecting property is changed by the user, the entire sleep mechanism should be transparent to the user.</p>
<p>A soft body can only go to sleep if all vertices are ready for sleeping. A soft body is guaranteed to be awake if at least one of the following holds:</p>
<ul>
<li>The wake counter is positive (<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#a05a3a3a2ba5855b5a76d0940f91dbcc9" title="Sets the wake counter for the soft body. ">setWakeCounter()</a>). </dd></dl>
</li>
<li>The velocity of any vertex is above the sleep threshold.</li>
</ul>
<p>If a soft body is sleeping, the following state is guaranteed:</p>
<ul>
<li>The wake counter is zero. </li>
<li>The linear velocity of all vertices is zero.</li>
</ul>
<p>When a soft body gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the soft body has not been added to a scene already.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the soft body is sleeping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#aa4979a4c10cc3c8aaafb1794ca41235b" title="Returns true if this soft body is sleeping. ">isSleeping()</a> </dd></dl>

</div>
</div>
<a id="a43ad653456c5a98273efdd1a1c2a6a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ad653456c5a98273efdd1a1c2a6a83">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxBuffer.html">PxBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a read command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Read operations are scheduled and then flushed in <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate()</a>. Read operations are known to be finished when <a class="el" href="classPxBuffer.html#a4d65e332caf3b67350cc4b8c3e8b2164" title="Provides access to internal memory (either device or pinned host memory depending on PxBufferType)...">PxBuffer::map()</a> returns.</p>
<p><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aaaec92ec86d14c52e56c869eb8dbf2d02" title="Flag to request access to the collision mesh&#39;s positions; read only. ">PxSoftBodyData::ePOSITION_INVMASS</a>, <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aa8aaff83c8728f2f659232795a93c6fcd" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses. ">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aae28b0dbc9e1f627bc4f9ed32065f9219" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses. ">PxSoftBodyData::eSIM_VELOCITY</a> can be read from the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.</p>
<p>The softbody class offers internal cpu buffers that can be used to hold the data. The cpu buffers are accessible through <a class="el" href="classPxSoftBody.html#ada2959c16d25c9b1902b14d41c826fa9" title="Access to the vertices of the collision mesh on the host. ">getPositionInvMassCPU()</a>, <a class="el" href="classPxSoftBody.html#a3ca1ca10f4d7fdc8f791ccb566e05688" title="Access to the vertices of the simulation mesh on the host. ">getSimPositionInvMassCPU()</a> and <a class="el" href="classPxSoftBody.html#a3a26d4abd7f35146b84040deb9d28497" title="Access to the velocities of the simulation mesh on the host. ">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specifies buffer to which data is written to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#a78fd08c0cb5bd219a19986b784228fd7" title="Issues a write command to the PxSoftBody. ">writeData()</a>, <a class="el" href="classPxBuffer.html" title="Buffer for delayed bulk read and write operations supporting host and GPU device memory spaces...">PxBuffer</a>, <a class="el" href="structPxSoftBodyData.html" title="Identifies input and output buffers for PxSoftBody. ">PxSoftBodyData</a> </dd></dl>

</div>
</div>
<a id="a08cf419e841151d0ce25ae99b08761d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cf419e841151d0ce25ae99b08761d7">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a read command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Read operations are scheduled and then flushed in <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate()</a>. Read operations are known to be finished when <a class="el" href="classPxBuffer.html#a4d65e332caf3b67350cc4b8c3e8b2164" title="Provides access to internal memory (either device or pinned host memory depending on PxBufferType)...">PxBuffer::map()</a> returns.</p>
<p><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aaaec92ec86d14c52e56c869eb8dbf2d02" title="Flag to request access to the collision mesh&#39;s positions; read only. ">PxSoftBodyData::ePOSITION_INVMASS</a>, <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aa8aaff83c8728f2f659232795a93c6fcd" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses. ">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aae28b0dbc9e1f627bc4f9ed32065f9219" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses. ">PxSoftBodyData::eSIM_VELOCITY</a> can be read from the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.</p>
<p>The data to read from the GPU is written to the corresponding cpu buffer that a softbody provides. Those cpu buffers are accessible through <a class="el" href="classPxSoftBody.html#ada2959c16d25c9b1902b14d41c826fa9" title="Access to the vertices of the collision mesh on the host. ">getPositionInvMassCPU()</a>, <a class="el" href="classPxSoftBody.html#a3ca1ca10f4d7fdc8f791ccb566e05688" title="Access to the vertices of the simulation mesh on the host. ">getSimPositionInvMassCPU()</a> or <a class="el" href="classPxSoftBody.html#a3a26d4abd7f35146b84040deb9d28497" title="Access to the velocities of the simulation mesh on the host. ">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#a78fd08c0cb5bd219a19986b784228fd7" title="Issues a write command to the PxSoftBody. ">writeData()</a>, <a class="el" href="structPxSoftBodyData.html" title="Identifies input and output buffers for PxSoftBody. ">PxSoftBodyData</a> </dd></dl>

</div>
</div>
<a id="a9f125fff89033d1f57c4fc62eb341257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f125fff89033d1f57c4fc62eb341257">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the softbody. </p>
<p>Releases the softbody and frees its resources. </p>

<p>Implements <a class="el" href="classPxActor.html#a589a4e70ef83b583ee6a4fc5c7767762">PxActor</a>.</p>

</div>
</div>
<a id="ae362061ccf427420adad2670cddecfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae362061ccf427420adad2670cddecfa0">&#9670;&nbsp;</a></span>removeParticleAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeParticleAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addParticleAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4513c65348d23ac90b5c8f4876887d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4513c65348d23ac90b5c8f4876887d1f">&#9670;&nbsp;</a></span>removeParticleFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeParticleFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPBDParticleSystem.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxParticleBuffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a collision filter between a particle and a tetrahedron in the soft body's collision mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classPxParticleBuffer.html" title="The shared base class for all particle buffers, can be instantiated directly to specify granular and ...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle whose collisions with the tetrahedron in the soft body are filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetrahedron in the soft body is filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dc6f89028db451c6318317362bd8357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc6f89028db451c6318317362bd8357">&#9670;&nbsp;</a></span>removeRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method removes a previously-created attachment between a vertex of the soft body collision mesh and the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addRigidAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83d084b9be28d36e2b60ed31c6ff7a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d084b9be28d36e2b60ed31c6ff7a01">&#9670;&nbsp;</a></span>removeRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>vertId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a collision filter between a vertex in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh whose collisions with the rigid body are filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecbad2a586d0f0e89a665f12f0f443bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbad2a586d0f0e89a665f12f0f443bd">&#9670;&nbsp;</a></span>removeSoftBodyAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeSoftBodyAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSoftBody.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>softbody0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an attachment between a soft body and the other soft body. Be aware that destroying the soft body before destroying the attachment is illegal and may cause a crash. </p>
<p>This method removes a previously-created attachment between a point inside a tetrahedron of the collision mesh to a point in another soft body's tetrahedron collision mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">softbody0</td><td>The softbody actor used for the attachment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addSoftBodyAttachment when the attachment is created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fa883fef5ece820ce66d20419d240a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa883fef5ece820ce66d20419d240a1">&#9670;&nbsp;</a></span>removeSoftBodyFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeSoftBodyFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSoftBody.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>otherTetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIdx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a tetrahedron in other soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIdx</td><td>The index of the other tetrahedron in the other softbody's collision mesh whose collision with the tetrahedron with the soft body is filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of the tetrahedron in the softbody's collision mesh whose collision with the other tetrahedron with the other soft body is filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c2acd0c6e03093a0f5898b0759302d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2acd0c6e03093a0f5898b0759302d3">&#9670;&nbsp;</a></span>removeSoftBodyFilters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeSoftBodyFilters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSoftBody.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *&#160;</td>
          <td class="paramname"><em>otherTetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> *&#160;</td>
          <td class="paramname"><em>tetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIndicesSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filters between a tetrahedron in a soft body with another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIndices</td><td>The indices of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndices</td><td>The indices of the tetrahedron of the softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndicesSize</td><td>The size of tetIndices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee868b0dd33b427ab4bc4d9d36cb782b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee868b0dd33b427ab4bc4d9d36cb782b">&#9670;&nbsp;</a></span>removeTetRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::removeTetRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh whose collisions with the rigid body is filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8609ff71ad7b93ec7fde8cce60941eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8609ff71ad7b93ec7fde8cce60941eda">&#9670;&nbsp;</a></span>setParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::setParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxFEMParameters.html">PxFEMParameters</a>&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parameter for FEM internal solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The FEM parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dbf9e415c813765251014de0e54ea87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbf9e415c813765251014de0e54ea87">&#9670;&nbsp;</a></span>setSoftBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::setSoftBodyFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSoftBodyFlag.html#a4f389e612dabaf1fcee1a93365c28a2d">PxSoftBodyFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single softbody flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The flag to set or clear </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new state of the flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97a29ca5485bb36b0abe449d73f594f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a29ca5485bb36b0abe449d73f594f6">&#9670;&nbsp;</a></span>setSoftBodyFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::setSoftBodyFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#ga4bbe198b0dac953e8f058975b5aba958">PxSoftBodyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the softbody flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The new softbody flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3803fd72be58615bd9f124f39150076d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3803fd72be58615bd9f124f39150076d">&#9670;&nbsp;</a></span>setSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::setSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td>
          <td class="paramname"><em>minVelocityIters</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the solver iteration counts for the body. </p>
<p>The solver iteration count determines how accurately deformation and contacts are resolved. If you are having trouble with softbodies that are not as stiff as they should be, then setting a higher position iteration count may improve the behavior.</p>
<p>If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations.</p>
<p><b>Default:</b> 4 position iterations, 1 velocity iteration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minPositionIters</td><td>Minimal number of position iterations the solver should perform for this body. <b>Range:</b> [1,255] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minVelocityIters</td><td>Minimal number of velocity iterations the solver should perform for this body. <b>Range:</b> [1,255]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#aaf3fdb3bcf74fcb0bcd8908174642279" title="Retrieves the solver iteration counts. ">getSolverIterationCounts()</a> </dd></dl>

</div>
</div>
<a id="a05a3a3a2ba5855b5a76d0940f91dbcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a3a3a2ba5855b5a76d0940f91dbcc9">&#9670;&nbsp;</a></span>setWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::setWakeCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gaebdd95ca9e4baca8d6ad390b0902d352">PxReal</a>&#160;</td>
          <td class="paramname"><em>wakeCounterValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wake counter for the soft body. </p>
<p>The wake counter value determines the minimum amount of time until the soft body can be put to sleep. Please note that a soft body will not be put to sleep if any vertex velocity is above the specified threshold or if other awake objects are touching it.</p>
<dl class="section note"><dt>Note</dt><dd>Passing in a positive value will wake the soft body up automatically.</dd></dl>
<p><b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeCounterValue</td><td>Wake counter value. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#aa4979a4c10cc3c8aaafb1794ca41235b" title="Returns true if this soft body is sleeping. ">isSleeping()</a> <a class="el" href="classPxSoftBody.html#a5d7292efe10a77c1f39d34e3844ed4d8" title="Returns the wake counter of the articulation. ">getWakeCounter()</a> </dd></dl>

</div>
</div>
<a id="a78fd08c0cb5bd219a19986b784228fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fd08c0cb5bd219a19986b784228fd7">&#9670;&nbsp;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxBuffer.html">PxBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a write command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Write operations are scheduled and then flushed in <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate()</a>. Write operations are known to be finished when PxScene::fetchResult() returns.</p>
<p><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aa8aaff83c8728f2f659232795a93c6fcd" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses. ">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aae28b0dbc9e1f627bc4f9ed32065f9219" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses. ">PxSoftBodyData::eSIM_VELOCITY</a> can be written to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aaaec92ec86d14c52e56c869eb8dbf2d02" title="Flag to request access to the collision mesh&#39;s positions; read only. ">PxSoftBodyData::ePOSITION_INVMASS</a> is read only, because the collision-mesh vertices are driven by the simulation-mesh vertices, which can be written to with <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aa8aaff83c8728f2f659232795a93c6fcd" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses. ">PxSoftBodyData::eSIM_POSITION_INVMASS</a>.</p>
<p>The softbody class offers internal cpu buffers that can be used to hold the data. The cpu buffers are accessible through <a class="el" href="classPxSoftBody.html#ada2959c16d25c9b1902b14d41c826fa9" title="Access to the vertices of the collision mesh on the host. ">getPositionInvMassCPU()</a>, <a class="el" href="classPxSoftBody.html#a3ca1ca10f4d7fdc8f791ccb566e05688" title="Access to the vertices of the simulation mesh on the host. ">getSimPositionInvMassCPU()</a> and <a class="el" href="classPxSoftBody.html#a3a26d4abd7f35146b84040deb9d28497" title="Access to the velocities of the simulation mesh on the host. ">getSimVelocityInvMassCPU()</a>. Consider to use the <a class="el" href="classPxSoftBodyExt.html#a5e0e263eee8c6d1f12fc682017edbc68" title="Uploads prepared softbody data to the GPU. It ensures that the embedded collision mesh matches the si...">PxSoftBodyExt::commit()</a> extension method if all buffers should get written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specifies buffer from which data is read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#a43ad653456c5a98273efdd1a1c2a6a83" title="Issues a read command to the PxSoftBody. ">readData()</a>, <a class="el" href="classPxBuffer.html" title="Buffer for delayed bulk read and write operations supporting host and GPU device memory spaces...">PxBuffer</a>, <a class="el" href="structPxSoftBodyData.html" title="Identifies input and output buffers for PxSoftBody. ">PxSoftBodyData</a>, <a class="el" href="classPxSoftBodyExt.html#a5e0e263eee8c6d1f12fc682017edbc68" title="Uploads prepared softbody data to the GPU. It ensures that the embedded collision mesh matches the si...">PxSoftBodyExt::commit</a> </dd></dl>

</div>
</div>
<a id="a9d7a70ca890f63491a78f1dd39b4333f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7a70ca890f63491a78f1dd39b4333f">&#9670;&nbsp;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSoftBody::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952a">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a write command to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Write operations are scheduled and then flushed in <a class="el" href="classPxScene.html#a2d154a207b905e73d7771a6c1160d8aa" title="Advances the simulation by an elapsedTime time. ">PxScene::simulate()</a>. Write operations are known to be finished when PxScene::fetchResult() returns.</p>
<p><a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aa8aaff83c8728f2f659232795a93c6fcd" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses. ">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aae28b0dbc9e1f627bc4f9ed32065f9219" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses. ">PxSoftBodyData::eSIM_VELOCITY</a> can be written to the <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aaaec92ec86d14c52e56c869eb8dbf2d02" title="Flag to request access to the collision mesh&#39;s positions; read only. ">PxSoftBodyData::ePOSITION_INVMASS</a> is read only, because the collision-mesh vertices are driven by the simulation-mesh vertices, which can be written to with <a class="el" href="structPxSoftBodyData.html#af8a30db5032df7bbe7ea5ece87c5952aa8aaff83c8728f2f659232795a93c6fcd" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses. ">PxSoftBodyData::eSIM_POSITION_INVMASS</a>.</p>
<p>The data to write to the GPU is taken from the corresponding cpu buffer that a softbody provides. Those cpu buffers are accessible through <a class="el" href="classPxSoftBody.html#ada2959c16d25c9b1902b14d41c826fa9" title="Access to the vertices of the collision mesh on the host. ">getPositionInvMassCPU()</a>, <a class="el" href="classPxSoftBody.html#a3ca1ca10f4d7fdc8f791ccb566e05688" title="Access to the vertices of the simulation mesh on the host. ">getSimPositionInvMassCPU()</a> or <a class="el" href="classPxSoftBody.html#a3a26d4abd7f35146b84040deb9d28497" title="Access to the velocities of the simulation mesh on the host. ">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classPxSoftBody.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSoftBody.html#a43ad653456c5a98273efdd1a1c2a6a83" title="Issues a read command to the PxSoftBody. ">readData()</a>, <a class="el" href="structPxSoftBodyData.html" title="Identifies input and output buffers for PxSoftBody. ">PxSoftBodyData</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxSoftBody_8h_source.html">PxSoftBody.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPxSoftBody.html">PxSoftBody</a></li>
    <li class="footer">Copyright &copy; 2008-2022 NVIDIA Corporation, 2788 San Tomas Expressway, Santa Clara, CA 95051 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a></li>
  </ul>
</div>
</body>
</html>
