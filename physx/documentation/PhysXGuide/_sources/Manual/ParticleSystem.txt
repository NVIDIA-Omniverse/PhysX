.. _ParticleSystem:

--------------------------------
Particle System
--------------------------------

In this chapter we cover a number of topics that are essential for creating particle-based simulations.

=================================
Introduction
=================================

A particle system, defined as an instance of PxParticleSystem class, is capable of simulating different types of dynamics that are represented with a set of particles. While a particle system itself is a generic concept, the underlying solver can be specified to handle different needs. For instance, PxParticleSystem will use Position-based Dynamics (PBD) for solving particle-to-particle dynamics by default. The PBD method is an algorithm to compute dynamics of a material using stable, purely particle-based method. Alternatively, Fluid-Implicit Particle (FLIP) can be used for fluid simulation which is a particle-grid hybrid algorithm. The FLIP method is known to be good at simulating large scale dynamics efficiently.

=================================
Position-based Dynamics (PBD)
=================================

The PBD method is a particle-based method which can handle wide range of dynamics including fluid and deformable objects. Unlike other particle solvers which mostly compute velocity first, PBD finds positions of particles that meet given constraints (such as volume preservation) and then calculates velocities from the optimized positions. This approach makes PBD stable and more robust to larger simulation time-steps.

As a first step to make a PBD simulation in PhysX, an instance of PxParticleSystem can be created as shown below::

    maxParticles = 1000;
    PxParticleSystem* particleSystem = gPhysics->createParticleSystem(maxParticles, 0, 0, 0, *cudaContextManager, 96, PxParticleSolverType::ePBD);

Here, maxParticles reserves the maximum total number of particles to be used in the simulation. Also note that we are providing cudaContextManager. Particle system requires a CUDA capable GPU and a CUDA context manager should be provided to create it. It also specifies maximum neighbors to 96 and its solver type to PBD. Here's an example code to create cudaContextManager::

    PxCudaContextManagerDesc cudaContextManagerDesc;
    PxCudaContextManager* cudaContextManager = PxCreateCudaContextManager(*gFoundation, cudaContextManagerDesc, PxGetProfilerCallback());

Next, we need to specify particle properties such as particle radius and mass. Here's an example code to set up fluid particles::

    const PxReal particleSpacing = 0.2f;
    const PxReal fluidDensity = 1000.f;
    const PxReal restOffset = 0.5f * particleSpacing / 0.6f;
    const PxReal solidRestOffset = restOffset;
    const PxReal fluidRestOffset = restOffset * 0.6f;
    const PxReal renderRadius = fluidRestOffset;
    const PxReal particleMass = fluidDensity * 1.333f * 3.14159f * renderRadius * renderRadius * renderRadius;
    particleSystem->setRestOffset(restOffset);
    particleSystem->setContactOffset(restOffset + 0.01f);
    particleSystem->setParticleContactOffset(PxMax(solidRestOffset + 0.01f, fluidRestOffset / 0.6f));
    particleSystem->setSolidRestOffset(solidRestOffset);
    particleSystem->setFluidRestOffset(fluidRestOffset);

Here's the definition of each setter function used above:

* particleSystem->setRestOffset(...): set rest the offset between particles and rigids or soft bodies
* particleSystem->setContactOffset(...): set the contact offset for the collision between particles and rigids or soft bodies
* particleSystem->setParticleContactOffset(...): set the contact offset for the interactions between particles
* particleSystem->setSolidRestOffset(...): set the solid rest offset
* particleSystem->setFluidRestOffset(...): set the fluid rest offset

Once configured, the new particle system can be added to the scene::

    gScene->addParticleSystem(*particleSystem);

So far we haven't initialized the particle set itself. The new particles need to be positioned with initial velocities with phase flags that defines particles' behavior. Finally, we need to specify which particles are participating in the simulation with an active particles indices array. This can be achived by creating host-side buffers, filling those buffers with particle values, and then writing them to the particle system. Here's a sample code for initializing fluid particles::

    const PxU32 particlePhase = PxCreateParticlePhase(0, PxParticlePhaseFlags(PxParticlePhaseFlag::eParticlePhaseFluid | PxParticlePhaseFlag::eParticlePhaseSelfCollide));

    PxBuffer* activeIndexBuf = gPhysics->createBuffer(maxParticles * sizeof(PxU32), PxBufferType::eHOST, cudaContextManager);
    PxBuffer* phaseBuf = gPhysics->createBuffer(maxParticles * sizeof(PxU32), PxBufferType::eHOST, cudaContextManager);
    PxBuffer* positionInvMassBuf = gPhysics->createBuffer(maxParticles * sizeof(PxVec4), PxBufferType::eHOST, cudaContextManager);
    PxBuffer* velocityBuf = gPhysics->createBuffer(maxParticles * sizeof(PxVec4), PxBufferType::eHOST, cudaContextManager);

    PxU32* activeIndex = (PxU32*)activeIndexBuf->map();
    PxU32* phase = (PxU32*)phaseBuf->map();
    PxVec4* positionInvMass = (PxVec4*)positionInvMassBuf->map();
    PxVec4* velocity = (PxVec4*)velocityBuf->map();

    PxReal x = position.x;
    PxReal y = position.y;
    PxReal z = position.z;
    PxReal maxY = y;
    PxReal maxZ = z;

    for (PxU32 i = 0; i < 10; ++i)
    {
        for (PxU32 j = 0; j < 10; ++j)
        {
            for (PxU32 k = 0; k < 10; ++k)
            {
                const PxU32 index = i * 100 + j * 10 + k;

                PxVec4 pos(x, y, z, 1.0f / particleMass);
                activeIndex[index] = index;
                phase[index] = particlePhase;
                positionInvMass[index] = pos;
                velocity[index] = PxVec4(0.0f);

                z += particleSpacing;
            }
            maxZ = z - particleSpacing;
            z = position.z;
            y += particleSpacing;
        }
        maxY = y - particleSpacing;
        y = position.y;
        x += particleSpacing;
    }

    activeIndexBuf->unmap();
    phaseBuf->unmap();
    positionInvMassBuf->unmap();
    velocityBuf->unmap();

    particleSystem->writeData(PxParticleDataFlag::eACTIVE_PARTICLE, *activeIndexBuf, true);
    particleSystem->writeData(PxParticleDataFlag::ePHASE, *phaseBuf, true);
    particleSystem->writeData(PxParticleDataFlag::ePOSITION_INVMASS, *positionInvMassBuf, true);
    particleSystem->writeData(PxParticleDataFlag::eVELOCITY, *velocityBuf, true);
    particleSystem->setNbActiveParticles(maxParticles);

This code above will create a cubic-shaped particle set.

+++++
Cloth
+++++

Particles in a particle system can not only behave like fluid or granular material. It is possible to insert additional constraints into the particle systems to connect a group of particles to act like a piece of cloth. To set up a cloth, a couple of additional buffers are required to define the connections between the particles. The following code can be added to the normal particle setup to create a piece of cloth::

	PxParticleSpringBuffers* particleSpringBuffers = PxCreateParticleSpringBuffers(maxParticles, maxSprings, cudaContextManager);
	PxParticleTriangleBuffers* particleTriangleBuffers = PxCreateParticleTriangleBuffers(maxParticles, particleSystem->getMaxParticleTriangles(), cudaContextManager);
	PxBuffer* restPositionBuf = gPhysics->createBuffer(maxParticles * sizeof(PxVec4), PxBufferType::eHOST, cudaContextManager);

	PxParticleSprings* particleSprings = particleSpringBuffers->map();
	PxParticleTriangles* particleTriangles = particleTriangleBuffers->map();
	PxVec4* restPosition = (PxVec4*)restPositionBuf->map();	
	
	...
	
	//Places a spring between particles at location i and j in the vertex buffer
	particleSprings->addSpring(i, j, stiffness, springRestLength, springDamping);

	//Adds a triangle between vertices at locations a, b and c in the vertex buffer. Triangles are used to compute approximated aerodynamic forces for cloth
	particleTriangles->addTriangle(a, b, c, 0, vertexCount);

	...

	restPositionBuf->unmap();	
	particleTriangleBuffers->unmap();
	particleSpringBuffers->unmap();

	particleSystem->updateSpringTopology(maxSprings, particleSprings->mNumSprings);
	particleSpringBuffers->writeData(*particleSystem, true);

	particleSystem->setNbTriangleParticles(maxParticles);
	particleTriangleBuffers->writeData(*particleSystem, true);

	particleSpringBuffers->release();
	particleTriangleBuffers->release();


+++++++++++
Inflatables
+++++++++++

A group of particles that is configured as cloth can be converted to an inflatable body if the triangle mesh used to create the inflatable is a non-overlapping, watertight mesh with a well defined volume. In contrast to a simple cloth, an inflatable body will simulate pressure inside the object. The pressure factor to control the behavior defines the volume the inflatable body tries to maintain during simulation. If the pressure is set to a value larger than one, the inflatable will show a behavior like a balloon. The setup is similar to cloth with some extensions:: 

	PxInflatableBuffers* inflatableBuffers = PxCreateInflatableBuffers(maxParticles, particleSystem->getMaxParticleTriangles(), maxInflatables, cudaContextManager);
	PxInflatables* inflatables = inflatableBuffers->map();
	
	...
	
	//The cooker helps to generate spring and triangle constraints. The constraints from the cooker need to be written into the corresponding buffers.
	PxClothCooker* cooker = PxCreateClothCooker(vertexCount, vertices.begin(), indices.size(), indices.begin(), particleSprings->mMaxSprings, particleSystem->getMaxParticleTriangles(),
		PxClothConstraint::eTYPE_HORIZONTAL_CONSTRAINT | PxClothConstraint::eTYPE_VERTICAL_CONSTRAINT | PxClothConstraint::eTYPE_DIAGONAL_CONSTRAINT);
	cooker->cookConstraints();
	cooker->calculateMeshVolume();
	
	PxU32 cookedTriangleIndicesCount = cooker->getTriangleIndicesCount();
	PxU32* cookedTriangleIndices = cooker->getTriangleIndices();
	for (PxU32 t = 0; t < cookedTriangleIndicesCount; t += 3)	
		particleTriangles->addTriangle(cookedTriangleIndices[t + 0], cookedTriangleIndices[t + 1], cookedTriangleIndices[t + 2], 0, vertexCount);
	
	PxU32 constraintCount = cooker->getConstraintCount();
	PxClothConstraint* constraintBuffer = cooker->getConstraints();
	for (PxU32 i = 0; i < constraintCount; i++)
	{
		const PxClothConstraint& c = constraintBuffer[i];
		particleSprings->addSpring(c.mParticleIndexA, c.mParticleIndexB, stiffness, c.mLength);
	}
	
	...
	
	inflatables->addInflatable(indices.begin(), indices.size(), cooker->getMeshVolume(), pressure, cooker->getConstraintScale());
	inflatableBuffers->unmap();
	
	particleSystem->setNbInflatables(maxInflatables);
	inflatableBuffers->writeData(*particleSystem, true);
	
	inflatableBuffers->release();

It is required to specify the maximal number of inflatables a particle system can contain when creating it.

+++++++
Volumes
+++++++

Volumes are used to accelerate scene queries, e.g. to support picking. Similar to inflatables, it is required to specify the maximal number of volumes a particle system can contain when creating it::

	PxParticleVolumeBuffers* volumeBuffers = PxCreateParticleVolumeBuffers(maxVolumes, cudaContextManager);	
	PxParticleVolumes* volumes = volumeBuffers->map(); 
	volumes->addParticleVolume(firstVertexOffset, numVertices, firstTriangleOffset, numTriangles);
	volumeBuffers->unmap();
	
	particleSystem->setNbVolumes(maxVolumes);
	volumeBuffers->writeData(*particleSystem, true);
	
	volumeBuffers->release();

Because scene queries run on the CPU, the volume data must be synchronized every frame::

	static_cast<PxPBDParticleSystem*>(particleSystem)->readPBDData(PxPBDParticleDataFlag::ePARTICLE_VOLUME, *volumeBuffers->mVolumes);

=================================
Fluid-Implicit Particle (FLIP)
=================================

While PBD is a multi-purpose dynamics solver, FLIP focuses on fluid simulation. The FLIP method combines the power of particle-based and grid-based methods; a particle-based approach is generally great for capturing vorticities and detailed flow while a grid-based method is efficient at solving large scale fluid motion. This is achived by solving advection of particles using particle-level time-integration, and solving other internal dynamics using grid-based solvers (such as pressure and viscosity). Thus, FLIP is more suitable for simulating large waves or turbulent water.

Turning PBD code into FLIP is straightforward. Simply switching the option when creating PxParticleSystem will flip the solver to FLIP::

    PxParticleSystem* particleSystem = gPhysics->createParticleSystem(maxParticles, 0, 0, 0, *cudaContextManager, 0, PxParticleSolverType::eFLIP);

The FLIP solver can be then configured using PxFLIPParams as shown below::

	PxFLIPParams flipParams;
	flipParams.blendingFactor = 0.95f;
	flipParams.pressureIterationCount = 3;
	
    PxSparseGridParams sgParams;
	sgParams.gridSpacing = 2.f * particleSpacing;
	
    gParticleSystem->setFLIPParams(flipParams);
	gParticleSystem->setSparseGridParams(sgParams);

From the parameters above, blendingFactor defines how much velocity contribution will be derived from FLIP and how much from the more viscous Particle-in-Cell (PIC) solution. FLIP is in fact a variant of the PIC method, but less dissipative and better at capturing vorticities. However, FLIP alone can be somewhat noisy which is mitigated by blending PIC and FLIP contributions. From the code above, we used 0.95f which means it will mix 95% of FLIP and 5% of PIC. The next parameter, pressureIterationCount, defines the accuracy level of the grid-based iterative pressure solver. More iteration means better accuracy but with performance trade off. Finally, the gridSpacing parameter defines the size of a single grid cell. Note that grid-related parameters are grouped into PxSparseGridParams. This is common parameters that can be used for other methods using the sparse grid like Material Point Method.

=================================
Material Point Method (MPM)
=================================

Similar to FLIP method, MPM is also a particle-grid hybrid method for simulating elasto-plastic solids. Compared to the mesh-based methods like Finite Element Method (FEM), MPM can handle topological changes naturally since it does not keep connectivity between particles and utilize underlying grid to handle self-collision and fracture/tearing.

The code for setting up MPM is quite similar to FLIP. First, MPM can be enabled by setting the solver type to PxParticleSolverType::eMPM::

	PxParticleSystem* particleSystem = gPhysics->createParticleSystem(maxParticles, 0, 0, 0, *cudaContextManager, 0, PxParticleSolverType::eMPM);

The MPM parameters can be defined as shown below:

    PxMPMParams mpmParams;
	mpmParams.youngsModulus = 3000.f;
	mpmParams.poissonsRatio = 0.2f;
	mpmParams.isPlastic = true;
	gParticleSystem->setMPMParams(mpmParams);
	
	PxSparseGridParams sgParams;
	sgParams.gridSpacing = 2.f * particleSpacing;
	gParticleSystem->setSparseGridParams(sgParams);

Among the parameters above, youngsModulus (Young's Modulus) defines the stiffness of the material while poissonsRatio (Poisson's Ratio) how much the material deforms in directions perpendicular to the applied force. Next, isPlastic parameter defines whether the material is plastic or elastic only. Like the FLIP example above, MPM also uses PxSparseGridParams to define the sparse grid settings.
